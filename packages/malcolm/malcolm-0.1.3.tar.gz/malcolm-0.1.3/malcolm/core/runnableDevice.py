from method import wrap_method
from device import DState, DEvent, Device


class RunnableDevice(Device):

    def __init__(self, name):
        # superclass init
        super(RunnableDevice, self).__init__(name)

        # some shortcuts for the state table
        do, t, s, e = self.shortcuts()

        # Error condition generated by device
        t(s,             e.Error,     do.error,     s.Fault)
        # Normal operations
        t(s.resettable(), e.Reset,    do.reset,     s.Resetting)
        t(s.Resetting,   e.ResetSta,  do.resetsta,  s.Resetting, s.Idle)
        t(s.Idle,        e.Config,    do.config,    s.Configuring)
        t(s.Configuring, e.ConfigSta, do.configsta, s.Configuring, s.Ready)
        t(s.Ready,       e.Config,    do.config,    s.Configuring)
        t(s.Ready,       e.Run,       do.run,       s.Running)
        t(s.Running,     e.RunSta,    do.runsta,    s.Running, s.Idle, s.Ready)
        # Abort
        t(s.abortable(), e.Abort,     do.abort,     s.Aborting)
        t(s.Aborting,    e.AbortSta,  do.abortsta,  s.Aborting, s.Aborted)

    def do_reset(self, event):
        """Check and attempt to clear any error state, arranging for a
        callback doing self.post(DEvent.ResetSta, resetsta) when progress has
        been made, where resetsta is any device specific reset status
        """
        raise NotImplementedError

    def do_resetsta(self, event, resetsta):
        """Examine configsta for configuration progress, returning
        DState.Resetting if still in progress, or DState.Idle if done.
        """
        raise NotImplementedError

    def do_config(self, event, **config_params):
        """Start doing a configuration using config_params, arranging for a
        callback doing self.post(DEvent.ConfigSta, configsta) when progress has
        been made, where configsta is any device specific configuration status
        """
        raise NotImplementedError

    def do_configsta(self, event, configsta):
        """Examine configsta for configuration progress, returning
        DState.Configuring if still in progress, or DState.Ready if done.
        """
        raise NotImplementedError

    def do_run(self, event):
        """Start doing a run, arranging for a callback doing
        self.post(DEvent.RunSta, runsta) when progress has been made, where
        runsta is any device specific run status
        """
        raise NotImplementedError

    def do_runsta(self, event, runsta):
        """Examine runsta for run progress, returning DState.Running if still
        in progress, DState.Ready if done and another run can be started
        without reconfiguration, or DState.Idle if done and configuration is
        needed before another run can be started.
        """
        raise NotImplementedError

    def do_abort(self, event):
        """Start doing an abort, arranging for a callback doing
        self.post(DEvent.AbortSta, runsta) when progress has been made, where
        abortsta is any device specific abort status
        """
        raise NotImplementedError

    def do_abortsta(self, event, abortsta):
        """Examine abortsta for abort progress, returning DState.Aborting if still
        in progress or DState.Aborted if done.
        """
        raise NotImplementedError

    @wrap_method(only_in=DState)
    def assert_valid(self, arg1, arg2="arg2default"):
        """Check whether a set of configuration parameters is valid or not. Each
        parameter name must match one of the names in self.attributes. This set
        of parameters should be checked in isolation, no device state should be
        taken into account. It is allowed from any DState and raises an error
        if the set of configuration parameters is invalid.
        """
        raise NotImplementedError

    @wrap_method(only_in=DState.abortable())
    def abort(self):
        """Abort configuration or abandon the current run whether it is
        running or paused. It blocks until the device is in a rest state:
         * Normally it will return a DState.Aborted Status
         * If something goes wrong it will return a DState.Fault Status
        """
        self.post(DEvent.Abort)
        self.wait_for_transition(DState.rest())

    @wrap_method(only_in=DState.resettable())
    def reset(self):
        """Try and reset the device into DState.Idle. It blocks until the 
        device is in a rest state:
         * Normally it will return a DState.Idle Status
         * If something goes wrong it will return a DState.Fault Status
        """
        self.post(DEvent.Reset)
        self.wait_for_transition(DState.rest())

    @wrap_method(only_in=DState.configurable(), args_from=assert_valid)
    def configure(self, **params):
        """Assert params are valid, then use them to configure a device for a run.
        It blocks until the device is in a rest state:
         * Normally it will return a DState.Configured Status
         * If the user aborts then it will return a DState.Aborted Status
         * If something goes wrong it will return a DState.Fault Status
        """
        self.assert_valid(**params)
        self.post(DEvent.Config, **params)
        self.wait_for_transition(DState.rest())

    @wrap_method(only_in=DState.runnable())
    def run(self):
        """Start a configured device running. It blocks until the device is in a
        rest state:
         * Normally it will return a DState.Idle Status
         * If the device allows many runs from a single configure the it
           will return a DState.Ready Status
         * If the user aborts then it will return a DState.Aborted Status
         * If something goes wrong it will return a DState.Fault Status
        """
        self.post(DEvent.Run)
        self.wait_for_transition(DState.rest())

    @wrap_method(only_in=DState, args_from=assert_valid)
    def configure_run(self, **params):
        """Try and configure and run a device in one step. It blocks until the
        device is in a rest state:
         * Normally it will return a DState.Idle Status
         * If the device allows many runs from a single configure then it
           will return a DState.Ready Status
         * If the user aborts then it will return a DState.Aborted Status
         * If something goes wrong it will return a DState.Fault Status
        """
        # If we can't configure from our current state
        if self.state not in DState.configurable():
            # If we are abortable then abort
            if self.state in DState.abortable():
                self.abort()
            # Now try a reset to bring us back to idle
            if self.state in DState.resettable():
                self.reset()
        # Now if we are configurable then do so
        if self.state in DState.configurable():
            self.configure(**params)
            # And now if we are ready then do a run
            if self.state == DState.Ready:
                self.run()
