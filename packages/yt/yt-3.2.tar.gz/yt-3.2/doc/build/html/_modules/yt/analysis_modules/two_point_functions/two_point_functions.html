<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>yt.analysis_modules.two_point_functions.two_point_functions &mdash; The yt Project 3.2-dev documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/bootswatch-3.3.4/readable/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '3.2-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../../../_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="The yt Project 3.2-dev documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" />
    
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-391373-2']);
      _gaq.push(['_setDomainName', 'yt-project.org']);
      _gaq.push(['_setAllowHash', false]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../../index.html"><img src="../../../../_static/yt_icon.png">
          The yt Project</a>
        <span class="navbar-text navbar-version pull-left"><b>3.2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../../help/index.html">How to get help</a></li>
                <li><a href="../../../../quickstart/index.html">Quickstart notebooks</a></li>
                <li><a href="../../../../cookbook/index.html">Cookbook</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installing.html">Getting and Installing yt</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../installing.html#getting-yt">Getting yt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../installing.html#testing-your-installation">Testing Your Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../installing.html#switching-between-yt-2-x-and-yt-3-x">Switching between yt-2.x and yt-3.x</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../quickstart/index.html">yt Quickstart</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../quickstart/introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../quickstart/data_inspection.html">Data Inspection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../quickstart/simple_visualization.html">Simple Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../quickstart/data_objects_and_time_series.html">Data Objects and Time Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../quickstart/derived_fields_and_profiles.html">Derived Fields and Profiles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../quickstart/volume_rendering.html">Volume Rendering</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../yt3differences.html">What&#8217;s New and Different in yt 3.0?</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../yt3differences.html#updating-to-yt-3-0-from-old-versions-and-going-back">Updating to yt 3.0 from Old Versions (and going back)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../yt3differences.html#converting-old-scripts-to-work-with-yt-3-0">Converting Old Scripts to Work with yt 3.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../yt3differences.html#cool-new-things">Cool New Things</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../yt3differences.html#api-changes">API Changes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cookbook/index.html">The Cookbook</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../cookbook/index.html#getting-the-sample-data">Getting the Sample Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../cookbook/index.html#example-scripts">Example Scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../cookbook/index.html#example-notebooks">Example Notebooks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../visualizing/index.html">Visualizing Data</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/plots.html">How to Make Plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/callbacks.html">Plot Modifications: Overplotting Contours, Velocities, Particles, and More</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/manual_plotting.html">Using the Manual Plotting Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/volume_rendering.html">Volume Rendering: Making 3D Photorealistic Isocontoured Images</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/hardware_volume_rendering.html">Hardware Volume Rendering on NVidia Graphics cards</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/sketchfab.html">3D Surfaces and Sketchfab</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/mapserver.html">Mapserver - A Google-Maps-like Interface to your Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/streamlines.html">Streamlines: Tracking the Trajectories of Tracers in your Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/colormaps/index.html">Colormaps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/writing_fits_images.html">Writing FITS Images</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../analyzing/index.html">General Data Analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/fields.html">Fields in yt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/creating_derived_fields.html">Creating Derived Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/objects.html">Data Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/units/index.html">Symbolic Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/filtering.html">Filtering your Dataset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/generating_processed_data.html">Generating Processed Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/time_series_analysis.html">Time Series Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/parallel_computation.html">Parallel Computation With yt</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../analyzing/analysis_modules/index.html">Topic-Specific Analysis Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/analysis_modules/halo_analysis.html">Halo Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/analysis_modules/synthetic_observation.html">Synthetic Observation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/analysis_modules/exporting.html">Exporting to External Radiation Transport Codes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/analysis_modules/two_point_functions.html">Two Point Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/analysis_modules/clump_finding.html">Clump Finding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/analysis_modules/particle_trajectories.html">Particle Trajectories</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/analysis_modules/ellipsoid_analysis.html">Halo Ellipsoid Analysis</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examining/index.html">Loading and Examining Data</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../examining/loading_data.html">Loading Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../examining/generic_array_data.html">Loading Generic Array Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../examining/generic_particle_data.html">Loading Generic Particle Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../examining/spherical_data.html">Loading Spherical Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../examining/low_level_inspection.html">Low-Level Data Inspection: Accessing Raw Data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developing/index.html">Developing in yt</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/intro.html">Getting Involved</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/developing.html">How to Develop yt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/building_the_docs.html">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/testing.html">Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/debugdrive.html">Debugging yt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/creating_datatypes.html">Creating Data Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/creating_derived_fields.html">Creating Derived Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/creating_derived_quantities.html">Creating Derived Quantities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/creating_frontend.html">Creating A New Code Frontend</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/external_analysis.html">Using yt with External Analysis Tools</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/index.html">Reference Materials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../reference/code_support.html">Code Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../reference/command-line.html">Command-Line Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../reference/api/api.html">API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../reference/configuration.html">Customizing yt: The Configuration and Plugin Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../reference/field_list.html">Field List</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../reference/changelog.html">ChangeLog</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/index.html">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../faq/index.html#version-installation">Version &amp; Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../faq/index.html#code-errors-and-failures">Code Errors and Failures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../faq/index.html#units">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../faq/index.html#fields">Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../faq/index.html#data-objects">Data Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../faq/index.html#developing">Developing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../faq/index.html#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../help/index.html">Getting Help</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#don-t-panic-and-don-t-give-up">Don&#8217;t panic and don&#8217;t give up</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#update-to-the-latest-version">Update to the latest version</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#search-the-documentation-faq-and-mailing-lists">Search the documentation, FAQ, and mailing lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#look-at-the-source-code">Look at the source code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#isolate-and-document-your-problem">Isolate and document your problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#go-on-irc-to-ask-a-question">Go on IRC to ask a question</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#ask-the-mailing-list">Ask the mailing list</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#submit-a-bug-report">Submit a bug report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#special-issues">Special Issues</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../about/index.html">About yt</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../about/index.html#what-is-yt">What is yt?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../about/index.html#who-is-yt">Who is yt?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../about/index.html#history-of-yt">History of yt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../about/index.html#how-do-i-contact-yt">How do I contact yt?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../about/index.html#how-do-i-cite-yt">How do I cite yt?</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <h1>Source code for yt.analysis_modules.two_point_functions.two_point_functions</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Two Point Functions Framework.</span>



<span class="sd">&quot;&quot;&quot;</span>

<span class="c">#-----------------------------------------------------------------------------</span>
<span class="c"># Copyright (c) 2013, yt Development Team.</span>
<span class="c">#</span>
<span class="c"># Distributed under the terms of the Modified BSD License.</span>
<span class="c">#</span>
<span class="c"># The full license is in the file COPYING.txt, distributed with this software.</span>
<span class="c">#-----------------------------------------------------------------------------</span>

<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">from</span> <span class="nn">yt.mods</span> <span class="kn">import</span> <span class="o">*</span>
<span class="c">#from yt.utilities.math_utils import *</span>
<span class="kn">from</span> <span class="nn">yt.utilities.performance_counters</span> <span class="kn">import</span> <span class="n">yt_counters</span><span class="p">,</span> <span class="n">time_function</span>
<span class="kn">from</span> <span class="nn">yt.utilities.parallel_tools.parallel_analysis_interface</span> <span class="kn">import</span> <span class="n">ParallelAnalysisInterface</span><span class="p">,</span> <span class="n">parallel_blocking_call</span><span class="p">,</span> <span class="n">parallel_root_only</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">yt.utilities.kdtree.api</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">mylog</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;The Fortran kD-Tree did not import correctly.&quot;</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">itertools</span><span class="o">,</span> <span class="nn">inspect</span><span class="o">,</span> <span class="nn">types</span><span class="o">,</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">sep</span> <span class="o">=</span> <span class="mi">12</span>

<div class="viewcode-block" id="TwoPointFunctions"><a class="viewcode-back" href="../../../../reference/api/generated/yt.analysis_modules.two_point_functions.two_point_functions.TwoPointFunctions.html#yt.analysis_modules.two_point_functions.two_point_functions.TwoPointFunctions">[docs]</a><span class="k">class</span> <span class="nc">TwoPointFunctions</span><span class="p">(</span><span class="n">ParallelAnalysisInterface</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot; Initialize a two point functions object.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    total_values : Integer</span>
<span class="sd">        How many total (global) pair calculations to run for each of the</span>
<span class="sd">        functions specified. Default: 1000000.</span>
<span class="sd">    comm_size : Integer</span>
<span class="sd">        How entries are sent during communication. Default: 10000.</span>
<span class="sd">    length_type : String</span>
<span class="sd">        Controls the even spacing of the rulers lengths in</span>
<span class="sd">        logarithmic or linear space, set by &quot;log&quot; or &quot;lin&quot;, respectively.</span>
<span class="sd">        Default: &quot;lin&quot;.</span>
<span class="sd">    length_number : Integer</span>
<span class="sd">        Sets how many lengths to create, evenly spaced by the above</span>
<span class="sd">        parameter. Default: 10.</span>
<span class="sd">    length_range : Float</span>
<span class="sd">        A min/max pair for the range of values to search the over</span>
<span class="sd">        the simulational volume. Default: [sqrt(3)dx, 1/2*shortest box edge],</span>
<span class="sd">        where dx is the smallest grid cell size.</span>
<span class="sd">    vol_ratio : Integer</span>
<span class="sd">        How to multiply-assign subvolumes to the parallel</span>
<span class="sd">        tasks. This number must be an integer factor of the total number of tasks or</span>
<span class="sd">        very bad things will happen. The default value of 1 will assign one task</span>
<span class="sd">        to each subvolume, and there will be an equal number of subvolumes as tasks.</span>
<span class="sd">        A value of 2 will assign two tasks to each subvolume and there will be</span>
<span class="sd">        one-half as many subvolumes as tasks.</span>
<span class="sd">        A value equal to the number of parallel tasks will result in each task</span>
<span class="sd">        owning a complete copy of all the fields data, meaning each task will be</span>
<span class="sd">        operating on the identical full volume.</span>
<span class="sd">        Setting it to -1 will automatically adjust it such that each task</span>
<span class="sd">        owns the entire volume. Default = 1.</span>
<span class="sd">    salt : Integer</span>
<span class="sd">        A number that will be added to the random number generator</span>
<span class="sd">        seed. Use this if a different random series of numbers is desired when</span>
<span class="sd">        keeping everything else constant from this set: (MPI task count, </span>
<span class="sd">        number of ruler lengths, ruler min/max, number of functions,</span>
<span class="sd">        number of point pairs per ruler length). Default = 0.</span>
<span class="sd">    theta : Float</span>
<span class="sd">        For random pairs of points, the second point is found by traversing</span>
<span class="sd">        a distance along a ray set by the angle (phi, theta) from the first</span>
<span class="sd">        point. To keep this angle constant, set ``theta`` to a value in the</span>
<span class="sd">        range [0, pi]. Default = None, which will randomize theta for</span>
<span class="sd">        every pair of points.</span>
<span class="sd">    phi : Float</span>
<span class="sd">        Similar to theta above, but the range of values is [0, 2*pi).</span>
<span class="sd">        Default = None, which will randomize phi for every pair of points.</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; tpf = TwoPointFunctions(ds, [&quot;velocity_x&quot;, &quot;velocity_y&quot;, &quot;velocity_z&quot;],</span>
<span class="sd">    ... total_values=1e5, comm_size=10000, </span>
<span class="sd">    ... length_number=10, length_range=[1./128, .5],</span>
<span class="sd">    ... length_type=&quot;log&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="TwoPointFunctions.__init__"><a class="viewcode-back" href="../../../../reference/api/generated/yt.analysis_modules.two_point_functions.two_point_functions.TwoPointFunctions.__init__.html#yt.analysis_modules.two_point_functions.two_point_functions.TwoPointFunctions.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">left_edge</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right_edge</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">total_values</span><span class="o">=</span><span class="mi">1000000</span><span class="p">,</span> <span class="n">comm_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">length_type</span><span class="o">=</span><span class="s">&quot;lin&quot;</span><span class="p">,</span>
            <span class="n">length_number</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">length_range</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vol_ratio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">salt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">ParallelAnalysisInterface</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fKD</span>
        <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&quot;You need to install the Forthon kD-Tree&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fsets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span> <span class="o">=</span> <span class="n">fields</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constant_theta</span> <span class="o">=</span> <span class="n">theta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constant_phi</span> <span class="o">=</span> <span class="n">phi</span>
        <span class="c"># MPI stuff.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vol_ratio</span> <span class="o">=</span> <span class="n">vol_ratio</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol_ratio</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vol_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_values</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_values</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="c"># For communication.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recv_hooks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_hooks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">done_hooks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">comm_size</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_values</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">max_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">domain_right_edge</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">domain_left_edge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_edge</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">domain_right_edge</span> <span class="o">+</span> <span class="n">ds</span><span class="o">.</span><span class="n">domain_left_edge</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="c"># Figure out the range of ruler lengths.</span>
        <span class="k">if</span> <span class="n">length_range</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">length_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_smallest_dx</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">min_edge</span><span class="o">/</span><span class="mf">2.</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">length_range</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;length_range must have two values.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">length_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">length_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;length_range[1] must be larger than length_range[0]&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">length_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_edge</span><span class="o">/</span><span class="mf">2.</span><span class="p">:</span>
                <span class="n">length_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_edge</span><span class="o">/</span><span class="mf">2.</span>
                <span class="n">mylog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Automatically adjusting length_range[1] to half the shortest box edge.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">length_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">length_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.</span><span class="p">:</span>
            <span class="n">mylog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Automatically adjusting length_range[0] to </span><span class="si">%1.5e</span><span class="s">.&quot;</span> <span class="o">%</span> \
                <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_smallest_dx</span><span class="p">()))</span>
            <span class="n">length_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_smallest_dx</span><span class="p">()</span>
        <span class="c"># Make the list of ruler lengths.</span>
        <span class="k">if</span> <span class="n">length_type</span> <span class="o">==</span> <span class="s">&quot;lin&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">length_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">length_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">length_number</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">length_type</span> <span class="o">==</span> <span class="s">&quot;log&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">length_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">length_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">length_number</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Something went wrong.</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s">&quot;length_type is either </span><span class="se">\&quot;</span><span class="s">lin</span><span class="se">\&quot;</span><span class="s"> or </span><span class="se">\&quot;</span><span class="s">log</span><span class="se">\&quot;</span><span class="s">.&quot;</span><span class="p">)</span>
        <span class="c"># Subdivide the volume.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">left_edge</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">right_edge</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">domain_left_edge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">right_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">domain_right_edge</span>
            <span class="c"># This ds business below has to do with changes made for halo</span>
            <span class="c"># finding on subvolumes and serves no purpose here except</span>
            <span class="c"># compatibility. This is not the best policy, if I&#39;m honest.</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">region</span><span class="p">([</span><span class="mf">0.</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_edge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_edge</span><span class="p">)</span>
            <span class="n">padded</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">LE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">RE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">partition_index_3d</span><span class="p">(</span><span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                <span class="n">rank_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol_ratio</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left_edge</span> <span class="o">=</span> <span class="n">left_edge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">right_edge</span> <span class="o">=</span> <span class="n">right_edge</span>
            <span class="c"># We do this twice, first with no &#39;buffer&#39; to get the unbuffered</span>
            <span class="c"># self.LE/RE, and then second to get a buffered self.ds.</span>
            <span class="n">padded</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">LE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">RE</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">partition_region_3d</span><span class="p">(</span><span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">,</span>
                    <span class="n">rank_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vol_ratio</span><span class="p">)</span>
            <span class="n">padded</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">partition_region_3d</span><span class="p">(</span><span class="n">left_edge</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> \
                <span class="n">right_edge</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rank_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vol_ratio</span><span class="p">)</span>
        <span class="n">mylog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;LE </span><span class="si">%s</span><span class="s"> RE </span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">LE</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">RE</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">right_edge</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">left_edge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">mtrand</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span> <span class="o">=</span> <span class="mi">1234</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mine</span> <span class="o">+</span> <span class="n">salt</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="TwoPointFunctions.add_function"><a class="viewcode-back" href="../../../../reference/api/generated/yt.analysis_modules.two_point_functions.two_point_functions.TwoPointFunctions.add_function.html#yt.analysis_modules.two_point_functions.two_point_functions.TwoPointFunctions.add_function">[docs]</a>    <span class="k">def</span> <span class="nf">add_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">out_labels</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">corr_norm</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Add a function to the list that will be evaluated at the</span>
<span class="sd">        generated pairs of points.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function : Function</span>
<span class="sd">            The two point function of the form fcn(a, b, r1, r2, vec).</span>
<span class="sd">        out_labels : List of strings</span>
<span class="sd">            A list of strings labeling the outputs of the function.</span>
<span class="sd">        sqrt : List of booleans</span>
<span class="sd">            A list of booleans which when True will square-root the corresponding</span>
<span class="sd">            element of the output in the text output (write_out_means()).</span>
<span class="sd">        corr_norm : Float</span>
<span class="sd">            Used when calculating two point correlations. If set, the output</span>
<span class="sd">            of the function is divided by this number. Default = None.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; f1 = tpf.add_function(function=rms_vel, out_labels=[&#39;RMSvdiff&#39;],</span>
<span class="sd">        ... sqrt=[True])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fargs</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fargs</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s">&quot;The function </span><span class="si">%s</span><span class="s"> needs five arguments.&quot;</span> <span class="o">%</span>\
                <span class="n">function</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="n">out_labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out_labels</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_labels</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s">&quot;Please specify at least one out_labels for function </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span>\
                <span class="n">function</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="n">sqrt</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sqrt</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sqrt</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s">&quot;Please have the same number of elements in out_labels as in sqrt for function </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span>\
                <span class="n">function</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FcnSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_edge</span><span class="p">,</span>
            <span class="n">out_labels</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span><span class="n">corr_norm</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fsets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fsets</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    
<div class="viewcode-block" id="TwoPointFunctions.run_generator"><a class="viewcode-back" href="../../../../reference/api/generated/yt.analysis_modules.two_point_functions.two_point_functions.TwoPointFunctions.run_generator.html#yt.analysis_modules.two_point_functions.two_point_functions.TwoPointFunctions.run_generator">[docs]</a>    <span class="k">def</span> <span class="nf">run_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;After all the functions have been added, run the generator.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; tpf.run_generator()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">yt_counters</span><span class="p">(</span><span class="s">&quot;run_generator&quot;</span><span class="p">)</span>
        <span class="c"># We need a function!</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mylog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;You need to add at least one function!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="c"># Do all the startup tasks to get the grid points.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">yt_counters</span><span class="p">(</span><span class="s">&quot;build_sort&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_sort_array</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort_done</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">yt_counters</span><span class="p">(</span><span class="s">&quot;build_sort&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yt_counters</span><span class="p">(</span><span class="s">&quot;init_kd_tree&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_kd_tree</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort_done</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">yt_counters</span><span class="p">(</span><span class="s">&quot;init_kd_tree&quot;</span><span class="p">)</span>
        <span class="c"># Store the fields.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stored_fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">yt_counters</span><span class="p">(</span><span class="s">&quot;getting data&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stored_fields</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span>
        <span class="c"># If the arrays haven&#39;t been sorted yet and need to be, do that.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort_done</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stored_fields</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stored_fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort_done</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">yt_counters</span><span class="p">(</span><span class="s">&quot;getting data&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_fields_vals</span><span class="p">()</span>
        <span class="n">yt_counters</span><span class="p">(</span><span class="s">&quot;big loop over lengths&quot;</span><span class="p">)</span>
        <span class="n">t_waiting</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">for</span> <span class="n">bigloop</span><span class="p">,</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_points_array</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mine</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mylog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Doing length </span><span class="si">%1.5e</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">length</span><span class="p">)</span>
            <span class="c"># Things stop when this value below equals total_values.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generated_points</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gen_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int64&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm_cycle_count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">final_comm_cycle_count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sent_done</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setup_done_hooks_on_root</span><span class="p">()</span>
            <span class="c"># While everyone else isn&#39;t done or I&#39;m not done, we loop.</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_should_cycle</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_setup_recv_arrays</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_send_arrays</span><span class="p">()</span>
                <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">mpi_Request_Waitall</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">send_hooks</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">mpi_Request_Waitall</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recv_hooks</span><span class="p">)</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="n">t_waiting</span> <span class="o">+=</span> <span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recv_points</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recv_points</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span> <span class="c"># or \</span>
                        <span class="c">#(np.abs(np.log10(np.abs(self.recv_points))) &gt; 20).any():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;self.recv_points is no good!&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recv_points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fields_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recv_fields_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gen_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recv_gen_array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_eval_points</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gen_array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mine</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generated_points</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">comm_cycle_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">generated_points</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_values</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_send_done_to_root</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mine</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mylog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Length (</span><span class="si">%d</span><span class="s"> of </span><span class="si">%d</span><span class="s">) </span><span class="si">%1.5e</span><span class="s"> took </span><span class="si">%d</span><span class="s"> communication cycles to complete.&quot;</span> <span class="o">%</span> \
                <span class="p">(</span><span class="n">bigloop</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">),</span> <span class="n">length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm_cycle_count</span><span class="p">))</span>
        <span class="n">yt_counters</span><span class="p">(</span><span class="s">&quot;big loop over lengths&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">fKD</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">fKD</span><span class="o">.</span><span class="n">qv_many</span><span class="p">,</span> <span class="n">fKD</span><span class="o">.</span><span class="n">nn_tags</span>
            <span class="n">free_tree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c"># Frees the kdtree object.</span>
        <span class="n">yt_counters</span><span class="p">(</span><span class="s">&quot;allsum&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_allsum_bin_hits</span><span class="p">()</span>
        <span class="n">mylog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Spent </span><span class="si">%f</span><span class="s"> seconds waiting for communication.&quot;</span> <span class="o">%</span> <span class="n">t_waiting</span><span class="p">)</span>
        <span class="n">yt_counters</span><span class="p">(</span><span class="s">&quot;allsum&quot;</span><span class="p">)</span>
        <span class="n">yt_counters</span><span class="p">(</span><span class="s">&quot;run_generator&quot;</span><span class="p">)</span>
    </div>
    <span class="k">def</span> <span class="nf">_init_kd_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds the kd tree of grid center points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Grid cell centers.</span>
        <span class="n">mylog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Multigrid: Building kD-Tree.&quot;</span><span class="p">)</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="s">&quot;x&quot;</span><span class="p">]</span>
        <span class="n">yp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="s">&quot;y&quot;</span><span class="p">]</span>
        <span class="n">zp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="s">&quot;z&quot;</span><span class="p">]</span>
        <span class="n">fKD</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">xp</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">))</span>
        <span class="c"># Normalize the grid points only within the kdtree.</span>
        <span class="n">fKD</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xp</span><span class="p">[:]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fKD</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">yp</span><span class="p">[:]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">fKD</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">zp</span><span class="p">[:]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">fKD</span><span class="o">.</span><span class="n">nn</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">fKD</span><span class="o">.</span><span class="n">sort</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">fKD</span><span class="o">.</span><span class="n">rearrange</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">create_tree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_sort_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When running on a unigrid simulation, the kD tree isn&#39;t necessary.</span>
<span class="sd">        But we need to ensure that the points are sorted in the usual manner</span>
<span class="sd">        allowing values to be found via array indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mylog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Unigrid: finding cell centers.&quot;</span><span class="p">)</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="s">&quot;x&quot;</span><span class="p">]</span>
        <span class="n">yp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="s">&quot;y&quot;</span><span class="p">]</span>
        <span class="n">zp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">[</span><span class="s">&quot;z&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">yp</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">zp</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">([</span><span class="n">zp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">xp</span><span class="p">])</span>
        <span class="k">del</span> <span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">zp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">_build_fields_vals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds an array to store the field values array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">comm_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> \
            <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
        <span class="c"># At the same time build a dict to label the columns.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields_columns</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">field</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fields_columns</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">def</span> <span class="nf">_build_points_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the array that contains the random points as all negatives</span>
<span class="sd">        to start with.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">comm_size</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mf">1.0</span>
    
    <span class="k">def</span> <span class="nf">_setup_done_hooks_on_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Opens non-blocking receives on root pointing to all the other tasks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mine</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recv_done</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">task</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">mine</span><span class="p">:</span> <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recv_done</span><span class="p">[</span><span class="n">task</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int64&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">done_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">mpi_nonblocking_recv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recv_done</span><span class="p">[</span><span class="n">task</span><span class="p">],</span> \
                <span class="n">task</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">15</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">_send_done_to_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tell the root process that I&#39;m done.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># If I&#39;ve already done this, don&#39;t do it again.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sent_done</span><span class="p">:</span> <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mine</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="c"># I send when I *think* things should finish.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send_done</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int64&#39;</span><span class="p">)</span> <span class="o">*</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol_ratio</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm_cycle_count</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">done_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">mpi_nonblocking_send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">send_done</span><span class="p">,</span> \
                    <span class="mi">0</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">15</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># As root, I need to mark myself!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recv_done</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int64&#39;</span><span class="p">)</span> <span class="o">*</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol_ratio</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm_cycle_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sent_done</span> <span class="o">=</span> <span class="bp">True</span>
    
    <span class="k">def</span> <span class="nf">_should_cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if I should continue cycling the communication.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mine</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># If other tasks aren&#39;t finished, this will return False.</span>
            <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">mpi_Request_Testall</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">done_hooks</span><span class="p">)</span>
            <span class="c"># Convolve this with with root&#39;s status.</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">status</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generated_points</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_values</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># If they are all finished, meaning Testall returns True,</span>
                <span class="c"># and root has made its points, we find</span>
                <span class="c"># the biggest value in self.recv_done and stop there.</span>
                <span class="n">status</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recv_done</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># Broadcast the status from root - we stop only if root thinks we should</span>
        <span class="c"># stop.</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">mpi_bcast</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm_cycle_count</span> <span class="o">&lt;</span> <span class="n">status</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="c"># If we&#39;ve come this far, we&#39;re done.</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_setup_recv_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the recv buffers and calls a non-blocking MPI receive pointing</span>
<span class="sd">        to the left-hand neighbor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recv_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">comm_size</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mf">1.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recv_fields_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">comm_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> \
            <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recv_gen_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int64&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recv_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">mpi_nonblocking_recv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recv_points</span><span class="p">,</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mine</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recv_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">mpi_nonblocking_recv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recv_fields_vals</span><span class="p">,</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mine</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">20</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recv_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">mpi_nonblocking_recv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recv_gen_array</span><span class="p">,</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mine</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">40</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_send_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Send the data arrays to the right-hand neighbor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">mpi_nonblocking_send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span>\
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mine</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">mpi_nonblocking_send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields_vals</span><span class="p">,</span>\
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mine</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">20</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_hooks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">mpi_nonblocking_send</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gen_array</span><span class="p">,</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mine</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="mi">40</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_allsum_bin_hits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add up the hits to all the bins globally for all functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">fset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fsets</span><span class="p">:</span>
            <span class="n">fset</span><span class="o">.</span><span class="n">too_low</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">mpi_allreduce</span><span class="p">(</span><span class="n">fset</span><span class="o">.</span><span class="n">too_low</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s">&#39;sum&#39;</span><span class="p">)</span>
            <span class="n">fset</span><span class="o">.</span><span class="n">too_high</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">mpi_allreduce</span><span class="p">(</span><span class="n">fset</span><span class="o">.</span><span class="n">too_high</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s">&#39;sum&#39;</span><span class="p">)</span>
            <span class="n">fset</span><span class="o">.</span><span class="n">binned</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mine</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mylog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Function </span><span class="si">%s</span><span class="s"> had values out of range for these fields:&quot;</span> <span class="o">%</span> \
                    <span class="n">fset</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">field</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fset</span><span class="o">.</span><span class="n">out_labels</span><span class="p">):</span>
                    <span class="n">mylog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Field </span><span class="si">%s</span><span class="s"> had </span><span class="si">%d</span><span class="s"> values too high and </span><span class="si">%d</span><span class="s"> too low that were not binned.&quot;</span> <span class="o">%</span> \
                    <span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">fset</span><span class="o">.</span><span class="n">too_high</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fset</span><span class="o">.</span><span class="n">too_low</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">:</span>
                <span class="n">fset</span><span class="o">.</span><span class="n">length_bin_hits</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">mpi_allreduce</span><span class="p">(</span><span class="n">fset</span><span class="o">.</span><span class="n">length_bin_hits</span><span class="p">[</span><span class="n">length</span><span class="p">],</span> <span class="n">op</span><span class="o">=</span><span class="s">&#39;sum&#39;</span><span class="p">)</span>
                <span class="c"># Find out how many were successfully binned.</span>
                <span class="n">fset</span><span class="o">.</span><span class="n">binned</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">fset</span><span class="o">.</span><span class="n">length_bin_hits</span><span class="p">[</span><span class="n">length</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="c"># Normalize the counts.</span>
                <span class="n">fset</span><span class="o">.</span><span class="n">length_bin_hits</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">fset</span><span class="o">.</span><span class="n">length_bin_hits</span><span class="p">[</span><span class="n">length</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;float64&#39;</span><span class="p">)</span> <span class="o">/</span> \
                    <span class="n">fset</span><span class="o">.</span><span class="n">binned</span><span class="p">[</span><span class="n">length</span><span class="p">]</span>
                <span class="c"># Return it to its original shape.</span>
                <span class="n">fset</span><span class="o">.</span><span class="n">length_bin_hits</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">fset</span><span class="o">.</span><span class="n">length_bin_hits</span><span class="p">[</span><span class="n">length</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fset</span><span class="o">.</span><span class="n">bin_number</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_pick_random_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Picks out size random pairs separated by length *length*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># First make random points inside this subvolume.</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">size</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">r1</span><span class="p">[:,</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">left_edge</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span>
                <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">right_edge</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
        <span class="c"># Next we find the second point, determined by a random</span>
        <span class="c"># theta, phi angle. See Eqns. 1 &amp; 2 from </span>
        <span class="c"># http://mathworld.wolfram.com/SpherePointPicking.html,</span>
        <span class="c"># but phi and theta are switched to the Physics convention.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_phi</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mf">2.</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_phi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_theta</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_theta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">size</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">r2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">r1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">length</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">r2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">length</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">r2</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">r1</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">length</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="c"># Reflect so it&#39;s inside the (full) volume.</span>
        <span class="n">r2</span> <span class="o">%=</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_nearest_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the closest grid cell for each point in a vectorized manner.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">points</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">left_edge</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span>
            <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;int32&#39;</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;int32&#39;</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s">&#39;int32&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Normalize the points to a 1-period for use only within the kdtree.</span>
            <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">fKD</span><span class="o">.</span><span class="n">qv_many</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">T</span>
            <span class="n">fKD</span><span class="o">.</span><span class="n">nn_tags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int64&#39;</span><span class="p">))</span>
            <span class="n">fKD</span><span class="o">.</span><span class="n">find_many_nn_nearest_neighbors</span><span class="p">()</span>
            <span class="c"># The -1 is for fortran counting.</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">fKD</span><span class="o">.</span><span class="n">nn_tags</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">n</span>

    <span class="k">def</span> <span class="nf">_get_fields_vals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given points, return the values for the fields we need for those</span>
<span class="sd">        points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># First find the grid data index field.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_nearest_cell</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
        <span class="c"># Put the field values into the columns of results.</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields_columns</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
            <span class="n">results</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stored_fields</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span>


    <span class="k">def</span> <span class="nf">_eval_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="c"># We need to loop over the points array at least once. Further</span>
        <span class="c"># iterations only happen if we have added new points to the array,</span>
        <span class="c"># but not as many as we want to, so we need to check again to see if</span>
        <span class="c"># we can put more points into the buffer.</span>
        <span class="n">added_points</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="n">added_points</span><span class="p">:</span>
            <span class="c"># If we need to, add more points to the points array.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">generated_points</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_values</span><span class="p">:</span>
                <span class="c"># Look for &#39;empty&#39; slots to put in new pairs.</span>
                <span class="n">select</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">ssum</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="c"># We&#39;ll generate only as many points as we need to/can.</span>
                <span class="n">size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ssum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_values</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">generated_points</span><span class="p">)</span>
                <span class="p">(</span><span class="n">new_r1</span><span class="p">,</span><span class="n">new_r2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pick_random_points</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">generated_points</span> <span class="o">+=</span> <span class="n">size</span>
                <span class="c"># If size != select.sum(), we need to pad the end of new_r1/r2</span>
                <span class="c"># which is what is effectively happening below.</span>
                <span class="n">newpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ssum</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mf">1.</span>
                <span class="n">newpoints</span><span class="p">[:</span><span class="n">size</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_r1</span>
                <span class="n">newpoints</span><span class="p">[:</span><span class="n">size</span><span class="p">,</span><span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="n">new_r2</span>
                <span class="c"># Now we insert them into self.points.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">newpoints</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">added_points</span> <span class="o">=</span> <span class="bp">False</span>
            
            <span class="c"># If we have an empty buffer here, we can skip everything below.</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">added_points</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># Not strictly required, but clearer.</span>
                <span class="k">break</span>
            
            <span class="c"># Now we have a points array that is either full of unevaluated points,</span>
            <span class="c"># or I don&#39;t need to make any new points and I&#39;m just processing the</span>
            <span class="c"># array. Start by finding the indices of the points I own.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm_size</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c"># Doesn&#39;t make a copy - fast!</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">left_edge</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">right_edge</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
            <span class="n">mypoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">mypoints</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># Get the fields values.</span>
                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_fields_vals</span><span class="p">(</span><span class="n">mypoints</span><span class="p">)</span>
                <span class="c"># Put this into self.fields_vals.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fields_vals</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm_size</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fields_vals</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span>
            
            <span class="c"># Put our arrays back into their original shapes cheaply!</span>
            <span class="k">if</span> <span class="n">mypoints</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fields_vals</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm_size</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
            
            <span class="c"># To run the functions, what is key is that the</span>
            <span class="c"># second point in the pair is ours.</span>
            <span class="n">second_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:]</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">((</span><span class="n">second_points</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">left_edge</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                <span class="p">(</span><span class="n">second_points</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="o">.</span><span class="n">right_edge</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">select</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">select</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">points_to_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>
                <span class="n">fields_to_eval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields_vals</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>
                
                <span class="c"># Find the normal vector between our points.</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">points_to_eval</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">points_to_eval</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:])</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="n">vec</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                <span class="c"># I wish there was a better way to do this, but I can&#39;t find it.</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">norm</span><span class="p">):</span>
                    <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">n</span><span class="p">)</span>
                
                <span class="c"># Now evaluate the functions.</span>
                <span class="k">for</span> <span class="n">fcn_set</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fsets</span><span class="p">:</span>
                    <span class="n">fcn_results</span> <span class="o">=</span> <span class="n">fcn_set</span><span class="o">.</span><span class="n">_eval_st_fcn</span><span class="p">(</span><span class="n">fields_to_eval</span><span class="p">,</span><span class="n">points_to_eval</span><span class="p">,</span>
                        <span class="n">vec</span><span class="p">)</span>
                    <span class="n">fcn_set</span><span class="o">.</span><span class="n">_bin_results</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">fcn_results</span><span class="p">)</span>
                
                <span class="c"># Now clear the buffers at the processed points.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">select</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># We didn&#39;t clear any points, so we should move on with our</span>
                <span class="c"># lives and pass this buffer along.</span>
                <span class="n">added_points</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="nd">@parallel_blocking_call</span>
<div class="viewcode-block" id="TwoPointFunctions.write_out_means"><a class="viewcode-back" href="../../../../reference/api/generated/yt.analysis_modules.two_point_functions.two_point_functions.TwoPointFunctions.write_out_means.html#yt.analysis_modules.two_point_functions.two_point_functions.TwoPointFunctions.write_out_means">[docs]</a>    <span class="k">def</span> <span class="nf">write_out_means</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">.txt&quot;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Writes out the weighted-average value for each function for</span>
<span class="sd">        each dimension for each ruler length to a text file. The data is written</span>
<span class="sd">        to files of the name &#39;function_name.txt&#39; in the current working</span>
<span class="sd">        directory.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; tpf.write_out_means()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">fset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fsets</span><span class="p">:</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">write_on_root</span><span class="p">(</span><span class="n">fn</span> <span class="o">%</span> <span class="n">fset</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
            <span class="n">fset</span><span class="o">.</span><span class="n">_avg_bin_hits</span><span class="p">()</span>
            <span class="n">line</span> <span class="o">=</span> <span class="s">&quot;# length&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="s">&quot;count&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">fset</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">fset</span><span class="o">.</span><span class="n">out_labels</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%1.5e</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">length</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">fset</span><span class="o">.</span><span class="n">binned</span><span class="p">[</span><span class="n">length</span><span class="p">])</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">fset</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fset</span><span class="o">.</span><span class="n">sqrt</span><span class="p">[</span><span class="n">dim</span><span class="p">]:</span>
                        <span class="n">line</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%1.5e</span><span class="s">&quot;</span> <span class="o">%</span> \
                            <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">fset</span><span class="o">.</span><span class="n">length_avgs</span><span class="p">[</span><span class="n">length</span><span class="p">][</span><span class="n">dim</span><span class="p">]))</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">line</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%1.5e</span><span class="s">&quot;</span> <span class="o">%</span> \
                            <span class="n">fset</span><span class="o">.</span><span class="n">length_avgs</span><span class="p">[</span><span class="n">length</span><span class="p">][</span><span class="n">dim</span><span class="p">])</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    </div>
    <span class="nd">@parallel_root_only</span>
<div class="viewcode-block" id="TwoPointFunctions.write_out_arrays"><a class="viewcode-back" href="../../../../reference/api/generated/yt.analysis_modules.two_point_functions.two_point_functions.TwoPointFunctions.write_out_arrays.html#yt.analysis_modules.two_point_functions.two_point_functions.TwoPointFunctions.write_out_arrays">[docs]</a>    <span class="k">def</span> <span class="nf">write_out_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">.h5&quot;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Writes out the raw probability bins and the bin edges to an HDF5 file</span>
<span class="sd">        for each of the functions. The files are named </span>
<span class="sd">        &#39;function_name.txt&#39; and saved in the current working directory.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; tpf.write_out_arrays()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mine</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fsets</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fn</span> <span class="o">%</span> <span class="n">fset</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span>
                <span class="n">bin_names</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">prob_names</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">bin_counts</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">fset</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s">&quot;/bin_edges_</span><span class="si">%02d</span><span class="s">_</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> \
                        <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">fset</span><span class="o">.</span><span class="n">out_labels</span><span class="p">[</span><span class="n">dim</span><span class="p">]),</span> \
                        <span class="n">data</span><span class="o">=</span><span class="n">fset</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
                    <span class="n">bin_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;/bin_edges_</span><span class="si">%02d</span><span class="s">_</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> \
                    <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">fset</span><span class="o">.</span><span class="n">out_labels</span><span class="p">[</span><span class="n">dim</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">length</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">):</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s">&quot;/prob_bins_</span><span class="si">%05d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> \
                        <span class="n">data</span><span class="o">=</span><span class="n">fset</span><span class="o">.</span><span class="n">length_bin_hits</span><span class="p">[</span><span class="n">length</span><span class="p">])</span>
                    <span class="n">prob_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;/prob_bins_</span><span class="si">%05d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">bin_counts</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">fset</span><span class="o">.</span><span class="n">too_low</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">fset</span><span class="o">.</span><span class="n">binned</span><span class="p">[</span><span class="n">length</span><span class="p">],</span>
                        <span class="n">fset</span><span class="o">.</span><span class="n">too_high</span><span class="o">.</span><span class="n">sum</span><span class="p">()])</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s">&quot;/bin_edges_names&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">bin_names</span><span class="p">)</span>
                <span class="c">#f.create_dataset(&quot;/prob_names&quot;, data=prob_names)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s">&quot;/lengths&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s">&quot;/counts&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">bin_counts</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
    <span class="nd">@parallel_root_only</span>
<div class="viewcode-block" id="TwoPointFunctions.write_out_correlation"><a class="viewcode-back" href="../../../../reference/api/generated/yt.analysis_modules.two_point_functions.two_point_functions.TwoPointFunctions.write_out_correlation.html#yt.analysis_modules.two_point_functions.two_point_functions.TwoPointFunctions.write_out_correlation">[docs]</a>    <span class="k">def</span> <span class="nf">write_out_correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;A special output function for doing two point correlation functions.</span>
<span class="sd">        Outputs the correlation function xi(r) in a text file</span>
<span class="sd">        &#39;function_name_corr.txt&#39; in the current working directory.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; tpf.write_out_correlation()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">fset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fsets</span><span class="p">:</span>
            <span class="c"># Only operate on correlation functions.</span>
            <span class="k">if</span> <span class="n">fset</span><span class="o">.</span><span class="n">corr_norm</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">write_on_root</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">_correlation.txt&quot;</span> <span class="o">%</span> <span class="n">fset</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
            <span class="n">line</span> <span class="o">=</span> <span class="s">&quot;# length&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">xi&quot;</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">fset</span><span class="o">.</span><span class="n">_corr_sum_norm</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lengths</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%1.5e</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">length</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%1.5e</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">xi</span><span class="p">[</span><span class="n">length</span><span class="p">])</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div></div>
<div class="viewcode-block" id="FcnSet"><a class="viewcode-back" href="../../../../reference/api/generated/yt.analysis_modules.two_point_functions.two_point_functions.FcnSet.html#yt.analysis_modules.two_point_functions.two_point_functions.FcnSet">[docs]</a><span class="k">class</span> <span class="nc">FcnSet</span><span class="p">(</span><span class="n">TwoPointFunctions</span><span class="p">):</span>
<div class="viewcode-block" id="FcnSet.__init__"><a class="viewcode-back" href="../../../../reference/api/generated/yt.analysis_modules.two_point_functions.two_point_functions.FcnSet.__init__.html#yt.analysis_modules.two_point_functions.two_point_functions.FcnSet.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">tpf</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">min_edge</span><span class="p">,</span> <span class="n">out_labels</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">corr_norm</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tpf</span> <span class="o">=</span> <span class="n">tpf</span> <span class="c"># The overarching TPF class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span> <span class="c"># Function to eval between the two points.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_edge</span> <span class="o">=</span> <span class="n">min_edge</span> <span class="c"># The length of the minimum edge of the box.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_labels</span> <span class="o">=</span> <span class="n">out_labels</span> <span class="c"># For output.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sqrt</span> <span class="o">=</span> <span class="n">sqrt</span> <span class="c"># which columns to sqrt on output.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corr_norm</span> <span class="o">=</span> <span class="n">corr_norm</span> <span class="c"># A number used to normalize a correlation function.</span>
        <span class="c"># These below are used to track how many times the function returns</span>
        <span class="c"># unbinned results.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">too_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_labels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int32&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">too_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_labels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int32&#39;</span><span class="p">)</span>
        </div>
<div class="viewcode-block" id="FcnSet.set_pdf_params"><a class="viewcode-back" href="../../../../reference/api/generated/yt.analysis_modules.two_point_functions.two_point_functions.FcnSet.set_pdf_params.html#yt.analysis_modules.two_point_functions.two_point_functions.FcnSet.set_pdf_params">[docs]</a>    <span class="k">def</span> <span class="nf">set_pdf_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_type</span><span class="o">=</span><span class="s">&quot;lin&quot;</span><span class="p">,</span> <span class="n">bin_number</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">bin_range</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Set the parameters used to build the Probability Distribution Function</span>
<span class="sd">        for each ruler length for this function. The values output by the</span>
<span class="sd">        function are slotted into the bins described here.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bin_type : String</span>
<span class="sd">            Controls the edges of the bins spaced evenly in</span>
<span class="sd">            logarithmic or linear space, set by &quot;log&quot; or &quot;lin&quot;, respectively.</span>
<span class="sd">            A single string, or list of strings for N-dim binning.</span>
<span class="sd">            Default = &quot;lin&quot;.</span>
<span class="sd">        bin_number : Integer</span>
<span class="sd">            Sets how many bins to create, evenly spaced by the above</span>
<span class="sd">            parameter. A single integer, or a list of integers for N-dim</span>
<span class="sd">            binning. Default = 1000.</span>
<span class="sd">        bin_range : Float</span>
<span class="sd">            A pair of values giving the range for the bins.</span>
<span class="sd">            A pair of floats (a list), or a list of pairs for N-dim binning.</span>
<span class="sd">            Default = None.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; f1.set_pdf_params(bin_type=&#39;log&#39;, bin_range=[5e4, 5.5e13],</span>
<span class="sd">        ... bin_number=1000)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># This should be called after setSearchParams.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpf</span><span class="p">,</span> <span class="s">&quot;lengths&quot;</span><span class="p">):</span>
            <span class="n">mylog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Please call setSearchParams() before calling setPDFParams().&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="c"># Make sure they&#39;re either all lists or only one is.</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="p">[</span><span class="n">bin_type</span><span class="p">,</span> <span class="n">bin_number</span><span class="p">,</span> <span class="n">bin_range</span><span class="p">]</span>
        <span class="n">lists</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">thing</span> <span class="ow">in</span> <span class="nb">input</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">lists</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">lists</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lists</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">mylog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Either all the inputs need to be lists, or only one.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="c"># Make sure they&#39;re all the same length if they&#39;re lists.</span>
        <span class="k">if</span> <span class="n">lists</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">first_len</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">thing</span> <span class="ow">in</span> <span class="nb">input</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">first_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">first_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">first_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">mylog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Input cannot be an empty list.&quot;</span><span class="p">)</span>
                        <span class="k">return</span> <span class="bp">None</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">first_len</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
                    <span class="n">mylog</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;All the inputs need to have the same length.&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">None</span>
        <span class="c"># If they are not all lists, put the input into lists for convenience.</span>
        <span class="k">if</span> <span class="n">lists</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bin_type</span><span class="p">,</span> <span class="n">bin_number</span> <span class="o">=</span> <span class="p">[</span><span class="n">bin_type</span><span class="p">],</span> <span class="p">[</span><span class="n">bin_number</span><span class="p">]</span>
            <span class="n">bin_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">bin_range</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_type</span> <span class="o">=</span> <span class="n">bin_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_number</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bin_number</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_type</span><span class="p">))</span>
        <span class="c"># Create the dict that stores the arrays to store the bin hits, and</span>
        <span class="c"># the arrays themselves.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length_bin_hits</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpf</span><span class="o">.</span><span class="n">lengths</span><span class="p">:</span>
            <span class="c"># It&#39;s easier to index flattened, but will be unflattened later.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">length_bin_hits</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_number</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int64&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="c"># Create the bin edges for each dimension.</span>
        <span class="c"># self.bins is indexed by dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="c"># Error check.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_range</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;bin_range must have two values.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bin_range</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">bin_range</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;bin_range[1] must be larger than bin_range[0]&quot;</span><span class="p">)</span>
            <span class="c"># Make the edges for this dimension.</span>
            <span class="k">if</span> <span class="n">bin_type</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;lin&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">bin_range</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">bin_range</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">bin_number</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">bin_type</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;log&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">bin_range</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">bin_range</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">bin_number</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s">&quot;bin_edges is either </span><span class="se">\&quot;</span><span class="s">lin</span><span class="se">\&quot;</span><span class="s"> or </span><span class="se">\&quot;</span><span class="s">log</span><span class="se">\&quot;</span><span class="s">.&quot;</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_st_fcn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the value of the function using the provided results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">results</span><span class="p">[:,:</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpf</span><span class="o">.</span><span class="n">fields</span><span class="p">)],</span>
            <span class="n">results</span><span class="p">[:,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tpf</span><span class="o">.</span><span class="n">fields</span><span class="p">):],</span> <span class="n">points</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span><span class="mi">3</span><span class="p">:],</span> <span class="n">vec</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NOTE - A function looks like:</span>
<span class="sd">        def stuff(a,b,r1,r2, vec):</span>
<span class="sd">            return [(a[0] - b[0])/(a[1] + b[1])]</span>
<span class="sd">        where a and b refer to different points in space and the indices</span>
<span class="sd">        are for the different fields, which are given when the function is</span>
<span class="sd">        added. The results need to be a list or array even if it&#39;s only one</span>
<span class="sd">        item.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_bin_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add hits to the bins corresponding to these results. length_hit_bins</span>
<span class="sd">        is flattened, so we need to figure out the offset for this hit by</span>
<span class="sd">        factoring the sizes of the other dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hit_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int64&#39;</span><span class="p">)</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;bool&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_labels</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">d1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">multi</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">d1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_labels</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">digi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c"># The user probably did something like </span>
                    <span class="c"># return a * b rather than</span>
                    <span class="c"># return a[0] * b[0], which will only happen</span>
                    <span class="c"># for single field functions.</span>
                    <span class="n">digi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">digi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">results</span><span class="p">[:,</span><span class="n">dim</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
            <span class="n">too_low</span> <span class="o">=</span> <span class="p">(</span><span class="n">digi</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">too_high</span> <span class="o">=</span> <span class="p">(</span><span class="n">digi</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">too_low</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">too_low</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">too_high</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">too_high</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">newgood</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">too_low</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">too_high</span><span class="p">))</span>
            <span class="n">good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">good</span><span class="p">,</span> <span class="n">newgood</span><span class="p">)</span>
            <span class="n">hit_bin</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">((</span><span class="n">digi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">multi</span><span class="p">)</span>
        <span class="n">digi_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length_bin_hits</span><span class="p">[</span><span class="n">length</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">hist</span><span class="p">,</span> <span class="n">digi_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">hit_bin</span><span class="p">[</span><span class="n">good</span><span class="p">],</span> <span class="n">digi_bins</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length_bin_hits</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hist</span>

    <span class="k">def</span> <span class="nf">_dim_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a multidimensional array a, this finds the sum over all the</span>
<span class="sd">        elements leaving the dimension dim untouched.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">gt_dims</span> <span class="o">=</span> <span class="n">dims</span><span class="p">[</span><span class="n">dims</span> <span class="o">&gt;</span> <span class="n">dim</span><span class="p">]</span>
        <span class="n">lt_dims</span> <span class="o">=</span> <span class="n">dims</span><span class="p">[</span><span class="n">dims</span> <span class="o">&lt;</span> <span class="n">dim</span><span class="p">]</span>
        <span class="n">iter_dims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">gt_dims</span><span class="p">,</span> <span class="n">lt_dims</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">this_dim</span> <span class="ow">in</span> <span class="n">iter_dims</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">this_dim</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">def</span> <span class="nf">_avg_bin_hits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each dimension and length of bin_hits return the weighted average.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length_avgs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpf</span><span class="o">.</span><span class="n">lengths</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">length_avgs</span><span class="p">[</span><span class="n">length</span><span class="p">][</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length_bin_hits</span><span class="p">[</span><span class="n">length</span><span class="p">],</span> <span class="n">dim</span><span class="p">)</span> <span class="o">*</span> \
                    <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">dim</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_corr_sum_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the correlations xi for this function. We are tacitly assuming</span>
<span class="sd">        that all correlation functions are one dimensional.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpf</span><span class="o">.</span><span class="n">lengths</span><span class="p">:</span>
            <span class="n">xi</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length_bin_hits</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">*</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_norm</span>
        <span class="k">return</span> <span class="n">xi</span></div>
</pre></div>

    </div>
      
  </div>
</div>
    <div class="footer">
      &copy; Copyright 2013, the yt Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>