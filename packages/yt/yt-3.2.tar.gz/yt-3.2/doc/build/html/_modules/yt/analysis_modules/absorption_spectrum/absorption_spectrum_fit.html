<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>yt.analysis_modules.absorption_spectrum.absorption_spectrum_fit &mdash; The yt Project 3.2-dev documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/bootswatch-3.3.4/readable/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '3.2-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../../../_static/bootstrap-3.3.4/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="The yt Project 3.2-dev documentation" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" />
    
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-391373-2']);
      _gaq.push(['_setDomainName', 'yt-project.org']);
      _gaq.push(['_setAllowHash', false]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../../index.html"><img src="../../../../_static/yt_icon.png">
          The yt Project</a>
        <span class="navbar-text navbar-version pull-left"><b>3.2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../../help/index.html">How to get help</a></li>
                <li><a href="../../../../quickstart/index.html">Quickstart notebooks</a></li>
                <li><a href="../../../../cookbook/index.html">Cookbook</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installing.html">Getting and Installing yt</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../installing.html#getting-yt">Getting yt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../installing.html#testing-your-installation">Testing Your Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../installing.html#switching-between-yt-2-x-and-yt-3-x">Switching between yt-2.x and yt-3.x</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../quickstart/index.html">yt Quickstart</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../quickstart/introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../quickstart/data_inspection.html">Data Inspection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../quickstart/simple_visualization.html">Simple Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../quickstart/data_objects_and_time_series.html">Data Objects and Time Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../quickstart/derived_fields_and_profiles.html">Derived Fields and Profiles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../quickstart/volume_rendering.html">Volume Rendering</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../yt3differences.html">What&#8217;s New and Different in yt 3.0?</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../yt3differences.html#updating-to-yt-3-0-from-old-versions-and-going-back">Updating to yt 3.0 from Old Versions (and going back)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../yt3differences.html#converting-old-scripts-to-work-with-yt-3-0">Converting Old Scripts to Work with yt 3.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../yt3differences.html#cool-new-things">Cool New Things</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../yt3differences.html#api-changes">API Changes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cookbook/index.html">The Cookbook</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../cookbook/index.html#getting-the-sample-data">Getting the Sample Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../cookbook/index.html#example-scripts">Example Scripts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../cookbook/index.html#example-notebooks">Example Notebooks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../visualizing/index.html">Visualizing Data</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/plots.html">How to Make Plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/callbacks.html">Plot Modifications: Overplotting Contours, Velocities, Particles, and More</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/manual_plotting.html">Using the Manual Plotting Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/volume_rendering.html">Volume Rendering: Making 3D Photorealistic Isocontoured Images</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/hardware_volume_rendering.html">Hardware Volume Rendering on NVidia Graphics cards</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/sketchfab.html">3D Surfaces and Sketchfab</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/mapserver.html">Mapserver - A Google-Maps-like Interface to your Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/streamlines.html">Streamlines: Tracking the Trajectories of Tracers in your Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/colormaps/index.html">Colormaps</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../visualizing/writing_fits_images.html">Writing FITS Images</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../analyzing/index.html">General Data Analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/fields.html">Fields in yt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/creating_derived_fields.html">Creating Derived Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/objects.html">Data Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/units/index.html">Symbolic Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/filtering.html">Filtering your Dataset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/generating_processed_data.html">Generating Processed Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/time_series_analysis.html">Time Series Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/parallel_computation.html">Parallel Computation With yt</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../analyzing/analysis_modules/index.html">Topic-Specific Analysis Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/analysis_modules/halo_analysis.html">Halo Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/analysis_modules/synthetic_observation.html">Synthetic Observation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/analysis_modules/exporting.html">Exporting to External Radiation Transport Codes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/analysis_modules/two_point_functions.html">Two Point Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/analysis_modules/clump_finding.html">Clump Finding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/analysis_modules/particle_trajectories.html">Particle Trajectories</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../analyzing/analysis_modules/ellipsoid_analysis.html">Halo Ellipsoid Analysis</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examining/index.html">Loading and Examining Data</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../examining/loading_data.html">Loading Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../examining/generic_array_data.html">Loading Generic Array Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../examining/generic_particle_data.html">Loading Generic Particle Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../examining/spherical_data.html">Loading Spherical Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../examining/low_level_inspection.html">Low-Level Data Inspection: Accessing Raw Data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../developing/index.html">Developing in yt</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/intro.html">Getting Involved</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/developing.html">How to Develop yt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/building_the_docs.html">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/testing.html">Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/debugdrive.html">Debugging yt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/creating_datatypes.html">Creating Data Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/creating_derived_fields.html">Creating Derived Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/creating_derived_quantities.html">Creating Derived Quantities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/creating_frontend.html">Creating A New Code Frontend</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../developing/external_analysis.html">Using yt with External Analysis Tools</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/index.html">Reference Materials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../reference/code_support.html">Code Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../reference/command-line.html">Command-Line Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../reference/api/api.html">API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../reference/configuration.html">Customizing yt: The Configuration and Plugin Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../reference/field_list.html">Field List</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../reference/changelog.html">ChangeLog</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq/index.html">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../faq/index.html#version-installation">Version &amp; Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../faq/index.html#code-errors-and-failures">Code Errors and Failures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../faq/index.html#units">Units</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../faq/index.html#fields">Fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../faq/index.html#data-objects">Data Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../faq/index.html#developing">Developing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../faq/index.html#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../help/index.html">Getting Help</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#don-t-panic-and-don-t-give-up">Don&#8217;t panic and don&#8217;t give up</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#update-to-the-latest-version">Update to the latest version</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#search-the-documentation-faq-and-mailing-lists">Search the documentation, FAQ, and mailing lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#look-at-the-source-code">Look at the source code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#isolate-and-document-your-problem">Isolate and document your problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#go-on-irc-to-ask-a-question">Go on IRC to ask a question</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#ask-the-mailing-list">Ask the mailing list</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#submit-a-bug-report">Submit a bug report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../help/index.html#special-issues">Special Issues</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../../about/index.html">About yt</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../../about/index.html#what-is-yt">What is yt?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../about/index.html#who-is-yt">Who is yt?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../about/index.html#history-of-yt">History of yt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../about/index.html#how-do-i-contact-yt">How do I contact yt?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../../about/index.html#how-do-i-cite-yt">How do I cite yt?</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <h1>Source code for yt.analysis_modules.absorption_spectrum.absorption_spectrum_fit</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">yt.analysis_modules.absorption_spectrum.absorption_line</span> <span class="kn">import</span> \
    <span class="n">voigt</span>
<span class="kn">from</span> <span class="nn">yt.funcs</span> <span class="kn">import</span> \
    <span class="n">mylog</span>
<span class="kn">from</span> <span class="nn">yt.units.yt_array</span> <span class="kn">import</span> \
    <span class="n">YTArray</span>
<span class="kn">from</span> <span class="nn">yt.utilities.on_demand_imports</span> <span class="kn">import</span> \
    <span class="n">_scipy</span>

<span class="n">optimize</span> <span class="o">=</span> <span class="n">_scipy</span><span class="o">.</span><span class="n">optimize</span>

<div class="viewcode-block" id="generate_total_fit"><a class="viewcode-back" href="../../../../reference/api/generated/yt.analysis_modules.absorption_spectrum.absorption_spectrum_fit.generate_total_fit.html#yt.analysis_modules.absorption_spectrum.absorption_spectrum_fit.generate_total_fit">[docs]</a><span class="k">def</span> <span class="nf">generate_total_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fluxData</span><span class="p">,</span> <span class="n">orderFits</span><span class="p">,</span> <span class="n">speciesDicts</span><span class="p">,</span> 
        <span class="n">minError</span><span class="o">=</span><span class="mf">1E-4</span><span class="p">,</span> <span class="n">complexLim</span><span class="o">=.</span><span class="mi">995</span><span class="p">,</span>
        <span class="n">fitLim</span><span class="o">=.</span><span class="mi">97</span><span class="p">,</span> <span class="n">minLength</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> 
        <span class="n">maxLength</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">splitLim</span><span class="o">=.</span><span class="mi">99</span><span class="p">,</span>
        <span class="n">output_file</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is designed to fit an absorption spectrum by breaking </span>
<span class="sd">    the spectrum up into absorption complexes, and iteratively adding</span>
<span class="sd">    and optimizing voigt profiles to each complex.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (N) ndarray</span>
<span class="sd">        1d array of wavelengths</span>
<span class="sd">    fluxData : (N) ndarray</span>
<span class="sd">        array of flux corresponding to the wavelengths given</span>
<span class="sd">        in x. (needs to be the same size as x)</span>
<span class="sd">    orderFits : list</span>
<span class="sd">        list of the names of the species in the order that they </span>
<span class="sd">        should be fit. Names should correspond to the names of the species</span>
<span class="sd">        given in speciesDicts. (ex: [&#39;lya&#39;,&#39;OVI&#39;])</span>
<span class="sd">    speciesDicts : dictionary</span>
<span class="sd">        Dictionary of dictionaries (I&#39;m addicted to dictionaries, I</span>
<span class="sd">        confess). Top level keys should be the names of all the species given</span>
<span class="sd">        in orderFits. The entries should be dictionaries containing all </span>
<span class="sd">        relevant parameters needed to create an absorption line of a given </span>
<span class="sd">        species (f,Gamma,lambda0) as well as max and min values for parameters</span>
<span class="sd">        to be fit</span>
<span class="sd">    complexLim : float, optional</span>
<span class="sd">        Maximum flux to start the edge of an absorption complex. Different </span>
<span class="sd">        from fitLim because it decides extent of a complex rather than </span>
<span class="sd">        whether or not a complex is accepted. </span>
<span class="sd">    fitLim : float,optional</span>
<span class="sd">        Maximum flux where the level of absorption will trigger </span>
<span class="sd">        identification of the region as an absorption complex. Default = .98.</span>
<span class="sd">        (ex: for a minSize=.98, a region where all the flux is between 1.0 and</span>
<span class="sd">        .99 will not be separated out to be fit as an absorbing complex, but</span>
<span class="sd">        a region that contains a point where the flux is .97 will be fit</span>
<span class="sd">        as an absorbing complex.)</span>
<span class="sd">    minLength : int, optional</span>
<span class="sd">        number of cells required for a complex to be included. </span>
<span class="sd">        default is 3 cells.</span>
<span class="sd">    maxLength : int, optional</span>
<span class="sd">        number of cells required for a complex to be split up. Default</span>
<span class="sd">        is 1000 cells.</span>
<span class="sd">    splitLim : float, optional</span>
<span class="sd">        if attempting to split a region for being larger than maxlength</span>
<span class="sd">        the point of the split must have a flux greater than splitLim </span>
<span class="sd">        (ie: absorption greater than splitLim). Default= .99.</span>
<span class="sd">    output_file : string, optional</span>
<span class="sd">        location to save the results of the fit. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    allSpeciesLines : dictionary</span>
<span class="sd">        Dictionary of dictionaries representing the fit lines. </span>
<span class="sd">        Top level keys are the species given in orderFits and the corresponding</span>
<span class="sd">        entries are dictionaries with the keys &#39;N&#39;,&#39;b&#39;,&#39;z&#39;, and &#39;group#&#39;. </span>
<span class="sd">        Each of these corresponds to a list of the parameters for every</span>
<span class="sd">        accepted fitted line. (ie: N[0],b[0],z[0] will create a line that</span>
<span class="sd">        fits some part of the absorption spectrum). &#39;group#&#39; is a similar list</span>
<span class="sd">        but identifies which absorbing complex each line belongs to. Lines</span>
<span class="sd">        with the same group# were fit at the same time. group#&#39;s do not</span>
<span class="sd">        correlate between species (ie: an lya line with group number 1 and</span>
<span class="sd">        an OVI line with group number 1 were not fit together and do</span>
<span class="sd">        not necessarily correspond to the same region)</span>
<span class="sd">    yFit : (N) ndarray</span>
<span class="sd">        array of flux corresponding to the combination of all fitted</span>
<span class="sd">        absorption profiles. Same size as x.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># convert to NumPy array if we have a YTArray</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">YTArray</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">d</span>
    
    <span class="c">#Empty dictionary for fitted lines</span>
    <span class="n">allSpeciesLines</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c">#Wavelength of beginning of array, wavelength resolution</span>
    <span class="n">x0</span><span class="p">,</span><span class="n">xRes</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c">#Empty fit without any lines</span>
    <span class="n">yFit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fluxData</span><span class="p">))</span>

    <span class="c">#Force the first and last flux pixel to be 1 to prevent OOB</span>
    <span class="n">fluxData</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">fluxData</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>


    <span class="c">#Find all regions where lines/groups of lines are present</span>
    <span class="n">cBounds</span> <span class="o">=</span> <span class="n">_find_complexes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fluxData</span><span class="p">,</span> <span class="n">fitLim</span><span class="o">=</span><span class="n">fitLim</span><span class="p">,</span>
            <span class="n">complexLim</span><span class="o">=</span><span class="n">complexLim</span><span class="p">,</span> <span class="n">minLength</span><span class="o">=</span><span class="n">minLength</span><span class="p">,</span>
            <span class="n">maxLength</span><span class="o">=</span><span class="n">maxLength</span><span class="p">,</span> <span class="n">splitLim</span><span class="o">=</span><span class="n">splitLim</span><span class="p">)</span>

    <span class="c">#Fit all species one at a time in given order from low to high wavelength</span>
    <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">orderFits</span><span class="p">:</span>
        <span class="n">speciesDict</span> <span class="o">=</span> <span class="n">speciesDicts</span><span class="p">[</span><span class="n">species</span><span class="p">]</span>
        <span class="n">speciesLines</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;N&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
                        <span class="s">&#39;b&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
                        <span class="s">&#39;z&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span>
                        <span class="s">&#39;group#&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])}</span>

        <span class="c">#Set up wavelengths for species</span>
        <span class="n">initWl</span> <span class="o">=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;wavelength&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">b_i</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cBounds</span><span class="p">):</span>
            <span class="n">xBounded</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">yDatBounded</span><span class="o">=</span><span class="n">fluxData</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="n">yFitBounded</span><span class="o">=</span><span class="n">yFit</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>


            <span class="c">#Find init redshift</span>
            <span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="n">xBounded</span><span class="p">[</span><span class="n">yDatBounded</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span><span class="o">-</span><span class="n">initWl</span><span class="p">)</span><span class="o">/</span><span class="n">initWl</span>

            <span class="c">#Check if any flux at partner sites</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_line_exists</span><span class="p">(</span><span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;wavelength&#39;</span><span class="p">],</span>
                    <span class="n">fluxData</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">x0</span><span class="p">,</span><span class="n">xRes</span><span class="p">,</span><span class="n">fitLim</span><span class="p">):</span> 
                <span class="k">continue</span> 

            <span class="c">#Fit Using complex tools</span>
            <span class="n">newLinesP</span><span class="p">,</span><span class="n">flag</span><span class="o">=</span><span class="n">_complex_fit</span><span class="p">(</span><span class="n">xBounded</span><span class="p">,</span><span class="n">yDatBounded</span><span class="p">,</span><span class="n">yFitBounded</span><span class="p">,</span>
                    <span class="n">z</span><span class="p">,</span><span class="n">fitLim</span><span class="p">,</span><span class="n">minError</span><span class="p">,</span><span class="n">speciesDict</span><span class="p">)</span>

            <span class="c">#If flagged as a bad fit, species is lyman alpha,</span>
            <span class="c">#   and it may be a saturated line, use special tools</span>
            <span class="k">if</span> <span class="n">flag</span> <span class="ow">and</span> <span class="n">species</span><span class="o">==</span><span class="s">&#39;lya&#39;</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="n">yDatBounded</span><span class="p">)</span><span class="o">&lt;.</span><span class="mi">1</span><span class="p">:</span>
               <span class="n">newLinesP</span><span class="o">=</span><span class="n">_large_flag_fit</span><span class="p">(</span><span class="n">xBounded</span><span class="p">,</span><span class="n">yDatBounded</span><span class="p">,</span>
                        <span class="n">yFitBounded</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">speciesDict</span><span class="p">,</span>
                        <span class="n">minSize</span><span class="p">,</span><span class="n">minError</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">newLinesP</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c">#Check for EXPLOOOOSIIONNNSSS</span>
                <span class="n">newLinesP</span> <span class="o">=</span> <span class="n">_check_numerical_instability</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">newLinesP</span><span class="p">,</span> <span class="n">speciesDict</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>


            <span class="c">#Check existence of partner lines if applicable</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;wavelength&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">newLinesP</span> <span class="o">=</span> <span class="n">_remove_unaccepted_partners</span><span class="p">(</span><span class="n">newLinesP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">fluxData</span><span class="p">,</span> 
                        <span class="n">b</span><span class="p">,</span> <span class="n">minError</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">xRes</span><span class="p">,</span> <span class="n">speciesDict</span><span class="p">)</span>




            <span class="c">#Adjust total current fit</span>
            <span class="n">yFit</span><span class="o">=</span><span class="n">yFit</span><span class="o">*</span><span class="n">_gen_flux_lines</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">newLinesP</span><span class="p">,</span><span class="n">speciesDict</span><span class="p">)</span>


            <span class="c">#Add new group to all fitted lines</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">newLinesP</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">speciesLines</span><span class="p">[</span><span class="s">&#39;N&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">speciesLines</span><span class="p">[</span><span class="s">&#39;N&#39;</span><span class="p">],</span><span class="n">newLinesP</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">speciesLines</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">speciesLines</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">],</span><span class="n">newLinesP</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">speciesLines</span><span class="p">[</span><span class="s">&#39;z&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">speciesLines</span><span class="p">[</span><span class="s">&#39;z&#39;</span><span class="p">],</span><span class="n">newLinesP</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">groupNums</span> <span class="o">=</span> <span class="n">b_i</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">newLinesP</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">speciesLines</span><span class="p">[</span><span class="s">&#39;group#&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">speciesLines</span><span class="p">[</span><span class="s">&#39;group#&#39;</span><span class="p">],</span><span class="n">groupNums</span><span class="p">)</span>

        <span class="n">allSpeciesLines</span><span class="p">[</span><span class="n">species</span><span class="p">]</span><span class="o">=</span><span class="n">speciesLines</span>


    <span class="k">if</span> <span class="n">output_file</span><span class="p">:</span>
        <span class="n">_output_fit</span><span class="p">(</span><span class="n">allSpeciesLines</span><span class="p">,</span> <span class="n">output_file</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">allSpeciesLines</span><span class="p">,</span><span class="n">yFit</span><span class="p">)</span>
</div>
<span class="k">def</span> <span class="nf">_complex_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yDat</span><span class="p">,</span> <span class="n">yFit</span><span class="p">,</span> <span class="n">initz</span><span class="p">,</span> <span class="n">minSize</span><span class="p">,</span> <span class="n">errBound</span><span class="p">,</span> <span class="n">speciesDict</span><span class="p">,</span> 
        <span class="n">initP</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Fit an absorption complex by iteratively adding and optimizing</span>
<span class="sd">    voigt profiles.</span>
<span class="sd">    </span>
<span class="sd">    A complex is defined as a region where some number of lines may be present,</span>
<span class="sd">    or a region of non zero of absorption. Lines are iteratively added</span>
<span class="sd">    and optimized until the difference between the flux generated using</span>
<span class="sd">    the optimized parameters has a least squares difference between the </span>
<span class="sd">    desired flux profile less than the error bound.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (N) ndarray</span>
<span class="sd">        array of wavelength</span>
<span class="sd">    ydat : (N) ndarray</span>
<span class="sd">        array of desired flux profile to be fitted for the wavelength</span>
<span class="sd">        space given by x. Same size as x.</span>
<span class="sd">    yFit : (N) ndarray</span>
<span class="sd">        array of flux profile fitted for the wavelength</span>
<span class="sd">        space given by x already. Same size as x.</span>
<span class="sd">    initz : float</span>
<span class="sd">        redshift to try putting first line at </span>
<span class="sd">        (maximum absorption for region)</span>
<span class="sd">    minsize : float</span>
<span class="sd">        minimum absorption allowed for a line to still count as a line</span>
<span class="sd">        given in normalized flux (ie: for minSize=.9, only lines with minimum</span>
<span class="sd">        flux less than .9 will be fitted)</span>
<span class="sd">    errbound : float</span>
<span class="sd">        maximum total error allowed for an acceptable fit</span>
<span class="sd">    speciesDict : dictionary</span>
<span class="sd">        dictionary containing all relevant parameters needed</span>
<span class="sd">        to create an absorption line of a given species (f,Gamma,lambda0)</span>
<span class="sd">        as well as max and min values for parameters to be fit</span>
<span class="sd">    initP : (,3,) ndarray</span>
<span class="sd">        initial guess to try for line parameters to fit the region. Used</span>
<span class="sd">        by large_flag_fit. Default = None, and initial guess generated</span>
<span class="sd">        automatically.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    linesP : (3,) ndarray</span>
<span class="sd">        Array of best parameters if a good enough fit is found in </span>
<span class="sd">        the form [[N1,b1,z1], [N2,b2,z2],...]</span>
<span class="sd">    flag : bool</span>
<span class="sd">        boolean value indicating the success of the fit (True if unsuccessful)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c">#Setup initial line guesses</span>
    <span class="k">if</span> <span class="n">initP</span><span class="o">==</span><span class="bp">None</span><span class="p">:</span> <span class="c">#Regular fit</span>
        <span class="n">initP</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> 
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">yDat</span><span class="p">)</span><span class="o">&lt;.</span><span class="mo">01</span><span class="p">:</span> <span class="c">#Large lines get larger initial guess </span>
            <span class="n">initP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_N&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">yDat</span><span class="p">)</span><span class="o">&lt;.</span><span class="mi">5</span><span class="p">:</span>
            <span class="n">initP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_N&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">yDat</span><span class="p">)</span><span class="o">&gt;.</span><span class="mi">9</span><span class="p">:</span> <span class="c">#Small lines get smaller initial guess</span>
            <span class="n">initP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_N&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="o">**-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">initP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_N&#39;</span><span class="p">]</span>
        <span class="n">initP</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_b&#39;</span><span class="p">]</span>
        <span class="n">initP</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">initz</span>
        <span class="n">initP</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">initP</span><span class="p">])</span>

    <span class="n">linesP</span> <span class="o">=</span> <span class="n">initP</span>

    <span class="c">#For generating new z guesses</span>
    <span class="n">wl0</span> <span class="o">=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;wavelength&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="c">#Check if first line exists still</span>
    <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">yDat</span><span class="o">-</span><span class="n">yFit</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="n">minSize</span><span class="p">:</span> 
        <span class="k">return</span> <span class="p">[],</span><span class="bp">False</span>
    
    <span class="c">#Values to proceed through first run</span>
    <span class="n">errSq</span><span class="p">,</span><span class="n">prevErrSq</span><span class="p">,</span><span class="n">prevLinesP</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),[]</span>

    <span class="k">if</span> <span class="n">errBound</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">errBound</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">yDat</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">yDat</span><span class="p">)</span><span class="o">*</span><span class="mf">1E-2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">errBound</span> <span class="o">=</span> <span class="n">errBound</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">yDat</span><span class="p">)</span>

    <span class="n">flag</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>

        <span class="c">#Initial parameter guess from joining parameters from all lines</span>
        <span class="c">#   in lines into a single array</span>
        <span class="n">initP</span> <span class="o">=</span> <span class="n">linesP</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c">#Optimize line</span>
        <span class="n">fitP</span><span class="p">,</span><span class="n">success</span><span class="o">=</span><span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span><span class="n">_voigt_error</span><span class="p">,</span><span class="n">initP</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">yDat</span><span class="p">,</span><span class="n">yFit</span><span class="p">,</span><span class="n">speciesDict</span><span class="p">),</span>
                <span class="n">epsfcn</span><span class="o">=</span><span class="mf">1E-10</span><span class="p">,</span><span class="n">maxfev</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>


        <span class="c">#Set results of optimization</span>
        <span class="n">linesP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fitP</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

        <span class="c">#Generate difference between current best fit and data</span>
        <span class="n">yNewFit</span><span class="o">=</span><span class="n">_gen_flux_lines</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">linesP</span><span class="p">,</span><span class="n">speciesDict</span><span class="p">)</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="n">yFit</span><span class="o">*</span><span class="n">yNewFit</span><span class="o">-</span><span class="n">yDat</span>

        <span class="c">#Sum to get idea of goodness of fit</span>
        <span class="n">errSq</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">dif</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">linesP</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_b&#39;</span><span class="p">]):</span>
         <span class="c">#   linesP = prevLinesP</span>

            <span class="n">flag</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">break</span>
            
        <span class="c">#If good enough, break</span>
        <span class="k">if</span> <span class="n">errSq</span> <span class="o">&lt;</span> <span class="n">errBound</span><span class="p">:</span>        
            <span class="k">break</span>

        <span class="c">#If last fit was worse, reject the last line and revert to last fit</span>
        <span class="k">if</span> <span class="n">errSq</span> <span class="o">&gt;</span> <span class="n">prevErrSq</span><span class="o">*</span><span class="mi">10</span> <span class="p">:</span>
            <span class="c">#If its still pretty damn bad, cut losses and try flag fit tools</span>
            <span class="k">if</span> <span class="n">prevErrSq</span> <span class="o">&gt;</span><span class="mf">1E2</span><span class="o">*</span><span class="n">errBound</span> <span class="ow">and</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span><span class="o">==</span><span class="s">&#39;HI lya&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[],</span><span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">linesP</span> <span class="o">=</span> <span class="n">prevLinesP</span>
                <span class="k">break</span>

        <span class="c">#If too many lines </span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">linesP</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">8</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">linesP</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="o">&gt;=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c">#If its fitable by flag tools and still bad, use flag tools</span>
            <span class="k">if</span> <span class="n">errSq</span> <span class="o">&gt;</span><span class="mf">1E2</span><span class="o">*</span><span class="n">errBound</span> <span class="ow">and</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span><span class="o">==</span><span class="s">&#39;HI lya&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[],</span><span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>

        <span class="c">#Store previous data in case reject next fit</span>
        <span class="n">prevErrSq</span> <span class="o">=</span> <span class="n">errSq</span>
        <span class="n">prevLinesP</span> <span class="o">=</span> <span class="n">linesP</span>

        <span class="c">#Set up initial condition for new line</span>
        <span class="n">newP</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> 

        <span class="n">yAdjusted</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">yFit</span><span class="o">*</span><span class="n">yNewFit</span><span class="o">-</span><span class="n">yDat</span>
 
        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">yAdjusted</span><span class="p">)</span><span class="o">&lt;.</span><span class="mo">01</span><span class="p">:</span> <span class="c">#Large lines get larger initial guess </span>
            <span class="n">newP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_N&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">yAdjusted</span><span class="p">)</span><span class="o">&lt;.</span><span class="mi">5</span><span class="p">:</span>
            <span class="n">newP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_N&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">yAdjusted</span><span class="p">)</span><span class="o">&gt;.</span><span class="mi">9</span><span class="p">:</span> <span class="c">#Small lines get smaller initial guess</span>
            <span class="n">newP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_N&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="o">**-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newP</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_N&#39;</span><span class="p">]</span>
        <span class="n">newP</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_b&#39;</span><span class="p">]</span>
        <span class="n">newP</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">dif</span><span class="o">.</span><span class="n">argmax</span><span class="p">()]</span><span class="o">-</span><span class="n">wl0</span><span class="p">)</span><span class="o">/</span><span class="n">wl0</span>
        <span class="n">linesP</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linesP</span><span class="p">,[</span><span class="n">newP</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


    <span class="c">#Check the parameters of all lines to see if they fall in an</span>
    <span class="c">#   acceptable range, as given in dict ref</span>
    <span class="n">remove</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">linesP</span><span class="p">):</span>
        <span class="n">check</span><span class="o">=</span><span class="n">_check_params</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="p">]),</span><span class="n">speciesDict</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check</span><span class="p">:</span> 
            <span class="n">remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">linesP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">linesP</span><span class="p">,</span><span class="n">remove</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">linesP</span><span class="p">,</span><span class="n">flag</span>

<span class="k">def</span> <span class="nf">_large_flag_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yDat</span><span class="p">,</span> <span class="n">yFit</span><span class="p">,</span> <span class="n">initz</span><span class="p">,</span> <span class="n">speciesDict</span><span class="p">,</span> <span class="n">minSize</span><span class="p">,</span> <span class="n">errBound</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attempts to more robustly fit saturated lyman alpha regions that have</span>
<span class="sd">    not converged to satisfactory fits using the standard tools.</span>

<span class="sd">    Uses a preselected sample of a wide range of initial parameter guesses</span>
<span class="sd">    designed to fit saturated lines (see get_test_lines).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (N) ndarray</span>
<span class="sd">        array of wavelength</span>
<span class="sd">    ydat : (N) ndarray</span>
<span class="sd">        array of desired flux profile to be fitted for the wavelength</span>
<span class="sd">        space given by x. Same size as x.</span>
<span class="sd">    yFit : (N) ndarray</span>
<span class="sd">        array of flux profile fitted for the wavelength</span>
<span class="sd">        space given by x already. Same size as x.</span>
<span class="sd">    initz : float</span>
<span class="sd">        redshift to try putting first line at </span>
<span class="sd">        (maximum absorption for region)</span>
<span class="sd">    speciesDict : dictionary</span>
<span class="sd">        dictionary containing all relevant parameters needed</span>
<span class="sd">        to create an absorption line of a given species (f,Gamma,lambda0)</span>
<span class="sd">        as well as max and min values for parameters to be fit</span>
<span class="sd">    minsize : float</span>
<span class="sd">        minimum absorption allowed for a line to still count as a line</span>
<span class="sd">        given in normalized flux (ie: for minSize=.9, only lines with minimum</span>
<span class="sd">        flux less than .9 will be fitted)</span>
<span class="sd">    errbound : float</span>
<span class="sd">        maximum total error allowed for an acceptable fit</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bestP : (3,) ndarray</span>
<span class="sd">        array of best parameters if a good enough fit is found in </span>
<span class="sd">        the form [[N1,b1,z1], [N2,b2,z2],...]  </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c">#Set up some initial line guesses</span>
    <span class="n">lineTests</span> <span class="o">=</span> <span class="n">_get_test_lines</span><span class="p">(</span><span class="n">initz</span><span class="p">)</span>

    <span class="c">#Keep track of the lowest achieved error</span>
    <span class="n">bestError</span> <span class="o">=</span> <span class="mi">1000</span> 

    <span class="c">#Iterate through test line guesses</span>
    <span class="k">for</span> <span class="n">initLines</span> <span class="ow">in</span> <span class="n">lineTests</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">initLines</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">initLines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">initLines</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c">#Do fitting with initLines as first guess</span>
        <span class="n">linesP</span><span class="p">,</span><span class="n">flag</span><span class="o">=</span><span class="n">_complex_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">yDat</span><span class="p">,</span><span class="n">yFit</span><span class="p">,</span><span class="n">initz</span><span class="p">,</span>
                <span class="n">minSize</span><span class="p">,</span><span class="n">errBound</span><span class="p">,</span><span class="n">speciesDict</span><span class="p">,</span><span class="n">initP</span><span class="o">=</span><span class="n">initLines</span><span class="p">)</span>

        <span class="c">#Find error of last fit</span>
        <span class="n">yNewFit</span><span class="o">=</span><span class="n">_gen_flux_lines</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">linesP</span><span class="p">,</span><span class="n">speciesDict</span><span class="p">)</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="n">yFit</span><span class="o">*</span><span class="n">yNewFit</span><span class="o">-</span><span class="n">yDat</span>
        <span class="n">errSq</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">dif</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c">#If error lower, keep track of the lines used to make that fit</span>
        <span class="k">if</span> <span class="n">errSq</span> <span class="o">&lt;</span> <span class="n">bestError</span><span class="p">:</span>
            <span class="n">bestError</span> <span class="o">=</span> <span class="n">errSq</span>
            <span class="n">bestP</span> <span class="o">=</span> <span class="n">linesP</span>

    <span class="k">if</span> <span class="n">bestError</span><span class="o">&gt;</span><span class="mi">10</span><span class="o">*</span><span class="n">errBound</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> 
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bestP</span>

<span class="k">def</span> <span class="nf">_get_test_lines</span><span class="p">(</span><span class="n">initz</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a 3d numpy array of lines to test as initial guesses for difficult</span>
<span class="sd">    to fit lyman alpha absorbers that are saturated. </span>
<span class="sd">    </span>
<span class="sd">    The array is 3d because</span>
<span class="sd">    the first dimension gives separate initial guesses, the second dimension</span>
<span class="sd">    has multiple lines for the same guess (trying a broad line plus a </span>
<span class="sd">    saturated line) and the 3d dimension contains the 3 fit parameters (N,b,z)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    initz : float</span>
<span class="sd">        redshift to give all the test lines</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    testP : (,3,) ndarray</span>
<span class="sd">        numpy array of the form </span>
<span class="sd">        [[[N1a,b1a,z1a], [N1b,b1b,z1b]], [[N2a,b2,z2a],...] ...]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c">#Set up a bunch of empty lines</span>
    <span class="n">testP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

    <span class="n">testP</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">=</span><span class="p">[</span><span class="mf">1E18</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="n">initz</span><span class="p">]</span>
    <span class="n">testP</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">=</span><span class="p">[</span><span class="mf">1E18</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="n">initz</span><span class="p">]</span>
    <span class="n">testP</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">=</span><span class="p">[</span><span class="mf">1E16</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="n">initz</span><span class="p">]</span>
    <span class="n">testP</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">=</span><span class="p">[</span><span class="mf">1E16</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="n">initz</span><span class="p">]</span>
    <span class="n">testP</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">=</span><span class="p">[</span><span class="mf">1E16</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="n">initz</span><span class="p">]</span>

    <span class="n">testP</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">=</span><span class="p">[</span><span class="mf">1E18</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="n">initz</span><span class="p">]</span>
    <span class="n">testP</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">=</span><span class="p">[</span><span class="mf">1E18</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="n">initz</span><span class="p">]</span>
    <span class="n">testP</span><span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">=</span><span class="p">[</span><span class="mf">1E16</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="n">initz</span><span class="p">]</span>
    <span class="n">testP</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">=</span><span class="p">[</span><span class="mf">1E16</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="n">initz</span><span class="p">]</span>
    <span class="n">testP</span><span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">=</span><span class="p">[</span><span class="mf">1E16</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="n">initz</span><span class="p">]</span>

    <span class="n">testP</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span><span class="o">=</span><span class="p">[</span><span class="mf">1E13</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="n">initz</span><span class="p">]</span>
    <span class="n">testP</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span><span class="o">=</span><span class="p">[</span><span class="mf">1E13</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="n">initz</span><span class="p">]</span>
    <span class="n">testP</span><span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span><span class="o">=</span><span class="p">[</span><span class="mf">1E13</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="n">initz</span><span class="p">]</span>
    <span class="n">testP</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span><span class="o">=</span><span class="p">[</span><span class="mf">1E13</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="n">initz</span><span class="p">]</span>
    <span class="n">testP</span><span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span><span class="o">=</span><span class="p">[</span><span class="mf">1E13</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="n">initz</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">testP</span>

<span class="k">def</span> <span class="nf">_get_bounds</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">wl</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">xRes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Gets the indices of range of wavelength that the wavelength wl is in </span>
<span class="sd">    with the size of some initial wavelength range.</span>

<span class="sd">    Used for checking if species with multiple lines (as in the OVI doublet)</span>
<span class="sd">    fit all lines appropriately.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : float</span>
<span class="sd">        redshift</span>
<span class="sd">    b : (3) ndarray/list</span>
<span class="sd">        initial bounds in form [i0,i1,i2] where i0 is the index of the </span>
<span class="sd">        minimum flux for the complex, i1 is index of the lower wavelength </span>
<span class="sd">        edge of the complex, and i2 is the index of the higher wavelength</span>
<span class="sd">        edge of the complex.</span>
<span class="sd">    wl : float</span>
<span class="sd">        unredshifted wavelength of the peak of the new region </span>
<span class="sd">    x0 : float</span>
<span class="sd">        wavelength of the index 0</span>
<span class="sd">    xRes : float</span>
<span class="sd">        difference in wavelength for two consecutive indices</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    indices : (2) tuple</span>
<span class="sd">        Tuple (i1,i2) where i1 is the index of the lower wavelength bound of </span>
<span class="sd">        the new region and i2 is the index of the higher wavelength bound of</span>
<span class="sd">        the new region</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">r</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">100</span><span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">100</span><span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">redWl</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">wl</span>
    <span class="n">iRedWl</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="n">redWl</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">/</span><span class="n">xRes</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">iRedWl</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">iRedWl</span><span class="o">+</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">indices</span>

<span class="k">def</span> <span class="nf">_remove_unaccepted_partners</span><span class="p">(</span><span class="n">linesP</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">errBound</span><span class="p">,</span> 
        <span class="n">x0</span><span class="p">,</span> <span class="n">xRes</span><span class="p">,</span> <span class="n">speciesDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a set of parameters [N,b,z] that form multiple lines for a given</span>
<span class="sd">    species (as in the OVI doublet), remove any set of parameters where</span>
<span class="sd">    not all transition wavelengths have a line that matches the fit.</span>

<span class="sd">    (ex: if a fit is determined based on the first line of the OVI doublet,</span>
<span class="sd">    but the given parameters give a bad fit of the wavelength space of</span>
<span class="sd">    the second line then that set of parameters is removed from the array</span>
<span class="sd">    of line parameters.)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    linesP : (3,) ndarray</span>
<span class="sd">        array giving sets of line parameters in </span>
<span class="sd">        form [[N1, b1, z1], ...]</span>
<span class="sd">    x : (N) ndarray</span>
<span class="sd">        wavelength array [nm]</span>
<span class="sd">    y : (N) ndarray</span>
<span class="sd">        normalized flux array of original data</span>
<span class="sd">    b : (3) tuple/list/ndarray</span>
<span class="sd">        indices that give the bounds of the original region so that another </span>
<span class="sd">        region of similar size can be used to determine the goodness</span>
<span class="sd">        of fit of the other wavelengths</span>
<span class="sd">    errBound : float</span>
<span class="sd">        size of the error that is appropriate for a given region, </span>
<span class="sd">        adjusted to account for the size of the region.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    linesP : (3,) ndarray</span>
<span class="sd">        array similar to linesP that only contains lines with</span>
<span class="sd">        appropriate fits of all transition wavelengths.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c">#List of lines to remove</span>
    <span class="n">removeLines</span><span class="o">=</span><span class="p">[]</span>

    <span class="c">#Set error</span>


    <span class="c">#Iterate through all sets of line parameters</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">linesP</span><span class="p">):</span>

        <span class="c">#iterate over all transition wavelengths</span>
        <span class="k">for</span> <span class="n">wl</span> <span class="ow">in</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;wavelength&#39;</span><span class="p">]:</span>

            <span class="c">#Get the bounds of a similar sized region around the</span>
            <span class="c">#   appropriate wavelength, and then get the appropriate</span>
            <span class="c">#   region of wavelength and flux</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="n">_get_bounds</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">b</span><span class="p">,</span><span class="n">wl</span><span class="p">,</span><span class="n">x0</span><span class="p">,</span><span class="n">xRes</span><span class="p">)</span>
            <span class="n">xb</span><span class="p">,</span><span class="n">yb</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">lb</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">lb</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="n">y</span><span class="p">[</span><span class="n">lb</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">lb</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">errBound</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">errBound</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">yb</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">yb</span><span class="p">)</span><span class="o">*</span><span class="mf">1E-2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errBound</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">errBound</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">yb</span><span class="p">)</span>

            <span class="c">#Generate a fit and find the difference to data</span>
            <span class="n">yFitb</span><span class="o">=</span><span class="n">_gen_flux_lines</span><span class="p">(</span><span class="n">xb</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="p">]),</span><span class="n">speciesDict</span><span class="p">)</span>
            <span class="n">dif</span> <span class="o">=</span><span class="n">yb</span><span class="o">-</span><span class="n">yFitb</span>



            <span class="c">#Only counts as an error if line is too big ---------------&lt;</span>
            <span class="n">dif</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dif</span> <span class="k">if</span> <span class="n">k</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">err</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dif</span><span class="p">)</span>

            <span class="c">#If the fit is too bad then add the line to list of removed lines</span>
            <span class="k">if</span> <span class="n">err</span> <span class="o">&gt;</span> <span class="n">errBound</span><span class="p">:</span>
                <span class="n">removeLines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">break</span>

    <span class="c">#Remove all bad line fits</span>
    <span class="n">linesP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">linesP</span><span class="p">,</span><span class="n">removeLines</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">linesP</span> 



<span class="k">def</span> <span class="nf">_line_exists</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">xRes</span><span class="p">,</span><span class="n">fluxMin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;For a group of lines finds if the there is some change in flux greater</span>
<span class="sd">    than some minimum at the same redshift with different initial wavelengths</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wavelengths : (N) ndarray</span>
<span class="sd">        array of initial wavelengths to check</span>
<span class="sd">    y : (N) ndarray</span>
<span class="sd">        flux array to check</span>
<span class="sd">    x0 : float</span>
<span class="sd">        wavelength of the first value in y</span>
<span class="sd">    xRes : float</span>
<span class="sd">        difference in wavelength between consecutive cells in flux array</span>
<span class="sd">    fluxMin : float</span>
<span class="sd">        maximum flux to count as a line existing. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    flag : boolean </span>
<span class="sd">        value indicating whether all lines exist. True if all lines exist</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c">#Iterate through initial wavelengths</span>
    <span class="k">for</span> <span class="n">wl</span> <span class="ow">in</span> <span class="n">wavelengths</span><span class="p">:</span>
        <span class="c">#Redshifted wavelength</span>
        <span class="n">redWl</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">wl</span>

        <span class="c">#Index of the redshifted wavelength</span>
        <span class="n">indexRedWl</span> <span class="o">=</span> <span class="p">(</span><span class="n">redWl</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">/</span><span class="n">xRes</span>

        <span class="c">#Check to see if even in flux range</span>
        <span class="k">if</span> <span class="n">indexRedWl</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c">#Check if surpasses minimum absorption bound</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">indexRedWl</span><span class="p">)]</span><span class="o">&gt;</span><span class="n">fluxMin</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">_find_complexes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">yDat</span><span class="p">,</span> <span class="n">complexLim</span><span class="o">=.</span><span class="mi">999</span><span class="p">,</span> <span class="n">fitLim</span><span class="o">=.</span><span class="mi">99</span><span class="p">,</span>
        <span class="n">minLength</span> <span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">maxLength</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">splitLim</span><span class="o">=.</span><span class="mi">99</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Breaks up the wavelength space into groups</span>
<span class="sd">    where there is some absorption. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (N) ndarray</span>
<span class="sd">        array of wavelengths</span>
<span class="sd">    yDat : (N) ndarray</span>
<span class="sd">        array of flux corresponding to the wavelengths given</span>
<span class="sd">        in x. (needs to be the same size as x)</span>
<span class="sd">    complexLim : float, optional</span>
<span class="sd">        Maximum flux to start the edge of an absorption complex. Different </span>
<span class="sd">        from fitLim because it decides extent of a complex rather than </span>
<span class="sd">        whether or not a complex is accepted. </span>
<span class="sd">    fitLim : float,optional</span>
<span class="sd">        Maximum flux where the level of absorption will trigger </span>
<span class="sd">        identification of the region as an absorption complex. Default = .98.</span>
<span class="sd">        (ex: for a minSize=.98, a region where all the flux is between 1.0 and</span>
<span class="sd">        .99 will not be separated out to be fit as an absorbing complex, but</span>
<span class="sd">        a region that contains a point where the flux is .97 will be fit</span>
<span class="sd">        as an absorbing complex.)</span>
<span class="sd">    minLength : int, optional</span>
<span class="sd">        number of cells required for a complex to be included. </span>
<span class="sd">        default is 3 cells.</span>
<span class="sd">    maxLength : int, optional</span>
<span class="sd">        number of cells required for a complex to be split up. Default</span>
<span class="sd">        is 1000 cells.</span>
<span class="sd">    splitLim : float, optional</span>
<span class="sd">        if attempting to split a region for being larger than maxlength</span>
<span class="sd">        the point of the split must have a flux greater than splitLim </span>
<span class="sd">        (ie: absorption greater than splitLim). Default= .99.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cBounds : (3,) </span>
<span class="sd">        list of bounds in the form [[i0,i1,i2],...] where i0 is the </span>
<span class="sd">        index of the maximum flux for a complex, i1 is the index of the</span>
<span class="sd">        beginning of the complex, and i2 is the index of the end of the </span>
<span class="sd">        complex. Indexes refer to the indices of x and yDat.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c">#Initialize empty list of bounds</span>
    <span class="n">cBounds</span><span class="o">=</span><span class="p">[]</span>

    <span class="c">#Iterate through cells of flux</span>
    <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>

        <span class="c">#Start tracking at a region that surpasses flux of edge</span>
        <span class="k">if</span> <span class="n">yDat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">complexLim</span><span class="p">:</span>

            <span class="c">#Iterate through until reach next edge</span>
            <span class="n">j</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">while</span> <span class="n">yDat</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">complexLim</span><span class="p">:</span> <span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span>

            <span class="c">#Check if the complex is big enough</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span><span class="n">minLength</span><span class="p">:</span>

                <span class="c">#Check if there is enough absorption for the complex to</span>
                <span class="c">#   be included</span>
                <span class="n">cPeak</span> <span class="o">=</span> <span class="n">yDat</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">yDat</span><span class="p">[</span><span class="n">cPeak</span><span class="o">+</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">fitLim</span><span class="p">:</span>
                    <span class="n">cBounds</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cPeak</span><span class="o">+</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">])</span>

            <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="n">j</span>
        <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>

    <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
    <span class="c">#Iterate through the bounds</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cBounds</span><span class="p">):</span>
        <span class="n">b</span><span class="o">=</span><span class="n">cBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c">#Check if the region needs to be divided</span>
        <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">maxLength</span><span class="p">:</span>

            <span class="n">split</span> <span class="o">=</span> <span class="n">_split_region</span><span class="p">(</span><span class="n">yDat</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">splitLim</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">split</span><span class="p">:</span>

                <span class="c">#add the two regions separately</span>
                <span class="n">cBounds</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">split</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">cBounds</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">split</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="c">#Remove the original region</span>
                <span class="n">cBounds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">cBounds</span>


<span class="k">def</span> <span class="nf">_split_region</span><span class="p">(</span><span class="n">yDat</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">splitLim</span><span class="p">):</span>
        <span class="c">#Find the minimum absorption in the middle two quartiles of</span>
    <span class="c">#   the large complex</span>

    <span class="n">q</span><span class="o">=</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">4</span>
    <span class="n">cut</span> <span class="o">=</span> <span class="n">yDat</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">q</span><span class="p">:</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">q</span><span class="p">]</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span><span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">q</span>

    <span class="c">#Only break it up if the minimum absorption is actually low enough</span>
    <span class="k">if</span> <span class="n">yDat</span><span class="p">[</span><span class="n">cut</span><span class="p">]</span><span class="o">&gt;</span><span class="n">splitLim</span><span class="p">:</span>

        <span class="c">#Get the new two peaks</span>
        <span class="n">b1Peak</span> <span class="o">=</span> <span class="n">yDat</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">cut</span><span class="p">]</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span><span class="o">+</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">b2Peak</span> <span class="o">=</span> <span class="n">yDat</span><span class="p">[</span><span class="n">cut</span><span class="p">:</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span><span class="o">+</span><span class="n">cut</span>

        <span class="n">region_1</span> <span class="o">=</span> <span class="p">[</span><span class="n">b1Peak</span><span class="p">,</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">cut</span><span class="p">]</span>
        <span class="n">region_2</span> <span class="o">=</span> <span class="p">[</span><span class="n">b2Peak</span><span class="p">,</span><span class="n">cut</span><span class="p">,</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">region_1</span><span class="p">,</span><span class="n">region_2</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">return</span> <span class="p">[]</span>



<span class="k">def</span> <span class="nf">_gen_flux_lines</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">linesP</span><span class="p">,</span> <span class="n">speciesDict</span><span class="p">,</span><span class="n">firstLine</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the normalized flux for a region of wavelength space</span>
<span class="sd">    generated by a set of absorption lines.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (N) ndarray</span>
<span class="sd">        Array of wavelength</span>
<span class="sd">    linesP: (3,) ndarray</span>
<span class="sd">        Array giving sets of line parameters in </span>
<span class="sd">        form [[N1, b1, z1], ...]</span>
<span class="sd">    speciesDict : dictionary</span>
<span class="sd">        Dictionary containing all relevant parameters needed</span>
<span class="sd">        to create an absorption line of a given species (f,Gamma,lambda0)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    flux : (N) ndarray</span>
<span class="sd">        Array of normalized flux generated by the line parameters</span>
<span class="sd">        given in linesP over the wavelength space given in x. Same size as x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">linesP</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;numLines&#39;</span><span class="p">]):</span>
            <span class="n">f</span><span class="o">=</span><span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">g</span><span class="o">=</span><span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;Gamma&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">wl</span><span class="o">=</span><span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;wavelength&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span> <span class="n">_gen_tau</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">wl</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">firstLine</span><span class="p">:</span> 
                <span class="k">break</span>

    <span class="n">flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flux</span>

<span class="k">def</span> <span class="nf">_gen_tau</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">Gamma</span><span class="p">,</span> <span class="n">lambda_unshifted</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This calculates a flux distribution for given parameters using the yt</span>
<span class="sd">    voigt profile generator&quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">z</span><span class="o">=</span> <span class="n">p</span>
    
    <span class="c">#Calculating quantities</span>
    <span class="n">tau_o</span> <span class="o">=</span> <span class="mf">1.4973614E-15</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">lambda_unshifted</span><span class="o">/</span><span class="n">b</span>
    <span class="n">a</span><span class="o">=</span><span class="mf">7.95774715459E-15</span><span class="o">*</span><span class="n">Gamma</span><span class="o">*</span><span class="n">lambda_unshifted</span><span class="o">/</span><span class="n">b</span>
    <span class="n">x</span><span class="o">=</span><span class="mf">299792.458</span><span class="o">/</span><span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">lambda_unshifted</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">voigt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
    
    <span class="n">tau</span> <span class="o">=</span> <span class="n">tau_o</span><span class="o">*</span><span class="n">H</span>

    <span class="k">return</span> <span class="n">tau</span>

<span class="k">def</span> <span class="nf">_voigt_error</span><span class="p">(</span><span class="n">pTotal</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">yDat</span><span class="p">,</span> <span class="n">yFit</span><span class="p">,</span> <span class="n">speciesDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gives the error of each point  used to optimize the fit of a group</span>
<span class="sd">        of absorption lines to a given flux profile.</span>

<span class="sd">        If the parameters are not in the acceptable range as defined</span>
<span class="sd">        in speciesDict, the first value of the error array will</span>
<span class="sd">        contain a large value (999), to prevent the optimizer from running</span>
<span class="sd">        into negative number problems.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pTotal : (3,) ndarray </span>
<span class="sd">        Array with form [[N1, b1, z1], ...] </span>
<span class="sd">    x : (N) ndarray</span>
<span class="sd">        array of wavelengths [nm]</span>
<span class="sd">    yDat : (N) ndarray</span>
<span class="sd">        desired normalized flux from fits of lines in wavelength</span>
<span class="sd">        space given by x</span>
<span class="sd">    yFit : (N) ndarray</span>
<span class="sd">        previous fit over the wavelength space given by x.</span>
<span class="sd">    speciesDict : dictionary</span>
<span class="sd">        dictionary containing all relevant parameters needed</span>
<span class="sd">        to create an absorption line of a given species (f,Gamma,lambda0)</span>
<span class="sd">        as well as max and min values for parameters to be fit</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    error : (N) ndarray</span>
<span class="sd">        the difference between the fit generated by the parameters</span>
<span class="sd">        given in pTotal multiplied by the previous fit and the desired</span>
<span class="sd">        flux profile, w/ first index modified appropriately for bad </span>
<span class="sd">        parameter choices and additional penalty for fitting with a lower</span>
<span class="sd">        flux than observed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pTotal</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">yNewFit</span> <span class="o">=</span> <span class="n">_gen_flux_lines</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">pTotal</span><span class="p">,</span><span class="n">speciesDict</span><span class="p">)</span>

    <span class="n">error</span> <span class="o">=</span> <span class="n">yDat</span><span class="o">-</span><span class="n">yFit</span><span class="o">*</span><span class="n">yNewFit</span>
    <span class="n">error_plus</span> <span class="o">=</span> <span class="p">(</span><span class="n">yDat</span><span class="o">-</span><span class="n">yFit</span><span class="o">*</span><span class="n">yNewFit</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">error</span> <span class="o">=</span> <span class="n">error</span><span class="o">+</span><span class="n">error_plus</span>
    <span class="n">error</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_check_params</span><span class="p">(</span><span class="n">pTotal</span><span class="p">,</span><span class="n">speciesDict</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">error</span>

<span class="k">def</span> <span class="nf">_check_params</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">speciesDict</span><span class="p">,</span><span class="n">xb</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check to see if any of the parameters in p fall outside the range </span>
<span class="sd">        given in speciesDict or on the boundaries</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : (3,) ndarray</span>
<span class="sd">        array with form [[N1, b1, z1], ...] </span>
<span class="sd">    speciesDict : dictionary</span>
<span class="sd">        dictionary with properties giving the max and min</span>
<span class="sd">        values appropriate for each parameter N,b, and z.</span>
<span class="sd">    xb : (N) ndarray</span>
<span class="sd">        wavelength array [nm]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    check : int</span>
<span class="sd">        0 if all values are fine</span>
<span class="sd">        999 if any values fall outside acceptable range</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">minz</span> <span class="o">=</span> <span class="p">(</span><span class="n">xb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;wavelength&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">maxz</span> <span class="o">=</span> <span class="p">(</span><span class="n">xb</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;wavelength&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>

    <span class="n">check</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;maxN&#39;</span><span class="p">])</span> <span class="ow">or</span>\
          <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;minN&#39;</span><span class="p">])</span> <span class="ow">or</span>\
          <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;maxb&#39;</span><span class="p">])</span> <span class="ow">or</span>\
          <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;minb&#39;</span><span class="p">])</span> <span class="ow">or</span>\
          <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">maxz</span><span class="p">)</span> <span class="ow">or</span>\
          <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">minz</span><span class="p">):</span>
              <span class="n">check</span> <span class="o">=</span> <span class="mi">999</span>
              
    <span class="k">return</span> <span class="n">check</span>

<span class="k">def</span> <span class="nf">_check_optimization_init</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">speciesDict</span><span class="p">,</span><span class="n">initz</span><span class="p">,</span><span class="n">xb</span><span class="p">,</span><span class="n">yDat</span><span class="p">,</span><span class="n">yFit</span><span class="p">,</span><span class="n">minSize</span><span class="p">,</span><span class="n">errorBound</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check to see if any of the parameters in p are the</span>
<span class="sd">    same as initial paramters and if so, attempt to </span>
<span class="sd">    split the region and refit it.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : (3,) ndarray</span>
<span class="sd">        array with form [[N1, b1, z1], ...] </span>
<span class="sd">    speciesDict : dictionary</span>
<span class="sd">        dictionary with properties giving the max and min</span>
<span class="sd">        values appropriate for each parameter N,b, and z.</span>
<span class="sd">    x : (N) ndarray</span>
<span class="sd">        wavelength array [nm]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Check if anything is a default parameter</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_N&#39;</span><span class="p">])</span> <span class="ow">or</span>\
          <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_N&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span> <span class="ow">or</span>\
          <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_N&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="ow">or</span>\
          <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_N&#39;</span><span class="p">]</span><span class="o">*.</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span>\
          <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;init_b&#39;</span><span class="p">])</span> <span class="ow">or</span>\
          <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">speciesDict</span><span class="p">[</span><span class="s">&#39;maxb&#39;</span><span class="p">]):</span>

            <span class="c"># These are the initial bounds</span>
            <span class="n">init_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="n">yDat</span><span class="o">.</span><span class="n">argmin</span><span class="p">(),</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">xb</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c"># Gratitutous limit for splitting region</span>
            <span class="n">newSplitLim</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">yDat</span><span class="p">))</span><span class="o">*.</span><span class="mi">5</span>

            <span class="c"># Attempt to split region</span>
            <span class="n">split</span> <span class="o">=</span> <span class="n">_split_region</span><span class="p">(</span><span class="n">yDat</span><span class="p">,</span><span class="n">init_bounds</span><span class="p">,</span><span class="n">newSplitLim</span><span class="p">)</span>
            
            <span class="c"># If we can&#39;t split it, just reject it. Its unphysical</span>
            <span class="c"># to just keep the default parameters and we&#39;re out of</span>
            <span class="c"># options at this point</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">split</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>

            <span class="c"># Else set up the bounds for each region and fit separately</span>
            <span class="n">b1</span><span class="p">,</span><span class="n">b2</span> <span class="o">=</span> <span class="n">split</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">split</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">p1</span><span class="p">,</span><span class="n">flag</span> <span class="o">=</span> <span class="n">_complex_fit</span><span class="p">(</span><span class="n">xb</span><span class="p">[:</span><span class="n">b1</span><span class="p">],</span> <span class="n">yDat</span><span class="p">[:</span><span class="n">b1</span><span class="p">],</span> <span class="n">yFit</span><span class="p">[:</span><span class="n">b1</span><span class="p">],</span>
                            <span class="n">initz</span><span class="p">,</span> <span class="n">minSize</span><span class="p">,</span> <span class="n">errorBound</span><span class="p">,</span> <span class="n">speciesDict</span><span class="p">)</span>

            <span class="n">p2</span><span class="p">,</span><span class="n">flag</span> <span class="o">=</span> <span class="n">_complex_fit</span><span class="p">(</span><span class="n">xb</span><span class="p">[</span><span class="n">b2</span><span class="p">:],</span> <span class="n">yDat</span><span class="p">[</span><span class="n">b2</span><span class="p">:],</span> <span class="n">yFit</span><span class="p">[</span><span class="n">b2</span><span class="p">:],</span>
                            <span class="n">initz</span><span class="p">,</span> <span class="n">minSize</span><span class="p">,</span> <span class="n">errorBound</span><span class="p">,</span> <span class="n">speciesDict</span><span class="p">)</span>

            <span class="c"># Make the final line parameters. Its annoying because</span>
            <span class="c"># one or both regions may have fit to nothing</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p2</span>

    <span class="k">return</span> <span class="n">p</span>


<span class="k">def</span> <span class="nf">_check_numerical_instability</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">speciesDict</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check to see if any of the parameters in p are causing</span>
<span class="sd">    unstable numerical effects outside the region of fit</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : (3,) ndarray</span>
<span class="sd">        array with form [[N1, b1, z1], ...] </span>
<span class="sd">    speciesDict : dictionary</span>
<span class="sd">        dictionary with properties giving the max and min</span>
<span class="sd">        values appropriate for each parameter N,b, and z.</span>
<span class="sd">    x : (N) ndarray</span>
<span class="sd">        wavelength array [nm]</span>
<span class="sd">    b : (3) list</span>
<span class="sd">        list of integers indicating bounds of region fit in x</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">remove_lines</span> <span class="o">=</span> <span class="p">[]</span>


    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>

        <span class="c"># First to check if the line is at risk for instability</span>
        <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">5</span> <span class="ow">or</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1E12</span><span class="p">:</span>


            <span class="c"># get all flux that isn&#39;t part of fit plus a little wiggle room</span>
            <span class="c"># max and min to prevent boundary errors</span>

            <span class="n">flux</span> <span class="o">=</span> <span class="n">_gen_flux_lines</span><span class="p">(</span><span class="n">x</span><span class="p">,[</span><span class="n">line</span><span class="p">],</span><span class="n">speciesDict</span><span class="p">,</span><span class="n">firstLine</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">flux</span><span class="p">[:</span><span class="nb">max</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">)],</span> <span class="n">flux</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):]]</span>

            <span class="c">#Find regions that are absorbing outside the region we fit</span>
            <span class="n">flux_dif</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">flux</span>
            <span class="n">absorbing_coefficient</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">flux_dif</span><span class="p">))</span>


            <span class="c">#Really there shouldn&#39;t be any absorption outside</span>
            <span class="c">#the region we fit, but we&#39;ll give some leeway.</span>
            <span class="c">#for high resolution spectra the tiny bits on the edges</span>
            <span class="c">#can give a non negligible amount of flux. Plus the errors</span>
            <span class="c">#we are looking for are HUGE.</span>
            <span class="k">if</span> <span class="n">absorbing_coefficient</span> <span class="o">&gt;</span> <span class="o">.</span><span class="mi">1</span><span class="p">:</span>

                <span class="c"># we just set it to no fit because we&#39;ve tried</span>
                <span class="c"># everything else at this point. this region just sucks :(</span>
                <span class="n">remove_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">remove_lines</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">remove_lines</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">p</span>

<span class="k">def</span> <span class="nf">_output_fit</span><span class="p">(</span><span class="n">lineDic</span><span class="p">,</span> <span class="n">file_name</span> <span class="o">=</span> <span class="s">&#39;spectrum_fit.h5&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is designed to output the parameters of the series</span>
<span class="sd">    of lines used to fit an absorption spectrum. </span>

<span class="sd">    The dataset contains entries in the form species/N, species/b</span>
<span class="sd">    species/z, and species/complex. The ith entry in each of the datasets</span>
<span class="sd">    is the fitted parameter for the ith line fitted to the spectrum for</span>
<span class="sd">    the given species. The species names come from the fitted line</span>
<span class="sd">    dictionary.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lineDic : dictionary</span>
<span class="sd">        Dictionary of dictionaries representing the fit lines. </span>
<span class="sd">        Top level keys are the species given in orderFits and the corresponding</span>
<span class="sd">        entries are dictionaries with the keys &#39;N&#39;,&#39;b&#39;,&#39;z&#39;, and &#39;group#&#39;. </span>
<span class="sd">        Each of these corresponds to a list of the parameters for every</span>
<span class="sd">        accepted fitted line. </span>
<span class="sd">    fileName : string, optional</span>
<span class="sd">        Name of the file to output fit to. Default = &#39;spectrum_fit.h5&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ion</span><span class="p">,</span> <span class="n">params</span> <span class="ow">in</span> <span class="n">lineDic</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s">&quot;{0}/N&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ion</span><span class="p">),</span><span class="n">data</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s">&#39;N&#39;</span><span class="p">])</span>
        <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s">&quot;{0}/b&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ion</span><span class="p">),</span><span class="n">data</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">])</span>
        <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s">&quot;{0}/z&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ion</span><span class="p">),</span><span class="n">data</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s">&#39;z&#39;</span><span class="p">])</span>
        <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s">&quot;{0}/complex&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ion</span><span class="p">),</span><span class="n">data</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s">&#39;group#&#39;</span><span class="p">])</span>
    <span class="n">mylog</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&#39;Writing spectrum fit to {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">file_name</span><span class="p">))</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>

    </div>
      
  </div>
</div>
    <div class="footer">
      &copy; Copyright 2013, the yt Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>