#
# PySNMP MIB module ROHC-RTP-MIB (http://pysnmp.sf.net)
# ASN.1 source http://mibs.snmplabs.com:80/asn1/ROHC-RTP-MIB
# Produced by pysmi-0.0.3 at Wed Jul  1 22:31:38 2015
# On host cray platform Linux version 2.6.37.6-smp by user ilya
# Using Python version 2.7.2 (default, Apr  2 2012, 20:32:47) 
#
( Integer, ObjectIdentifier, OctetString, ) = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
( NamedValues, ) = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
( ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ) = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint")
( rohcChannelID, rohcContextCID, ) = mibBuilder.importSymbols("ROHC-MIB", "rohcChannelID", "rohcContextCID")
( NotificationGroup, ModuleCompliance, ObjectGroup, ) = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
( Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, MibIdentifier, mib_2, IpAddress, TimeTicks, Counter64, Unsigned32, ModuleIdentity, Gauge32, iso, ObjectIdentity, Bits, Counter32, ) = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "MibIdentifier", "mib-2", "IpAddress", "TimeTicks", "Counter64", "Unsigned32", "ModuleIdentity", "Gauge32", "iso", "ObjectIdentity", "Bits", "Counter32")
( TruthValue, DisplayString, TextualConvention, ) = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "TextualConvention")
rohcRtpMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 114)).setRevisions(("2004-06-03 00:00",))
if mibBuilder.loadTexts: rohcRtpMIB.setOrganization('IETF Robust Header Compression Working Group')
if mibBuilder.loadTexts: rohcRtpMIB.setContactInfo('WG charter:\n          http://www.ietf.org/html.charters/rohc-charter.html\n\n        Mailing Lists:\n          General Discussion: rohc@ietf.org\n          To Subscribe: rohc-request@ietf.org\n          In Body: subscribe your_email_address\n\n        Editor:\n          Juergen Quittek\n          NEC Europe Ltd.\n          Network Laboratories\n          Kurfuersten-Anlage 36\n          69221 Heidelberg\n          Germany\n          Tel: +49 6221 90511-15\n          EMail: quittek@netlab.nec.de')
if mibBuilder.loadTexts: rohcRtpMIB.setDescription('This MIB module defines a set of objects for monitoring\n         and configuring RObust Header Compression (ROHC).\n         The objects are specific to ROHC RTP (profile 0x0001),\n         ROHC UDP (profile 0x0002), and ROHC ESP (profile 0x0003)\n         defined in RFC 3095 and for the ROHC LLA profile (profile\n         0x0005) defined in RFC 3242.\n\n         Copyright (C) The Internet Society (2004). The\n         initial version of this MIB module was published\n         in RFC 3816. For full legal notices see the RFC\n         itself or see:\n         http://www.ietf.org/copyrights/ianamib.html')
rohcRtpObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 114, 1))
rohcRtpConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 114, 2))
rohcRtpContextTable = MibTable((1, 3, 6, 1, 2, 1, 114, 1, 1), )
if mibBuilder.loadTexts: rohcRtpContextTable.setDescription('This table lists and describes RTP profile specific\n         properties of compressor contexts and decompressor\n         contexts.  It extends the rohcContextTable of the\n         ROHC-MIB module.')
rohcRtpContextEntry = MibTableRow((1, 3, 6, 1, 2, 1, 114, 1, 1, 1), ).setIndexNames((0, "ROHC-RTP-MIB", "rohcChannelID"), (0, "ROHC-RTP-MIB", "rohcContextCID"))
if mibBuilder.loadTexts: rohcRtpContextEntry.setDescription('An entry describing a particular context.')
rohcRtpContextState = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=SingleValueConstraint(1, 2, 3, 4, 5, 6,)).clone(namedValues=NamedValues(("initAndRefresh", 1), ("firstOrder", 2), ("secondOrder", 3), ("noContext", 4), ("staticContext", 5), ("fullContext", 6),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpContextState.setDescription('State of the context as defined in RFC 3095.  States\n         initAndRefresh(1), firstOrder(2), and secondOrder(3)\n         are states of compressor contexts, states noContext(4),\n         staticContext(5) and fullContext(6) are states of\n         decompressor contexts.')
rohcRtpContextMode = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=SingleValueConstraint(1, 2, 3,)).clone(namedValues=NamedValues(("unidirectional", 1), ("optimistic", 2), ("reliable", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpContextMode.setDescription('Mode of the context.')
rohcRtpContextAlwaysPad = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpContextAlwaysPad.setDescription('Boolean, only applicable to compressor contexts using the\n\n         LLA profile.  If its value is true, the compressor must\n         pad every RHP packet with a minimum of one octet ROHC\n         padding.\n\n         The value of this object is only valid for LLA profiles,\n         i.e., if the corresponding rohcProfile has a value of\n         0x0005.  If the corresponding rohcProfile has a value\n         other than 0x0005, then this object MUST NOT be\n         instantiated.')
rohcRtpContextLargePktsAllowed = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 1, 1, 6), TruthValue().clone('true')).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpContextLargePktsAllowed.setDescription('Boolean, only applicable to compressor contexts using the\n         LLA profile.  It specifies how to handle packets that do\n         not fit any of the preferred packet sizes specified.  If\n         its value is true, the compressor must deliver the larger\n         packet as-is and must not use segmentation.  If it is set\n         to false, the ROHC segmentation scheme must be used to\n         split the packet into two or more segments, and each\n         segment must further be padded to fit one of the preferred\n         packet sizes.\n\n         The value of this object is only valid for LLA profiles,\n         i.e., if the corresponding rohcProfile has a value of\n         0x0005.  If the corresponding rohcProfile has a value\n         other than 0x0005, then this object MUST NOT be\n         instantiated.')
rohcRtpContextVerifyPeriod = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpContextVerifyPeriod.setDescription('This object is only applicable to compressor contexts\n         using the LLA profile.  It specifies the minimum frequency\n         with which a packet validating the context must be sent.\n         This tells the compressor that a packet containing a CRC\n\n         field must be sent at least once every N packets, where N\n         is the value of the object.  A value of 0 indicates that\n         periodical verifications are disabled.\n\n         The value of this object is only valid for LLA profiles,\n         i.e., if the corresponding rohcProfile has a value of\n         0x0005.  If the corresponding rohcProfile has a value\n         other than 0x0005, then this object MUST NOT be\n         instantiated.')
rohcRtpContextSizesAllowed = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1,4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpContextSizesAllowed.setDescription('The value of this object is only valid for decompressor\n         contexts, i.e., if rohcInstanceType of the corresponding\n         rohcContextEntry has the value decompressor(2).  For\n         compressor contexts where rohcInstanceType has the value\n         compressor(1), this object MUST NOT be instantiated.\n\n         This object contains the number of different packet sizes\n         that may be used in the context.')
rohcRtpContextSizesUsed = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1,4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpContextSizesUsed.setDescription('The value of this object is only valid for decompressor\n         contexts, i.e., if rohcInstanceType of the corresponding\n         rohcContextEntry has the value decompressor(2).  For\n         compressor contexts where rohcInstanceType has the value\n         compressor(1), this object MUST NOT be instantiated.\n\n         This object contains the number of different packet sizes\n         that are used in the context.')
rohcRtpContextACKs = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpContextACKs.setDescription('The number of all positive feedbacks (ACK) sent or\n         received in this context, respectively.\n\n         Discontinuities in the value of this counter can\n         occur at re-initialization of the management\n         system, and at other times as indicated by the\n         value of ifCounterDiscontinuityTime.  For checking\n         ifCounterDiscontinuityTime, the interface index is\n         required.  It can be determined by reading the\n         rohcChannelTable of the ROHC-MIB.')
rohcRtpContextNACKs = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpContextNACKs.setDescription('The number of all dynamic negative feedbacks (ACK) sent\n         or received in this context, respectively.\n\n         Discontinuities in the value of this counter can\n         occur at re-initialization of the management\n         system, and at other times as indicated by the\n         value of ifCounterDiscontinuityTime.  For checking\n         ifCounterDiscontinuityTime, the interface index is\n         required.  It can be determined by reading the\n         rohcChannelTable of the ROHC-MIB.')
rohcRtpContextSNACKs = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpContextSNACKs.setDescription('The number of all static negative feedbacks (ACK) sent\n         or received in this context, respectively.\n\n         Discontinuities in the value of this counter can\n         occur at re-initialization of the management\n\n         system, and at other times as indicated by the\n         value of ifCounterDiscontinuityTime.  For checking\n         ifCounterDiscontinuityTime, the interface index is\n         required.  It can be determined by reading the\n         rohcChannelTable of the ROHC-MIB.')
rohcRtpContextNHPs = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpContextNHPs.setDescription('This object is only applicable to contexts using the\n         LLA profile.  It contains the number of all no-header\n         packets (NHP) sent or received in this context,\n         respectively.\n\n         Discontinuities in the value of this counter can\n         occur at re-initialization of the management\n         system, and at other times as indicated by the\n         value of ifCounterDiscontinuityTime.  For checking\n         ifCounterDiscontinuityTime, the interface index is\n         required.  It can be determined by reading the\n         rohcChannelTable of the ROHC-MIB.\n\n         The value of this object is only valid for LLA profiles,\n         i.e., if the corresponding rohcProfile has a value of\n         0x0005.  If the corresponding rohcProfile has a value\n         other than 0x0005, then this object MUST NOT be\n         instantiated.')
rohcRtpContextCSPs = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpContextCSPs.setDescription('This object is only applicable to contexts using the\n         LLA profile.  It contains the number of all context\n         synchronization packets (CSP) sent or received in this\n         context, respectively.\n\n         Discontinuities in the value of this counter can\n         occur at re-initialization of the management\n\n         system, and at other times as indicated by the\n         value of ifCounterDiscontinuityTime.  For checking\n         ifCounterDiscontinuityTime, the interface index is\n         required.  It can be determined by reading the\n         rohcChannelTable of the ROHC-MIB.\n\n         The value of this object is only valid for LLA profiles,\n         i.e., if the corresponding rohcProfile has a value of\n         0x0005.  If the corresponding rohcProfile has a value\n         other than 0x0005, then this object MUST NOT be\n         instantiated.')
rohcRtpContextCCPs = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpContextCCPs.setDescription('This object is only applicable to contexts using the\n         LLA profile.  It contains the number of all context check\n         packets (CCP) sent or received in this context,\n         respectively.\n\n         Discontinuities in the value of this counter can\n         occur at re-initialization of the management\n         system, and at other times as indicated by the\n         value of ifCounterDiscontinuityTime.  For checking\n         ifCounterDiscontinuityTime, the interface index is\n         required.  It can be determined by reading the\n         rohcChannelTable of the ROHC-MIB.\n\n         The value of this object is only valid for LLA profiles,\n         i.e., if the corresponding rohcProfile has a value of\n         0x0005.  If the corresponding rohcProfile has a value\n         other than 0x0005, then this object MUST NOT be\n         instantiated.')
rohcRtpContextPktsLostPhysical = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpContextPktsLostPhysical.setDescription('This object is only applicable to decompressor contexts\n\n         using the LLA profile.  It contains the number of physical\n         packet losses on the link between compressor and\n         decompressor, that have been indicated to the decompressor.\n\n         Discontinuities in the value of this counter can\n         occur at re-initialization of the management\n         system, and at other times as indicated by the\n         value of ifCounterDiscontinuityTime.  For checking\n         ifCounterDiscontinuityTime, the interface index is\n         required.  It can be determined by reading the\n         rohcChannelTable of the ROHC-MIB.\n\n         The value of this object is only valid for LLA profiles,\n         i.e., if the corresponding rohcProfile has a value of\n         0x0005.  If the corresponding rohcProfile has a value\n         other than 0x0005, then this object MUST NOT be\n         instantiated.')
rohcRtpContextPktsLostPreLink = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpContextPktsLostPreLink.setDescription('This object is only applicable to decompressor contexts\n         using the LLA profile.  It contains the number of pre-link\n         packet losses on the link between compressor and\n         decompressor, that have been indicated to the decompressor.\n\n         Discontinuities in the value of this counter can\n         occur at re-initialization of the management\n         system, and at other times as indicated by the\n         value of ifCounterDiscontinuityTime.  For checking\n         ifCounterDiscontinuityTime, the interface index is\n         required.  It can be determined by reading the\n         rohcChannelTable of the ROHC-MIB.\n\n         The value of this object is only valid for LLA profiles,\n         i.e., if the corresponding rohcProfile has a value of\n         0x0005.  If the corresponding rohcProfile has a value\n         other than 0x0005, then this object MUST NOT be\n         instantiated.')
rohcRtpPacketSizeTable = MibTable((1, 3, 6, 1, 2, 1, 114, 1, 2), )
if mibBuilder.loadTexts: rohcRtpPacketSizeTable.setDescription('This table lists all allowed, preferred, and used packet\n         sizes per compressor context and channel.\n\n         Note, that the sizes table represents implementation\n         parameters that are suggested by RFC 3095 and/or RFC 3242,\n         but that are not mandatory.')
rohcRtpPacketSizeEntry = MibTableRow((1, 3, 6, 1, 2, 1, 114, 1, 2, 1), ).setIndexNames((0, "ROHC-RTP-MIB", "rohcChannelID"), (0, "ROHC-RTP-MIB", "rohcContextCID"), (0, "ROHC-RTP-MIB", "rohcRtpPacketSize"))
if mibBuilder.loadTexts: rohcRtpPacketSizeEntry.setDescription('An entry of a particular packet size.')
rohcRtpPacketSize = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1,4294967295)))
if mibBuilder.loadTexts: rohcRtpPacketSize.setDescription('A packet size used as index.')
rohcRtpPacketSizePreferred = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 2, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpPacketSizePreferred.setDescription('This object is only applicable to compressor contexts\n         using the LLA profile.  When retrieved, it will have\n         the value true(1) if the packet size is preferred.\n         Otherwise, its value will be false(2).\n\n         The value of this object is only valid for LLA profiles,\n         i.e., if the corresponding rohcProfile has a value of\n         0x0005.  If the corresponding rohcProfile has a value\n         other than 0x0005, then this object MUST NOT be\n         instantiated.')
rohcRtpPacketSizeUsed = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 2, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpPacketSizeUsed.setDescription('This object is only applicable to compressor contexts\n         using the UDP, RTP, or ESP profile.  When retrieved,\n         it will have the value true(1) if the packet size is\n         used.  Otherwise, its value will be false(2).\n\n         The value of this object is only valid for UDP, RTP,\n         and ESP profiles, i.e., if the corresponding rohcProfile\n         has a value of either 0x0001, 0x0002 or 0x0003.  If\n         the corresponding rohcProfile has a value other than\n         0x0001, 0x0002 or 0x0003, then this object MUST NOT be\n         instantiated.')
rohcRtpPacketSizeRestrictedType = MibTableColumn((1, 3, 6, 1, 2, 1, 114, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=SingleValueConstraint(1, 2, 3,)).clone(namedValues=NamedValues(("nhpOnly", 1), ("rhpOnly", 2), ("noRestrictions", 3),))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rohcRtpPacketSizeRestrictedType.setDescription('This object is only applicable to preferred packet\n\n         sizes of compressor contexts using the LLA profile.\n         When retrieved, it will indicate whether the packet\n         size is preferred for NHP only, for RHP only, or\n         for both of them.\n\n         The value of this object is only valid for LLA profiles,\n         i.e., if the corresponding rohcProfile has a value of\n         0x0005.  If the corresponding rohcProfile has a value\n         other than 0x0005, then this object MUST NOT be\n         instantiated.')
rohcRtpCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 114, 2, 1))
rohcRtpGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 114, 2, 2))
rohcRtpCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 114, 2, 1, 1)).setObjects(*(("ROHC-RTP-MIB", "rohcRtpContextGroup"), ("ROHC-RTP-MIB", "rohcRtpPacketSizesGroup"), ("ROHC-RTP-MIB", "rohcRtpStatisticsGroup"),))
if mibBuilder.loadTexts: rohcRtpCompliance.setDescription('The compliance statement for SNMP entities that implement\n         the ROHC-RTP-MIB.\n\n         Note that compliance with this compliance\n         statement requires compliance with the\n         rohcCompliance MODULE-COMPLIANCE statement of the\n         ROHC-MIB and with the ifCompliance3 MODULE-COMPLIANCE\n         statement of the IF-MIB (RFC2863).')
rohcRtpContextGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 114, 2, 2, 1)).setObjects(*(("ROHC-RTP-MIB", "rohcRtpContextState"), ("ROHC-RTP-MIB", "rohcRtpContextMode"), ("ROHC-RTP-MIB", "rohcRtpContextAlwaysPad"), ("ROHC-RTP-MIB", "rohcRtpContextLargePktsAllowed"), ("ROHC-RTP-MIB", "rohcRtpContextVerifyPeriod"),))
if mibBuilder.loadTexts: rohcRtpContextGroup.setDescription('A collection of objects providing information about\n         ROHC RTP compressors and decompressors.')
rohcRtpPacketSizesGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 114, 2, 2, 2)).setObjects(*(("ROHC-RTP-MIB", "rohcRtpContextSizesAllowed"), ("ROHC-RTP-MIB", "rohcRtpContextSizesUsed"), ("ROHC-RTP-MIB", "rohcRtpPacketSizePreferred"), ("ROHC-RTP-MIB", "rohcRtpPacketSizeUsed"), ("ROHC-RTP-MIB", "rohcRtpPacketSizeRestrictedType"),))
if mibBuilder.loadTexts: rohcRtpPacketSizesGroup.setDescription('A collection of objects providing information about\n         allowed and used packet sizes at a ROHC RTP compressor.')
rohcRtpStatisticsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 114, 2, 2, 3)).setObjects(*(("ROHC-RTP-MIB", "rohcRtpContextACKs"), ("ROHC-RTP-MIB", "rohcRtpContextNACKs"), ("ROHC-RTP-MIB", "rohcRtpContextSNACKs"), ("ROHC-RTP-MIB", "rohcRtpContextNHPs"), ("ROHC-RTP-MIB", "rohcRtpContextCSPs"), ("ROHC-RTP-MIB", "rohcRtpContextCCPs"), ("ROHC-RTP-MIB", "rohcRtpContextPktsLostPhysical"), ("ROHC-RTP-MIB", "rohcRtpContextPktsLostPreLink"),))
if mibBuilder.loadTexts: rohcRtpStatisticsGroup.setDescription('A collection of objects providing ROHC compressor and\n         decompressor statistics.')
mibBuilder.exportSymbols("ROHC-RTP-MIB", rohcRtpContextCSPs=rohcRtpContextCSPs, rohcRtpCompliance=rohcRtpCompliance, rohcRtpCompliances=rohcRtpCompliances, rohcRtpContextVerifyPeriod=rohcRtpContextVerifyPeriod, rohcRtpContextPktsLostPreLink=rohcRtpContextPktsLostPreLink, rohcRtpContextTable=rohcRtpContextTable, rohcRtpContextGroup=rohcRtpContextGroup, rohcRtpContextCCPs=rohcRtpContextCCPs, rohcRtpContextAlwaysPad=rohcRtpContextAlwaysPad, rohcRtpContextState=rohcRtpContextState, rohcRtpGroups=rohcRtpGroups, rohcRtpObjects=rohcRtpObjects, rohcRtpContextNHPs=rohcRtpContextNHPs, rohcRtpContextACKs=rohcRtpContextACKs, rohcRtpContextPktsLostPhysical=rohcRtpContextPktsLostPhysical, PYSNMP_MODULE_ID=rohcRtpMIB, rohcRtpContextSizesUsed=rohcRtpContextSizesUsed, rohcRtpContextSNACKs=rohcRtpContextSNACKs, rohcRtpStatisticsGroup=rohcRtpStatisticsGroup, rohcRtpPacketSize=rohcRtpPacketSize, rohcRtpContextEntry=rohcRtpContextEntry, rohcRtpPacketSizeEntry=rohcRtpPacketSizeEntry, rohcRtpContextSizesAllowed=rohcRtpContextSizesAllowed, rohcRtpPacketSizeRestrictedType=rohcRtpPacketSizeRestrictedType, rohcRtpContextNACKs=rohcRtpContextNACKs, rohcRtpMIB=rohcRtpMIB, rohcRtpPacketSizePreferred=rohcRtpPacketSizePreferred, rohcRtpPacketSizesGroup=rohcRtpPacketSizesGroup, rohcRtpPacketSizeUsed=rohcRtpPacketSizeUsed, rohcRtpContextMode=rohcRtpContextMode, rohcRtpContextLargePktsAllowed=rohcRtpContextLargePktsAllowed, rohcRtpConformance=rohcRtpConformance, rohcRtpPacketSizeTable=rohcRtpPacketSizeTable)
