#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import koverse.thriftgen.ttypes
import koverse.thriftgen.security.ttypes
import koverse.thriftgen.aggregate.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TCollectionState:
  Ready = 1
  Deleting = 2
  Initializing = 3

  _VALUES_TO_NAMES = {
    1: "Ready",
    2: "Deleting",
    3: "Initializing",
  }

  _NAMES_TO_VALUES = {
    "Ready": 1,
    "Deleting": 2,
    "Initializing": 3,
  }

class TIndexingPolicyFieldMode:
  Inclusive = 1
  Exclusive = 2

  _VALUES_TO_NAMES = {
    1: "Inclusive",
    2: "Exclusive",
  }

  _NAMES_TO_VALUES = {
    "Inclusive": 1,
    "Exclusive": 2,
  }


class TFieldTypePair:
  """
  Attributes:
   - fieldName
   - fieldType
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'fieldName', None, None, ), # 1
    (2, TType.STRING, 'fieldType', None, None, ), # 2
  )

  def __init__(self, fieldName=None, fieldType=None,):
    self.fieldName = fieldName
    self.fieldType = fieldType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.fieldName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.fieldType = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TFieldTypePair')
    if self.fieldName is not None:
      oprot.writeFieldBegin('fieldName', TType.STRING, 1)
      oprot.writeString(self.fieldName)
      oprot.writeFieldEnd()
    if self.fieldType is not None:
      oprot.writeFieldBegin('fieldType', TType.STRING, 2)
      oprot.writeString(self.fieldType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TFieldDetails:
  """
  Attributes:
   - fieldName
   - typeHistogram
   - lengthsHistogram
   - recordCount
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'fieldName', None, None, ), # 1
    (2, TType.MAP, 'typeHistogram', (TType.STRING,None,TType.I64,None), None, ), # 2
    (3, TType.MAP, 'lengthsHistogram', (TType.I32,None,TType.I64,None), None, ), # 3
    (4, TType.I64, 'recordCount', None, None, ), # 4
  )

  def __init__(self, fieldName=None, typeHistogram=None, lengthsHistogram=None, recordCount=None,):
    self.fieldName = fieldName
    self.typeHistogram = typeHistogram
    self.lengthsHistogram = lengthsHistogram
    self.recordCount = recordCount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.fieldName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.typeHistogram = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in xrange(_size0):
            _key5 = iprot.readString();
            _val6 = iprot.readI64();
            self.typeHistogram[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.lengthsHistogram = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin()
          for _i11 in xrange(_size7):
            _key12 = iprot.readI32();
            _val13 = iprot.readI64();
            self.lengthsHistogram[_key12] = _val13
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.recordCount = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TFieldDetails')
    if self.fieldName is not None:
      oprot.writeFieldBegin('fieldName', TType.STRING, 1)
      oprot.writeString(self.fieldName)
      oprot.writeFieldEnd()
    if self.typeHistogram is not None:
      oprot.writeFieldBegin('typeHistogram', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.typeHistogram))
      for kiter14,viter15 in self.typeHistogram.items():
        oprot.writeString(kiter14)
        oprot.writeI64(viter15)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.lengthsHistogram is not None:
      oprot.writeFieldBegin('lengthsHistogram', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.I64, len(self.lengthsHistogram))
      for kiter16,viter17 in self.lengthsHistogram.items():
        oprot.writeI32(kiter16)
        oprot.writeI64(viter17)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.recordCount is not None:
      oprot.writeFieldBegin('recordCount', TType.I64, 4)
      oprot.writeI64(self.recordCount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TIndexTermConfiguration:
  """
  Attributes:
   - indexTermTransformerClassName
   - parameters
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'indexTermTransformerClassName', None, None, ), # 1
    (2, TType.MAP, 'parameters', (TType.STRING,None,TType.STRING,None), None, ), # 2
  )

  def __init__(self, indexTermTransformerClassName=None, parameters=None,):
    self.indexTermTransformerClassName = indexTermTransformerClassName
    self.parameters = parameters

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.indexTermTransformerClassName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parameters = {}
          (_ktype19, _vtype20, _size18 ) = iprot.readMapBegin()
          for _i22 in xrange(_size18):
            _key23 = iprot.readString();
            _val24 = iprot.readString();
            self.parameters[_key23] = _val24
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TIndexTermConfiguration')
    if self.indexTermTransformerClassName is not None:
      oprot.writeFieldBegin('indexTermTransformerClassName', TType.STRING, 1)
      oprot.writeString(self.indexTermTransformerClassName)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
      for kiter25,viter26 in self.parameters.items():
        oprot.writeString(kiter25)
        oprot.writeString(viter26)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TFieldTypeIndexTermConfigurationPair:
  """
  Attributes:
   - fieldTypePair
   - indexTermConfiguration
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'fieldTypePair', (TFieldTypePair, TFieldTypePair.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'indexTermConfiguration', (TIndexTermConfiguration, TIndexTermConfiguration.thrift_spec), None, ), # 2
  )

  def __init__(self, fieldTypePair=None, indexTermConfiguration=None,):
    self.fieldTypePair = fieldTypePair
    self.indexTermConfiguration = indexTermConfiguration

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.fieldTypePair = TFieldTypePair()
          self.fieldTypePair.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.indexTermConfiguration = TIndexTermConfiguration()
          self.indexTermConfiguration.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TFieldTypeIndexTermConfigurationPair')
    if self.fieldTypePair is not None:
      oprot.writeFieldBegin('fieldTypePair', TType.STRUCT, 1)
      self.fieldTypePair.write(oprot)
      oprot.writeFieldEnd()
    if self.indexTermConfiguration is not None:
      oprot.writeFieldBegin('indexTermConfiguration', TType.STRUCT, 2)
      self.indexTermConfiguration.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TIndexingPolicy:
  """
  Attributes:
   - fieldMode
   - fields
   - fieldTermConfigurations
   - compositeIndexes
   - createValueOnlyIndices
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'fieldMode', None, None, ), # 1
    (2, TType.SET, 'fields', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'fieldTermConfigurations', (TType.STRUCT,(TFieldTypeIndexTermConfigurationPair, TFieldTypeIndexTermConfigurationPair.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'compositeIndexes', (TType.LIST,(TType.STRUCT,(TFieldTypePair, TFieldTypePair.thrift_spec))), None, ), # 4
    (5, TType.BOOL, 'createValueOnlyIndices', None, None, ), # 5
  )

  def __init__(self, fieldMode=None, fields=None, fieldTermConfigurations=None, compositeIndexes=None, createValueOnlyIndices=None,):
    self.fieldMode = fieldMode
    self.fields = fields
    self.fieldTermConfigurations = fieldTermConfigurations
    self.compositeIndexes = compositeIndexes
    self.createValueOnlyIndices = createValueOnlyIndices

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.fieldMode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.fields = set()
          (_etype30, _size27) = iprot.readSetBegin()
          for _i31 in xrange(_size27):
            _elem32 = iprot.readString();
            self.fields.add(_elem32)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.fieldTermConfigurations = []
          (_etype36, _size33) = iprot.readListBegin()
          for _i37 in xrange(_size33):
            _elem38 = TFieldTypeIndexTermConfigurationPair()
            _elem38.read(iprot)
            self.fieldTermConfigurations.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.compositeIndexes = []
          (_etype42, _size39) = iprot.readListBegin()
          for _i43 in xrange(_size39):
            _elem44 = []
            (_etype48, _size45) = iprot.readListBegin()
            for _i49 in xrange(_size45):
              _elem50 = TFieldTypePair()
              _elem50.read(iprot)
              _elem44.append(_elem50)
            iprot.readListEnd()
            self.compositeIndexes.append(_elem44)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.createValueOnlyIndices = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TIndexingPolicy')
    if self.fieldMode is not None:
      oprot.writeFieldBegin('fieldMode', TType.I32, 1)
      oprot.writeI32(self.fieldMode)
      oprot.writeFieldEnd()
    if self.fields is not None:
      oprot.writeFieldBegin('fields', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.fields))
      for iter51 in self.fields:
        oprot.writeString(iter51)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.fieldTermConfigurations is not None:
      oprot.writeFieldBegin('fieldTermConfigurations', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.fieldTermConfigurations))
      for iter52 in self.fieldTermConfigurations:
        iter52.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.compositeIndexes is not None:
      oprot.writeFieldBegin('compositeIndexes', TType.LIST, 4)
      oprot.writeListBegin(TType.LIST, len(self.compositeIndexes))
      for iter53 in self.compositeIndexes:
        oprot.writeListBegin(TType.STRUCT, len(iter53))
        for iter54 in iter53:
          iter54.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.createValueOnlyIndices is not None:
      oprot.writeFieldBegin('createValueOnlyIndices', TType.BOOL, 5)
      oprot.writeBool(self.createValueOnlyIndices)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TIndexTermTransformerDescriptor:
  """
  Attributes:
   - inputParameters
   - name
   - fieldTypes
   - implementingClassName
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'inputParameters', (TType.STRUCT,(koverse.thriftgen.ttypes.TParameter, koverse.thriftgen.ttypes.TParameter.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.SET, 'fieldTypes', (TType.STRING,None), None, ), # 3
    (4, TType.STRING, 'implementingClassName', None, None, ), # 4
  )

  def __init__(self, inputParameters=None, name=None, fieldTypes=None, implementingClassName=None,):
    self.inputParameters = inputParameters
    self.name = name
    self.fieldTypes = fieldTypes
    self.implementingClassName = implementingClassName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.inputParameters = []
          (_etype58, _size55) = iprot.readListBegin()
          for _i59 in xrange(_size55):
            _elem60 = koverse.thriftgen.ttypes.TParameter()
            _elem60.read(iprot)
            self.inputParameters.append(_elem60)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.fieldTypes = set()
          (_etype64, _size61) = iprot.readSetBegin()
          for _i65 in xrange(_size61):
            _elem66 = iprot.readString();
            self.fieldTypes.add(_elem66)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.implementingClassName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TIndexTermTransformerDescriptor')
    if self.inputParameters is not None:
      oprot.writeFieldBegin('inputParameters', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.inputParameters))
      for iter67 in self.inputParameters:
        iter67.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.fieldTypes is not None:
      oprot.writeFieldBegin('fieldTypes', TType.SET, 3)
      oprot.writeSetBegin(TType.STRING, len(self.fieldTypes))
      for iter68 in self.fieldTypes:
        oprot.writeString(iter68)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.implementingClassName is not None:
      oprot.writeFieldBegin('implementingClassName', TType.STRING, 4)
      oprot.writeString(self.implementingClassName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCollectionStatus:
  """
  Attributes:
   - id
   - creationTimestamp
   - recordCount
   - interval
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.I64, 'creationTimestamp', None, None, ), # 2
    (3, TType.I64, 'recordCount', None, None, ), # 3
    (4, TType.I64, 'interval', None, None, ), # 4
    (5, TType.STRING, 'collectionId', None, None, ), # 5
  )

  def __init__(self, id=None, creationTimestamp=None, recordCount=None, interval=None, collectionId=None,):
    self.id = id
    self.creationTimestamp = creationTimestamp
    self.recordCount = recordCount
    self.interval = interval
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.creationTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.recordCount = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.interval = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCollectionStatus')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.creationTimestamp is not None:
      oprot.writeFieldBegin('creationTimestamp', TType.I64, 2)
      oprot.writeI64(self.creationTimestamp)
      oprot.writeFieldEnd()
    if self.recordCount is not None:
      oprot.writeFieldBegin('recordCount', TType.I64, 3)
      oprot.writeI64(self.recordCount)
      oprot.writeFieldEnd()
    if self.interval is not None:
      oprot.writeFieldBegin('interval', TType.I64, 4)
      oprot.writeI64(self.interval)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 5)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCollectionProvenance:
  """
  Attributes:
   - otherCollectionId
   - numberOfTransformSteps
   - transformJobIds
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'otherCollectionId', None, None, ), # 1
    (2, TType.I64, 'numberOfTransformSteps', None, None, ), # 2
    (3, TType.LIST, 'transformJobIds', (TType.I64,None), None, ), # 3
  )

  def __init__(self, otherCollectionId=None, numberOfTransformSteps=None, transformJobIds=None,):
    self.otherCollectionId = otherCollectionId
    self.numberOfTransformSteps = numberOfTransformSteps
    self.transformJobIds = transformJobIds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.otherCollectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.numberOfTransformSteps = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.transformJobIds = []
          (_etype72, _size69) = iprot.readListBegin()
          for _i73 in xrange(_size69):
            _elem74 = iprot.readI64();
            self.transformJobIds.append(_elem74)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCollectionProvenance')
    if self.otherCollectionId is not None:
      oprot.writeFieldBegin('otherCollectionId', TType.STRING, 1)
      oprot.writeString(self.otherCollectionId)
      oprot.writeFieldEnd()
    if self.numberOfTransformSteps is not None:
      oprot.writeFieldBegin('numberOfTransformSteps', TType.I64, 2)
      oprot.writeI64(self.numberOfTransformSteps)
      oprot.writeFieldEnd()
    if self.transformJobIds is not None:
      oprot.writeFieldBegin('transformJobIds', TType.LIST, 3)
      oprot.writeListBegin(TType.I64, len(self.transformJobIds))
      for iter75 in self.transformJobIds:
        oprot.writeI64(iter75)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TFieldStatistics:
  """
  Attributes:
   - collectionId
   - fieldName
   - typeHistogram
   - lengthsHistogram
   - recordCount
   - cardinalityEstimate
   - top40
   - heatmap
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'collectionId', None, None, ), # 1
    (2, TType.STRING, 'fieldName', None, None, ), # 2
    (3, TType.MAP, 'typeHistogram', (TType.STRING,None,TType.I64,None), None, ), # 3
    (4, TType.MAP, 'lengthsHistogram', (TType.I32,None,TType.I64,None), None, ), # 4
    (5, TType.I64, 'recordCount', None, None, ), # 5
    (6, TType.DOUBLE, 'cardinalityEstimate', None, None, ), # 6
    (7, TType.MAP, 'top40', (TType.STRING,None,TType.I32,None), None, ), # 7
    (8, TType.LIST, 'heatmap', (TType.I32,None), None, ), # 8
  )

  def __init__(self, collectionId=None, fieldName=None, typeHistogram=None, lengthsHistogram=None, recordCount=None, cardinalityEstimate=None, top40=None, heatmap=None,):
    self.collectionId = collectionId
    self.fieldName = fieldName
    self.typeHistogram = typeHistogram
    self.lengthsHistogram = lengthsHistogram
    self.recordCount = recordCount
    self.cardinalityEstimate = cardinalityEstimate
    self.top40 = top40
    self.heatmap = heatmap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.fieldName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.typeHistogram = {}
          (_ktype77, _vtype78, _size76 ) = iprot.readMapBegin()
          for _i80 in xrange(_size76):
            _key81 = iprot.readString();
            _val82 = iprot.readI64();
            self.typeHistogram[_key81] = _val82
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.lengthsHistogram = {}
          (_ktype84, _vtype85, _size83 ) = iprot.readMapBegin()
          for _i87 in xrange(_size83):
            _key88 = iprot.readI32();
            _val89 = iprot.readI64();
            self.lengthsHistogram[_key88] = _val89
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.recordCount = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.DOUBLE:
          self.cardinalityEstimate = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.top40 = {}
          (_ktype91, _vtype92, _size90 ) = iprot.readMapBegin()
          for _i94 in xrange(_size90):
            _key95 = iprot.readString();
            _val96 = iprot.readI32();
            self.top40[_key95] = _val96
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.heatmap = []
          (_etype100, _size97) = iprot.readListBegin()
          for _i101 in xrange(_size97):
            _elem102 = iprot.readI32();
            self.heatmap.append(_elem102)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TFieldStatistics')
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 1)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    if self.fieldName is not None:
      oprot.writeFieldBegin('fieldName', TType.STRING, 2)
      oprot.writeString(self.fieldName)
      oprot.writeFieldEnd()
    if self.typeHistogram is not None:
      oprot.writeFieldBegin('typeHistogram', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.typeHistogram))
      for kiter103,viter104 in self.typeHistogram.items():
        oprot.writeString(kiter103)
        oprot.writeI64(viter104)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.lengthsHistogram is not None:
      oprot.writeFieldBegin('lengthsHistogram', TType.MAP, 4)
      oprot.writeMapBegin(TType.I32, TType.I64, len(self.lengthsHistogram))
      for kiter105,viter106 in self.lengthsHistogram.items():
        oprot.writeI32(kiter105)
        oprot.writeI64(viter106)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.recordCount is not None:
      oprot.writeFieldBegin('recordCount', TType.I64, 5)
      oprot.writeI64(self.recordCount)
      oprot.writeFieldEnd()
    if self.cardinalityEstimate is not None:
      oprot.writeFieldBegin('cardinalityEstimate', TType.DOUBLE, 6)
      oprot.writeDouble(self.cardinalityEstimate)
      oprot.writeFieldEnd()
    if self.top40 is not None:
      oprot.writeFieldBegin('top40', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.top40))
      for kiter107,viter108 in self.top40.items():
        oprot.writeString(kiter107)
        oprot.writeI32(viter108)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.heatmap is not None:
      oprot.writeFieldBegin('heatmap', TType.LIST, 8)
      oprot.writeListBegin(TType.I32, len(self.heatmap))
      for iter109 in self.heatmap:
        oprot.writeI32(iter109)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCollectionStatistics:
  """
  Attributes:
   - fieldStatistics
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'fieldStatistics', (TType.STRUCT,(TFieldStatistics, TFieldStatistics.thrift_spec)), None, ), # 1
  )

  def __init__(self, fieldStatistics=None,):
    self.fieldStatistics = fieldStatistics

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fieldStatistics = []
          (_etype113, _size110) = iprot.readListBegin()
          for _i114 in xrange(_size110):
            _elem115 = TFieldStatistics()
            _elem115.read(iprot)
            self.fieldStatistics.append(_elem115)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCollectionStatistics')
    if self.fieldStatistics is not None:
      oprot.writeFieldBegin('fieldStatistics', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.fieldStatistics))
      for iter116 in self.fieldStatistics:
        iter116.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDownloadRecords:
  """
  Attributes:
   - downloadId
   - hasMore
   - records
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'downloadId', None, None, ), # 1
    (2, TType.BOOL, 'hasMore', None, None, ), # 2
    (3, TType.LIST, 'records', (TType.STRUCT,(koverse.thriftgen.ttypes.TSimpleRecord, koverse.thriftgen.ttypes.TSimpleRecord.thrift_spec)), None, ), # 3
  )

  def __init__(self, downloadId=None, hasMore=None, records=None,):
    self.downloadId = downloadId
    self.hasMore = hasMore
    self.records = records

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.downloadId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.hasMore = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.records = []
          (_etype120, _size117) = iprot.readListBegin()
          for _i121 in xrange(_size117):
            _elem122 = koverse.thriftgen.ttypes.TSimpleRecord()
            _elem122.read(iprot)
            self.records.append(_elem122)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDownloadRecords')
    if self.downloadId is not None:
      oprot.writeFieldBegin('downloadId', TType.STRING, 1)
      oprot.writeString(self.downloadId)
      oprot.writeFieldEnd()
    if self.hasMore is not None:
      oprot.writeFieldBegin('hasMore', TType.BOOL, 2)
      oprot.writeBool(self.hasMore)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.records))
      for iter123 in self.records:
        iter123.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCollectionGroupPermission:
  """
  Attributes:
   - id
   - group
   - permissions
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.I64, 'group', None, None, ), # 2
    (3, TType.LIST, 'permissions', (TType.STRING,None), None, ), # 3
  )

  def __init__(self, id=None, group=None, permissions=None,):
    self.id = id
    self.group = group
    self.permissions = permissions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.group = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.permissions = []
          (_etype127, _size124) = iprot.readListBegin()
          for _i128 in xrange(_size124):
            _elem129 = iprot.readString();
            self.permissions.append(_elem129)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCollectionGroupPermission')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.group is not None:
      oprot.writeFieldBegin('group', TType.I64, 2)
      oprot.writeI64(self.group)
      oprot.writeFieldEnd()
    if self.permissions is not None:
      oprot.writeFieldBegin('permissions', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.permissions))
      for iter130 in self.permissions:
        oprot.writeString(iter130)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCollection:
  """
  Attributes:
   - id
   - name
   - description
   - indexingPolicy
   - tags
   - responsibleUserId
   - createdTimestamp
   - updatedTimestamp
   - recordCountUpdatedTimestamp
   - recordCount
   - sizeInBytes
   - state
   - groupPermissions
   - provenance
   - hadoopDeleteJobIds
   - version
   - deleted
   - disableFieldStats
   - disableSampling
   - fieldStatsMinimumExecutionPeriod
   - samplingMinimumExecutionPeriod
   - aggregationMinimumExecutionPeriod
   - versionedCollectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'description', None, None, ), # 3
    (4, TType.STRUCT, 'indexingPolicy', (TIndexingPolicy, TIndexingPolicy.thrift_spec), None, ), # 4
    (5, TType.SET, 'tags', (TType.STRING,None), None, ), # 5
    (6, TType.I64, 'responsibleUserId', None, None, ), # 6
    (7, TType.I64, 'createdTimestamp', None, None, ), # 7
    (8, TType.I64, 'updatedTimestamp', None, None, ), # 8
    (9, TType.I64, 'recordCountUpdatedTimestamp', None, None, ), # 9
    (10, TType.I64, 'recordCount', None, None, ), # 10
    (11, TType.I64, 'sizeInBytes', None, None, ), # 11
    (12, TType.I32, 'state', None, None, ), # 12
    (13, TType.LIST, 'groupPermissions', (TType.STRUCT,(TCollectionGroupPermission, TCollectionGroupPermission.thrift_spec)), None, ), # 13
    (14, TType.LIST, 'provenance', (TType.STRUCT,(TCollectionProvenance, TCollectionProvenance.thrift_spec)), None, ), # 14
    (15, TType.LIST, 'hadoopDeleteJobIds', (TType.STRING,None), None, ), # 15
    (16, TType.I64, 'version', None, None, ), # 16
    (17, TType.BOOL, 'deleted', None, None, ), # 17
    (18, TType.BOOL, 'disableFieldStats', None, None, ), # 18
    (19, TType.BOOL, 'disableSampling', None, None, ), # 19
    (20, TType.I64, 'fieldStatsMinimumExecutionPeriod', None, None, ), # 20
    (21, TType.I64, 'samplingMinimumExecutionPeriod', None, None, ), # 21
    (22, TType.I64, 'aggregationMinimumExecutionPeriod', None, None, ), # 22
    (23, TType.STRING, 'versionedCollectionId', None, None, ), # 23
  )

  def __init__(self, id=None, name=None, description=None, indexingPolicy=None, tags=None, responsibleUserId=None, createdTimestamp=None, updatedTimestamp=None, recordCountUpdatedTimestamp=None, recordCount=None, sizeInBytes=None, state=None, groupPermissions=None, provenance=None, hadoopDeleteJobIds=None, version=None, deleted=None, disableFieldStats=None, disableSampling=None, fieldStatsMinimumExecutionPeriod=None, samplingMinimumExecutionPeriod=None, aggregationMinimumExecutionPeriod=None, versionedCollectionId=None,):
    self.id = id
    self.name = name
    self.description = description
    self.indexingPolicy = indexingPolicy
    self.tags = tags
    self.responsibleUserId = responsibleUserId
    self.createdTimestamp = createdTimestamp
    self.updatedTimestamp = updatedTimestamp
    self.recordCountUpdatedTimestamp = recordCountUpdatedTimestamp
    self.recordCount = recordCount
    self.sizeInBytes = sizeInBytes
    self.state = state
    self.groupPermissions = groupPermissions
    self.provenance = provenance
    self.hadoopDeleteJobIds = hadoopDeleteJobIds
    self.version = version
    self.deleted = deleted
    self.disableFieldStats = disableFieldStats
    self.disableSampling = disableSampling
    self.fieldStatsMinimumExecutionPeriod = fieldStatsMinimumExecutionPeriod
    self.samplingMinimumExecutionPeriod = samplingMinimumExecutionPeriod
    self.aggregationMinimumExecutionPeriod = aggregationMinimumExecutionPeriod
    self.versionedCollectionId = versionedCollectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.description = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.indexingPolicy = TIndexingPolicy()
          self.indexingPolicy.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.SET:
          self.tags = set()
          (_etype134, _size131) = iprot.readSetBegin()
          for _i135 in xrange(_size131):
            _elem136 = iprot.readString();
            self.tags.add(_elem136)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.responsibleUserId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.createdTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.updatedTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.recordCountUpdatedTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.recordCount = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.sizeInBytes = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I32:
          self.state = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.LIST:
          self.groupPermissions = []
          (_etype140, _size137) = iprot.readListBegin()
          for _i141 in xrange(_size137):
            _elem142 = TCollectionGroupPermission()
            _elem142.read(iprot)
            self.groupPermissions.append(_elem142)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.LIST:
          self.provenance = []
          (_etype146, _size143) = iprot.readListBegin()
          for _i147 in xrange(_size143):
            _elem148 = TCollectionProvenance()
            _elem148.read(iprot)
            self.provenance.append(_elem148)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.LIST:
          self.hadoopDeleteJobIds = []
          (_etype152, _size149) = iprot.readListBegin()
          for _i153 in xrange(_size149):
            _elem154 = iprot.readString();
            self.hadoopDeleteJobIds.append(_elem154)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I64:
          self.version = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.BOOL:
          self.deleted = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.BOOL:
          self.disableFieldStats = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.BOOL:
          self.disableSampling = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.I64:
          self.fieldStatsMinimumExecutionPeriod = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.I64:
          self.samplingMinimumExecutionPeriod = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.I64:
          self.aggregationMinimumExecutionPeriod = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRING:
          self.versionedCollectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCollection')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.description is not None:
      oprot.writeFieldBegin('description', TType.STRING, 3)
      oprot.writeString(self.description)
      oprot.writeFieldEnd()
    if self.indexingPolicy is not None:
      oprot.writeFieldBegin('indexingPolicy', TType.STRUCT, 4)
      self.indexingPolicy.write(oprot)
      oprot.writeFieldEnd()
    if self.tags is not None:
      oprot.writeFieldBegin('tags', TType.SET, 5)
      oprot.writeSetBegin(TType.STRING, len(self.tags))
      for iter155 in self.tags:
        oprot.writeString(iter155)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.responsibleUserId is not None:
      oprot.writeFieldBegin('responsibleUserId', TType.I64, 6)
      oprot.writeI64(self.responsibleUserId)
      oprot.writeFieldEnd()
    if self.createdTimestamp is not None:
      oprot.writeFieldBegin('createdTimestamp', TType.I64, 7)
      oprot.writeI64(self.createdTimestamp)
      oprot.writeFieldEnd()
    if self.updatedTimestamp is not None:
      oprot.writeFieldBegin('updatedTimestamp', TType.I64, 8)
      oprot.writeI64(self.updatedTimestamp)
      oprot.writeFieldEnd()
    if self.recordCountUpdatedTimestamp is not None:
      oprot.writeFieldBegin('recordCountUpdatedTimestamp', TType.I64, 9)
      oprot.writeI64(self.recordCountUpdatedTimestamp)
      oprot.writeFieldEnd()
    if self.recordCount is not None:
      oprot.writeFieldBegin('recordCount', TType.I64, 10)
      oprot.writeI64(self.recordCount)
      oprot.writeFieldEnd()
    if self.sizeInBytes is not None:
      oprot.writeFieldBegin('sizeInBytes', TType.I64, 11)
      oprot.writeI64(self.sizeInBytes)
      oprot.writeFieldEnd()
    if self.state is not None:
      oprot.writeFieldBegin('state', TType.I32, 12)
      oprot.writeI32(self.state)
      oprot.writeFieldEnd()
    if self.groupPermissions is not None:
      oprot.writeFieldBegin('groupPermissions', TType.LIST, 13)
      oprot.writeListBegin(TType.STRUCT, len(self.groupPermissions))
      for iter156 in self.groupPermissions:
        iter156.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.provenance is not None:
      oprot.writeFieldBegin('provenance', TType.LIST, 14)
      oprot.writeListBegin(TType.STRUCT, len(self.provenance))
      for iter157 in self.provenance:
        iter157.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.hadoopDeleteJobIds is not None:
      oprot.writeFieldBegin('hadoopDeleteJobIds', TType.LIST, 15)
      oprot.writeListBegin(TType.STRING, len(self.hadoopDeleteJobIds))
      for iter158 in self.hadoopDeleteJobIds:
        oprot.writeString(iter158)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I64, 16)
      oprot.writeI64(self.version)
      oprot.writeFieldEnd()
    if self.deleted is not None:
      oprot.writeFieldBegin('deleted', TType.BOOL, 17)
      oprot.writeBool(self.deleted)
      oprot.writeFieldEnd()
    if self.disableFieldStats is not None:
      oprot.writeFieldBegin('disableFieldStats', TType.BOOL, 18)
      oprot.writeBool(self.disableFieldStats)
      oprot.writeFieldEnd()
    if self.disableSampling is not None:
      oprot.writeFieldBegin('disableSampling', TType.BOOL, 19)
      oprot.writeBool(self.disableSampling)
      oprot.writeFieldEnd()
    if self.fieldStatsMinimumExecutionPeriod is not None:
      oprot.writeFieldBegin('fieldStatsMinimumExecutionPeriod', TType.I64, 20)
      oprot.writeI64(self.fieldStatsMinimumExecutionPeriod)
      oprot.writeFieldEnd()
    if self.samplingMinimumExecutionPeriod is not None:
      oprot.writeFieldBegin('samplingMinimumExecutionPeriod', TType.I64, 21)
      oprot.writeI64(self.samplingMinimumExecutionPeriod)
      oprot.writeFieldEnd()
    if self.aggregationMinimumExecutionPeriod is not None:
      oprot.writeFieldBegin('aggregationMinimumExecutionPeriod', TType.I64, 22)
      oprot.writeI64(self.aggregationMinimumExecutionPeriod)
      oprot.writeFieldEnd()
    if self.versionedCollectionId is not None:
      oprot.writeFieldBegin('versionedCollectionId', TType.STRING, 23)
      oprot.writeString(self.versionedCollectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
