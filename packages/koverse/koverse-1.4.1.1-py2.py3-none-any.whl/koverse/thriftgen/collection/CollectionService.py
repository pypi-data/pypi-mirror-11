#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def getCollectionById(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    pass

  def getCollectionByName(self, auth, collectionName):
    """
    Parameters:
     - auth
     - collectionName
    """
    pass

  def listCollections(self, auth):
    """
    Parameters:
     - auth
    """
    pass

  def listCollectionsWithPermission(self, auth, permission):
    """
    Parameters:
     - auth
     - permission
    """
    pass

  def listCollectionPermissionTypes(self):
    pass

  def createCollection(self, auth, collection):
    """
    Parameters:
     - auth
     - collection
    """
    pass

  def updateCollection(self, auth, collection):
    """
    Parameters:
     - auth
     - collection
    """
    pass

  def deleteCollection(self, auth, collection):
    """
    Parameters:
     - auth
     - collection
    """
    pass

  def clearCollection(self, auth, collection):
    """
    Parameters:
     - auth
     - collection
    """
    pass

  def getCollectionStatus(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    pass

  def getCollectionSample(self, auth, collectionId, maxRecords):
    """
    Parameters:
     - auth
     - collectionId
     - maxRecords
    """
    pass

  def getCollectionHistoricalStatus(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    pass

  def getAllFieldStatistics(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    pass

  def getFieldStatistics(self, auth, collectionId, field):
    """
    Parameters:
     - auth
     - collectionId
     - field
    """
    pass

  def getIndexTermTransformerDescriptors(self, auth):
    """
    Parameters:
     - auth
    """
    pass

  def repair(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    pass

  def insert(self, auth, records):
    """
    Parameters:
     - auth
     - records
    """
    pass

  def incrementRecordCount(self, auth, collectionId, count):
    """
    Parameters:
     - auth
     - collectionId
     - count
    """
    pass

  def setRecordCount(self, auth, collectionId, count):
    """
    Parameters:
     - auth
     - collectionId
     - count
    """
    pass

  def getDataCollectionPermissionsForAuthorizationBearer(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    pass

  def startDownloadRecords(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    pass

  def downloadMoreRecords(self, auth, downloadId, maxToReturn):
    """
    Parameters:
     - auth
     - downloadId
     - maxToReturn
    """
    pass

  def stopDownloadRecords(self, auth, downloadId):
    """
    Parameters:
     - auth
     - downloadId
    """
    pass

  def listAllCollectionsThriftException(self, auth):
    """
    Parameters:
     - auth
    """
    pass

  def startDownloadSamples(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    pass

  def downloadMoreSamples(self, auth, downloadId, maxToReturn):
    """
    Parameters:
     - auth
     - downloadId
     - maxToReturn
    """
    pass

  def stopDownloadSamples(self, auth, downloadId):
    """
    Parameters:
     - auth
     - downloadId
    """
    pass

  def listAllCollectionsServiceException(self, auth):
    """
    Parameters:
     - auth
    """
    pass

  def listAllCollectionsPersistenceException(self, auth):
    """
    Parameters:
     - auth
    """
    pass

  def getAllFieldDetails(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    pass

  def getFieldDetails(self, auth, collectionId, field):
    """
    Parameters:
     - auth
     - collectionId
     - field
    """
    pass

  def createAggregate(self, auth, aggregate):
    """
    Parameters:
     - auth
     - aggregate
    """
    pass

  def deleteAggregate(self, auth, collectionId, id):
    """
    Parameters:
     - auth
     - collectionId
     - id
    """
    pass

  def getAggregate(self, auth, id):
    """
    Parameters:
     - auth
     - id
    """
    pass

  def getCollectionAggregates(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    pass

  def getSparkRDDConf(self, auth, collectionName):
    """
    Parameters:
     - auth
     - collectionName
    """
    pass

  def getNewSparkJobOutputPath(self, auth):
    """
    Parameters:
     - auth
    """
    pass

  def addSparkFilesToCollection(self, auth, collectionName, path):
    """
    Parameters:
     - auth
     - collectionName
     - path
    """
    pass

  def cleanupSparkImportDir(self, auth, importId):
    """
    Parameters:
     - auth
     - importId
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def getCollectionById(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    self.send_getCollectionById(auth, collectionId)
    return self.recv_getCollectionById()

  def send_getCollectionById(self, auth, collectionId):
    self._oprot.writeMessageBegin('getCollectionById', TMessageType.CALL, self._seqid)
    args = getCollectionById_args()
    args.auth = auth
    args.collectionId = collectionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCollectionById(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getCollectionById_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.nfe is not None:
      raise result.nfe
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionById failed: unknown result");

  def getCollectionByName(self, auth, collectionName):
    """
    Parameters:
     - auth
     - collectionName
    """
    self.send_getCollectionByName(auth, collectionName)
    return self.recv_getCollectionByName()

  def send_getCollectionByName(self, auth, collectionName):
    self._oprot.writeMessageBegin('getCollectionByName', TMessageType.CALL, self._seqid)
    args = getCollectionByName_args()
    args.auth = auth
    args.collectionName = collectionName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCollectionByName(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getCollectionByName_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.nfe is not None:
      raise result.nfe
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionByName failed: unknown result");

  def listCollections(self, auth):
    """
    Parameters:
     - auth
    """
    self.send_listCollections(auth)
    return self.recv_listCollections()

  def send_listCollections(self, auth):
    self._oprot.writeMessageBegin('listCollections', TMessageType.CALL, self._seqid)
    args = listCollections_args()
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listCollections(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listCollections_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listCollections failed: unknown result");

  def listCollectionsWithPermission(self, auth, permission):
    """
    Parameters:
     - auth
     - permission
    """
    self.send_listCollectionsWithPermission(auth, permission)
    return self.recv_listCollectionsWithPermission()

  def send_listCollectionsWithPermission(self, auth, permission):
    self._oprot.writeMessageBegin('listCollectionsWithPermission', TMessageType.CALL, self._seqid)
    args = listCollectionsWithPermission_args()
    args.auth = auth
    args.permission = permission
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listCollectionsWithPermission(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listCollectionsWithPermission_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listCollectionsWithPermission failed: unknown result");

  def listCollectionPermissionTypes(self):
    self.send_listCollectionPermissionTypes()
    return self.recv_listCollectionPermissionTypes()

  def send_listCollectionPermissionTypes(self):
    self._oprot.writeMessageBegin('listCollectionPermissionTypes', TMessageType.CALL, self._seqid)
    args = listCollectionPermissionTypes_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listCollectionPermissionTypes(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listCollectionPermissionTypes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listCollectionPermissionTypes failed: unknown result");

  def createCollection(self, auth, collection):
    """
    Parameters:
     - auth
     - collection
    """
    self.send_createCollection(auth, collection)
    return self.recv_createCollection()

  def send_createCollection(self, auth, collection):
    self._oprot.writeMessageBegin('createCollection', TMessageType.CALL, self._seqid)
    args = createCollection_args()
    args.auth = auth
    args.collection = collection
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createCollection(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createCollection_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "createCollection failed: unknown result");

  def updateCollection(self, auth, collection):
    """
    Parameters:
     - auth
     - collection
    """
    self.send_updateCollection(auth, collection)
    return self.recv_updateCollection()

  def send_updateCollection(self, auth, collection):
    self._oprot.writeMessageBegin('updateCollection', TMessageType.CALL, self._seqid)
    args = updateCollection_args()
    args.auth = auth
    args.collection = collection
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_updateCollection(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = updateCollection_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "updateCollection failed: unknown result");

  def deleteCollection(self, auth, collection):
    """
    Parameters:
     - auth
     - collection
    """
    self.send_deleteCollection(auth, collection)
    return self.recv_deleteCollection()

  def send_deleteCollection(self, auth, collection):
    self._oprot.writeMessageBegin('deleteCollection', TMessageType.CALL, self._seqid)
    args = deleteCollection_args()
    args.auth = auth
    args.collection = collection
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteCollection(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteCollection_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteCollection failed: unknown result");

  def clearCollection(self, auth, collection):
    """
    Parameters:
     - auth
     - collection
    """
    self.send_clearCollection(auth, collection)
    self.recv_clearCollection()

  def send_clearCollection(self, auth, collection):
    self._oprot.writeMessageBegin('clearCollection', TMessageType.CALL, self._seqid)
    args = clearCollection_args()
    args.auth = auth
    args.collection = collection
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clearCollection(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = clearCollection_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def getCollectionStatus(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    self.send_getCollectionStatus(auth, collectionId)
    return self.recv_getCollectionStatus()

  def send_getCollectionStatus(self, auth, collectionId):
    self._oprot.writeMessageBegin('getCollectionStatus', TMessageType.CALL, self._seqid)
    args = getCollectionStatus_args()
    args.auth = auth
    args.collectionId = collectionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCollectionStatus(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getCollectionStatus_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ae is not None:
      raise result.ae
    if result.ke is not None:
      raise result.ke
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionStatus failed: unknown result");

  def getCollectionSample(self, auth, collectionId, maxRecords):
    """
    Parameters:
     - auth
     - collectionId
     - maxRecords
    """
    self.send_getCollectionSample(auth, collectionId, maxRecords)
    return self.recv_getCollectionSample()

  def send_getCollectionSample(self, auth, collectionId, maxRecords):
    self._oprot.writeMessageBegin('getCollectionSample', TMessageType.CALL, self._seqid)
    args = getCollectionSample_args()
    args.auth = auth
    args.collectionId = collectionId
    args.maxRecords = maxRecords
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCollectionSample(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getCollectionSample_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ae is not None:
      raise result.ae
    if result.ke is not None:
      raise result.ke
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionSample failed: unknown result");

  def getCollectionHistoricalStatus(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    self.send_getCollectionHistoricalStatus(auth, collectionId)
    return self.recv_getCollectionHistoricalStatus()

  def send_getCollectionHistoricalStatus(self, auth, collectionId):
    self._oprot.writeMessageBegin('getCollectionHistoricalStatus', TMessageType.CALL, self._seqid)
    args = getCollectionHistoricalStatus_args()
    args.auth = auth
    args.collectionId = collectionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCollectionHistoricalStatus(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getCollectionHistoricalStatus_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionHistoricalStatus failed: unknown result");

  def getAllFieldStatistics(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    self.send_getAllFieldStatistics(auth, collectionId)
    return self.recv_getAllFieldStatistics()

  def send_getAllFieldStatistics(self, auth, collectionId):
    self._oprot.writeMessageBegin('getAllFieldStatistics', TMessageType.CALL, self._seqid)
    args = getAllFieldStatistics_args()
    args.auth = auth
    args.collectionId = collectionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAllFieldStatistics(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAllFieldStatistics_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllFieldStatistics failed: unknown result");

  def getFieldStatistics(self, auth, collectionId, field):
    """
    Parameters:
     - auth
     - collectionId
     - field
    """
    self.send_getFieldStatistics(auth, collectionId, field)
    return self.recv_getFieldStatistics()

  def send_getFieldStatistics(self, auth, collectionId, field):
    self._oprot.writeMessageBegin('getFieldStatistics', TMessageType.CALL, self._seqid)
    args = getFieldStatistics_args()
    args.auth = auth
    args.collectionId = collectionId
    args.field = field
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getFieldStatistics(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getFieldStatistics_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getFieldStatistics failed: unknown result");

  def getIndexTermTransformerDescriptors(self, auth):
    """
    Parameters:
     - auth
    """
    self.send_getIndexTermTransformerDescriptors(auth)
    return self.recv_getIndexTermTransformerDescriptors()

  def send_getIndexTermTransformerDescriptors(self, auth):
    self._oprot.writeMessageBegin('getIndexTermTransformerDescriptors', TMessageType.CALL, self._seqid)
    args = getIndexTermTransformerDescriptors_args()
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getIndexTermTransformerDescriptors(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getIndexTermTransformerDescriptors_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getIndexTermTransformerDescriptors failed: unknown result");

  def repair(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    self.send_repair(auth, collectionId)
    self.recv_repair()

  def send_repair(self, auth, collectionId):
    self._oprot.writeMessageBegin('repair', TMessageType.CALL, self._seqid)
    args = repair_args()
    args.auth = auth
    args.collectionId = collectionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_repair(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = repair_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def insert(self, auth, records):
    """
    Parameters:
     - auth
     - records
    """
    self.send_insert(auth, records)
    return self.recv_insert()

  def send_insert(self, auth, records):
    self._oprot.writeMessageBegin('insert', TMessageType.CALL, self._seqid)
    args = insert_args()
    args.auth = auth
    args.records = records
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_insert(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = insert_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "insert failed: unknown result");

  def incrementRecordCount(self, auth, collectionId, count):
    """
    Parameters:
     - auth
     - collectionId
     - count
    """
    self.send_incrementRecordCount(auth, collectionId, count)
    self.recv_incrementRecordCount()

  def send_incrementRecordCount(self, auth, collectionId, count):
    self._oprot.writeMessageBegin('incrementRecordCount', TMessageType.CALL, self._seqid)
    args = incrementRecordCount_args()
    args.auth = auth
    args.collectionId = collectionId
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_incrementRecordCount(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = incrementRecordCount_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def setRecordCount(self, auth, collectionId, count):
    """
    Parameters:
     - auth
     - collectionId
     - count
    """
    self.send_setRecordCount(auth, collectionId, count)
    self.recv_setRecordCount()

  def send_setRecordCount(self, auth, collectionId, count):
    self._oprot.writeMessageBegin('setRecordCount', TMessageType.CALL, self._seqid)
    args = setRecordCount_args()
    args.auth = auth
    args.collectionId = collectionId
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setRecordCount(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setRecordCount_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def getDataCollectionPermissionsForAuthorizationBearer(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    self.send_getDataCollectionPermissionsForAuthorizationBearer(auth, collectionId)
    return self.recv_getDataCollectionPermissionsForAuthorizationBearer()

  def send_getDataCollectionPermissionsForAuthorizationBearer(self, auth, collectionId):
    self._oprot.writeMessageBegin('getDataCollectionPermissionsForAuthorizationBearer', TMessageType.CALL, self._seqid)
    args = getDataCollectionPermissionsForAuthorizationBearer_args()
    args.auth = auth
    args.collectionId = collectionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getDataCollectionPermissionsForAuthorizationBearer(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getDataCollectionPermissionsForAuthorizationBearer_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getDataCollectionPermissionsForAuthorizationBearer failed: unknown result");

  def startDownloadRecords(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    self.send_startDownloadRecords(auth, collectionId)
    return self.recv_startDownloadRecords()

  def send_startDownloadRecords(self, auth, collectionId):
    self._oprot.writeMessageBegin('startDownloadRecords', TMessageType.CALL, self._seqid)
    args = startDownloadRecords_args()
    args.auth = auth
    args.collectionId = collectionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startDownloadRecords(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = startDownloadRecords_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startDownloadRecords failed: unknown result");

  def downloadMoreRecords(self, auth, downloadId, maxToReturn):
    """
    Parameters:
     - auth
     - downloadId
     - maxToReturn
    """
    self.send_downloadMoreRecords(auth, downloadId, maxToReturn)
    return self.recv_downloadMoreRecords()

  def send_downloadMoreRecords(self, auth, downloadId, maxToReturn):
    self._oprot.writeMessageBegin('downloadMoreRecords', TMessageType.CALL, self._seqid)
    args = downloadMoreRecords_args()
    args.auth = auth
    args.downloadId = downloadId
    args.maxToReturn = maxToReturn
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_downloadMoreRecords(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = downloadMoreRecords_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "downloadMoreRecords failed: unknown result");

  def stopDownloadRecords(self, auth, downloadId):
    """
    Parameters:
     - auth
     - downloadId
    """
    self.send_stopDownloadRecords(auth, downloadId)
    self.recv_stopDownloadRecords()

  def send_stopDownloadRecords(self, auth, downloadId):
    self._oprot.writeMessageBegin('stopDownloadRecords', TMessageType.CALL, self._seqid)
    args = stopDownloadRecords_args()
    args.auth = auth
    args.downloadId = downloadId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stopDownloadRecords(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = stopDownloadRecords_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def listAllCollectionsThriftException(self, auth):
    """
    Parameters:
     - auth
    """
    self.send_listAllCollectionsThriftException(auth)
    return self.recv_listAllCollectionsThriftException()

  def send_listAllCollectionsThriftException(self, auth):
    self._oprot.writeMessageBegin('listAllCollectionsThriftException', TMessageType.CALL, self._seqid)
    args = listAllCollectionsThriftException_args()
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listAllCollectionsThriftException(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listAllCollectionsThriftException_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listAllCollectionsThriftException failed: unknown result");

  def startDownloadSamples(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    self.send_startDownloadSamples(auth, collectionId)
    return self.recv_startDownloadSamples()

  def send_startDownloadSamples(self, auth, collectionId):
    self._oprot.writeMessageBegin('startDownloadSamples', TMessageType.CALL, self._seqid)
    args = startDownloadSamples_args()
    args.auth = auth
    args.collectionId = collectionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startDownloadSamples(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = startDownloadSamples_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startDownloadSamples failed: unknown result");

  def downloadMoreSamples(self, auth, downloadId, maxToReturn):
    """
    Parameters:
     - auth
     - downloadId
     - maxToReturn
    """
    self.send_downloadMoreSamples(auth, downloadId, maxToReturn)
    return self.recv_downloadMoreSamples()

  def send_downloadMoreSamples(self, auth, downloadId, maxToReturn):
    self._oprot.writeMessageBegin('downloadMoreSamples', TMessageType.CALL, self._seqid)
    args = downloadMoreSamples_args()
    args.auth = auth
    args.downloadId = downloadId
    args.maxToReturn = maxToReturn
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_downloadMoreSamples(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = downloadMoreSamples_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "downloadMoreSamples failed: unknown result");

  def stopDownloadSamples(self, auth, downloadId):
    """
    Parameters:
     - auth
     - downloadId
    """
    self.send_stopDownloadSamples(auth, downloadId)
    self.recv_stopDownloadSamples()

  def send_stopDownloadSamples(self, auth, downloadId):
    self._oprot.writeMessageBegin('stopDownloadSamples', TMessageType.CALL, self._seqid)
    args = stopDownloadSamples_args()
    args.auth = auth
    args.downloadId = downloadId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stopDownloadSamples(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = stopDownloadSamples_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def listAllCollectionsServiceException(self, auth):
    """
    Parameters:
     - auth
    """
    self.send_listAllCollectionsServiceException(auth)
    return self.recv_listAllCollectionsServiceException()

  def send_listAllCollectionsServiceException(self, auth):
    self._oprot.writeMessageBegin('listAllCollectionsServiceException', TMessageType.CALL, self._seqid)
    args = listAllCollectionsServiceException_args()
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listAllCollectionsServiceException(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listAllCollectionsServiceException_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listAllCollectionsServiceException failed: unknown result");

  def listAllCollectionsPersistenceException(self, auth):
    """
    Parameters:
     - auth
    """
    self.send_listAllCollectionsPersistenceException(auth)
    return self.recv_listAllCollectionsPersistenceException()

  def send_listAllCollectionsPersistenceException(self, auth):
    self._oprot.writeMessageBegin('listAllCollectionsPersistenceException', TMessageType.CALL, self._seqid)
    args = listAllCollectionsPersistenceException_args()
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_listAllCollectionsPersistenceException(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = listAllCollectionsPersistenceException_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "listAllCollectionsPersistenceException failed: unknown result");

  def getAllFieldDetails(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    self.send_getAllFieldDetails(auth, collectionId)
    return self.recv_getAllFieldDetails()

  def send_getAllFieldDetails(self, auth, collectionId):
    self._oprot.writeMessageBegin('getAllFieldDetails', TMessageType.CALL, self._seqid)
    args = getAllFieldDetails_args()
    args.auth = auth
    args.collectionId = collectionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAllFieldDetails(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAllFieldDetails_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllFieldDetails failed: unknown result");

  def getFieldDetails(self, auth, collectionId, field):
    """
    Parameters:
     - auth
     - collectionId
     - field
    """
    self.send_getFieldDetails(auth, collectionId, field)
    return self.recv_getFieldDetails()

  def send_getFieldDetails(self, auth, collectionId, field):
    self._oprot.writeMessageBegin('getFieldDetails', TMessageType.CALL, self._seqid)
    args = getFieldDetails_args()
    args.auth = auth
    args.collectionId = collectionId
    args.field = field
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getFieldDetails(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getFieldDetails_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getFieldDetails failed: unknown result");

  def createAggregate(self, auth, aggregate):
    """
    Parameters:
     - auth
     - aggregate
    """
    self.send_createAggregate(auth, aggregate)
    self.recv_createAggregate()

  def send_createAggregate(self, auth, aggregate):
    self._oprot.writeMessageBegin('createAggregate', TMessageType.CALL, self._seqid)
    args = createAggregate_args()
    args.auth = auth
    args.aggregate = aggregate
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_createAggregate(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = createAggregate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def deleteAggregate(self, auth, collectionId, id):
    """
    Parameters:
     - auth
     - collectionId
     - id
    """
    self.send_deleteAggregate(auth, collectionId, id)
    self.recv_deleteAggregate()

  def send_deleteAggregate(self, auth, collectionId, id):
    self._oprot.writeMessageBegin('deleteAggregate', TMessageType.CALL, self._seqid)
    args = deleteAggregate_args()
    args.auth = auth
    args.collectionId = collectionId
    args.id = id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteAggregate(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteAggregate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def getAggregate(self, auth, id):
    """
    Parameters:
     - auth
     - id
    """
    self.send_getAggregate(auth, id)
    return self.recv_getAggregate()

  def send_getAggregate(self, auth, id):
    self._oprot.writeMessageBegin('getAggregate', TMessageType.CALL, self._seqid)
    args = getAggregate_args()
    args.auth = auth
    args.id = id
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAggregate(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAggregate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAggregate failed: unknown result");

  def getCollectionAggregates(self, auth, collectionId):
    """
    Parameters:
     - auth
     - collectionId
    """
    self.send_getCollectionAggregates(auth, collectionId)
    return self.recv_getCollectionAggregates()

  def send_getCollectionAggregates(self, auth, collectionId):
    self._oprot.writeMessageBegin('getCollectionAggregates', TMessageType.CALL, self._seqid)
    args = getCollectionAggregates_args()
    args.auth = auth
    args.collectionId = collectionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCollectionAggregates(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getCollectionAggregates_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCollectionAggregates failed: unknown result");

  def getSparkRDDConf(self, auth, collectionName):
    """
    Parameters:
     - auth
     - collectionName
    """
    self.send_getSparkRDDConf(auth, collectionName)
    return self.recv_getSparkRDDConf()

  def send_getSparkRDDConf(self, auth, collectionName):
    self._oprot.writeMessageBegin('getSparkRDDConf', TMessageType.CALL, self._seqid)
    args = getSparkRDDConf_args()
    args.auth = auth
    args.collectionName = collectionName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSparkRDDConf(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSparkRDDConf_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSparkRDDConf failed: unknown result");

  def getNewSparkJobOutputPath(self, auth):
    """
    Parameters:
     - auth
    """
    self.send_getNewSparkJobOutputPath(auth)
    return self.recv_getNewSparkJobOutputPath()

  def send_getNewSparkJobOutputPath(self, auth):
    self._oprot.writeMessageBegin('getNewSparkJobOutputPath', TMessageType.CALL, self._seqid)
    args = getNewSparkJobOutputPath_args()
    args.auth = auth
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getNewSparkJobOutputPath(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getNewSparkJobOutputPath_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getNewSparkJobOutputPath failed: unknown result");

  def addSparkFilesToCollection(self, auth, collectionName, path):
    """
    Parameters:
     - auth
     - collectionName
     - path
    """
    self.send_addSparkFilesToCollection(auth, collectionName, path)
    self.recv_addSparkFilesToCollection()

  def send_addSparkFilesToCollection(self, auth, collectionName, path):
    self._oprot.writeMessageBegin('addSparkFilesToCollection', TMessageType.CALL, self._seqid)
    args = addSparkFilesToCollection_args()
    args.auth = auth
    args.collectionName = collectionName
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addSparkFilesToCollection(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addSparkFilesToCollection_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return

  def cleanupSparkImportDir(self, auth, importId):
    """
    Parameters:
     - auth
     - importId
    """
    self.send_cleanupSparkImportDir(auth, importId)
    self.recv_cleanupSparkImportDir()

  def send_cleanupSparkImportDir(self, auth, importId):
    self._oprot.writeMessageBegin('cleanupSparkImportDir', TMessageType.CALL, self._seqid)
    args = cleanupSparkImportDir_args()
    args.auth = auth
    args.importId = importId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_cleanupSparkImportDir(self):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = cleanupSparkImportDir_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ke is not None:
      raise result.ke
    if result.ae is not None:
      raise result.ae
    if result.ce is not None:
      raise result.ce
    return


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["getCollectionById"] = Processor.process_getCollectionById
    self._processMap["getCollectionByName"] = Processor.process_getCollectionByName
    self._processMap["listCollections"] = Processor.process_listCollections
    self._processMap["listCollectionsWithPermission"] = Processor.process_listCollectionsWithPermission
    self._processMap["listCollectionPermissionTypes"] = Processor.process_listCollectionPermissionTypes
    self._processMap["createCollection"] = Processor.process_createCollection
    self._processMap["updateCollection"] = Processor.process_updateCollection
    self._processMap["deleteCollection"] = Processor.process_deleteCollection
    self._processMap["clearCollection"] = Processor.process_clearCollection
    self._processMap["getCollectionStatus"] = Processor.process_getCollectionStatus
    self._processMap["getCollectionSample"] = Processor.process_getCollectionSample
    self._processMap["getCollectionHistoricalStatus"] = Processor.process_getCollectionHistoricalStatus
    self._processMap["getAllFieldStatistics"] = Processor.process_getAllFieldStatistics
    self._processMap["getFieldStatistics"] = Processor.process_getFieldStatistics
    self._processMap["getIndexTermTransformerDescriptors"] = Processor.process_getIndexTermTransformerDescriptors
    self._processMap["repair"] = Processor.process_repair
    self._processMap["insert"] = Processor.process_insert
    self._processMap["incrementRecordCount"] = Processor.process_incrementRecordCount
    self._processMap["setRecordCount"] = Processor.process_setRecordCount
    self._processMap["getDataCollectionPermissionsForAuthorizationBearer"] = Processor.process_getDataCollectionPermissionsForAuthorizationBearer
    self._processMap["startDownloadRecords"] = Processor.process_startDownloadRecords
    self._processMap["downloadMoreRecords"] = Processor.process_downloadMoreRecords
    self._processMap["stopDownloadRecords"] = Processor.process_stopDownloadRecords
    self._processMap["listAllCollectionsThriftException"] = Processor.process_listAllCollectionsThriftException
    self._processMap["startDownloadSamples"] = Processor.process_startDownloadSamples
    self._processMap["downloadMoreSamples"] = Processor.process_downloadMoreSamples
    self._processMap["stopDownloadSamples"] = Processor.process_stopDownloadSamples
    self._processMap["listAllCollectionsServiceException"] = Processor.process_listAllCollectionsServiceException
    self._processMap["listAllCollectionsPersistenceException"] = Processor.process_listAllCollectionsPersistenceException
    self._processMap["getAllFieldDetails"] = Processor.process_getAllFieldDetails
    self._processMap["getFieldDetails"] = Processor.process_getFieldDetails
    self._processMap["createAggregate"] = Processor.process_createAggregate
    self._processMap["deleteAggregate"] = Processor.process_deleteAggregate
    self._processMap["getAggregate"] = Processor.process_getAggregate
    self._processMap["getCollectionAggregates"] = Processor.process_getCollectionAggregates
    self._processMap["getSparkRDDConf"] = Processor.process_getSparkRDDConf
    self._processMap["getNewSparkJobOutputPath"] = Processor.process_getNewSparkJobOutputPath
    self._processMap["addSparkFilesToCollection"] = Processor.process_addSparkFilesToCollection
    self._processMap["cleanupSparkImportDir"] = Processor.process_cleanupSparkImportDir

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_getCollectionById(self, seqid, iprot, oprot):
    args = getCollectionById_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCollectionById_result()
    try:
      result.success = self._handler.getCollectionById(args.auth, args.collectionId)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.ttypes.TNotFoundException, nfe:
      result.nfe = nfe
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("getCollectionById", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCollectionByName(self, seqid, iprot, oprot):
    args = getCollectionByName_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCollectionByName_result()
    try:
      result.success = self._handler.getCollectionByName(args.auth, args.collectionName)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.ttypes.TNotFoundException, nfe:
      result.nfe = nfe
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("getCollectionByName", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listCollections(self, seqid, iprot, oprot):
    args = listCollections_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listCollections_result()
    try:
      result.success = self._handler.listCollections(args.auth)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("listCollections", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listCollectionsWithPermission(self, seqid, iprot, oprot):
    args = listCollectionsWithPermission_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listCollectionsWithPermission_result()
    try:
      result.success = self._handler.listCollectionsWithPermission(args.auth, args.permission)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("listCollectionsWithPermission", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listCollectionPermissionTypes(self, seqid, iprot, oprot):
    args = listCollectionPermissionTypes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listCollectionPermissionTypes_result()
    try:
      result.success = self._handler.listCollectionPermissionTypes()
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("listCollectionPermissionTypes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createCollection(self, seqid, iprot, oprot):
    args = createCollection_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createCollection_result()
    try:
      result.success = self._handler.createCollection(args.auth, args.collection)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("createCollection", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_updateCollection(self, seqid, iprot, oprot):
    args = updateCollection_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = updateCollection_result()
    try:
      result.success = self._handler.updateCollection(args.auth, args.collection)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("updateCollection", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteCollection(self, seqid, iprot, oprot):
    args = deleteCollection_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteCollection_result()
    try:
      result.success = self._handler.deleteCollection(args.auth, args.collection)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("deleteCollection", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clearCollection(self, seqid, iprot, oprot):
    args = clearCollection_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clearCollection_result()
    try:
      self._handler.clearCollection(args.auth, args.collection)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("clearCollection", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCollectionStatus(self, seqid, iprot, oprot):
    args = getCollectionStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCollectionStatus_result()
    try:
      result.success = self._handler.getCollectionStatus(args.auth, args.collectionId)
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("getCollectionStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCollectionSample(self, seqid, iprot, oprot):
    args = getCollectionSample_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCollectionSample_result()
    try:
      result.success = self._handler.getCollectionSample(args.auth, args.collectionId, args.maxRecords)
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("getCollectionSample", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCollectionHistoricalStatus(self, seqid, iprot, oprot):
    args = getCollectionHistoricalStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCollectionHistoricalStatus_result()
    try:
      result.success = self._handler.getCollectionHistoricalStatus(args.auth, args.collectionId)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("getCollectionHistoricalStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAllFieldStatistics(self, seqid, iprot, oprot):
    args = getAllFieldStatistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAllFieldStatistics_result()
    try:
      result.success = self._handler.getAllFieldStatistics(args.auth, args.collectionId)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("getAllFieldStatistics", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getFieldStatistics(self, seqid, iprot, oprot):
    args = getFieldStatistics_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getFieldStatistics_result()
    try:
      result.success = self._handler.getFieldStatistics(args.auth, args.collectionId, args.field)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("getFieldStatistics", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getIndexTermTransformerDescriptors(self, seqid, iprot, oprot):
    args = getIndexTermTransformerDescriptors_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getIndexTermTransformerDescriptors_result()
    try:
      result.success = self._handler.getIndexTermTransformerDescriptors(args.auth)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("getIndexTermTransformerDescriptors", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_repair(self, seqid, iprot, oprot):
    args = repair_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = repair_result()
    try:
      self._handler.repair(args.auth, args.collectionId)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("repair", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_insert(self, seqid, iprot, oprot):
    args = insert_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = insert_result()
    try:
      result.success = self._handler.insert(args.auth, args.records)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("insert", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_incrementRecordCount(self, seqid, iprot, oprot):
    args = incrementRecordCount_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = incrementRecordCount_result()
    try:
      self._handler.incrementRecordCount(args.auth, args.collectionId, args.count)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("incrementRecordCount", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setRecordCount(self, seqid, iprot, oprot):
    args = setRecordCount_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setRecordCount_result()
    try:
      self._handler.setRecordCount(args.auth, args.collectionId, args.count)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("setRecordCount", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getDataCollectionPermissionsForAuthorizationBearer(self, seqid, iprot, oprot):
    args = getDataCollectionPermissionsForAuthorizationBearer_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getDataCollectionPermissionsForAuthorizationBearer_result()
    try:
      result.success = self._handler.getDataCollectionPermissionsForAuthorizationBearer(args.auth, args.collectionId)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("getDataCollectionPermissionsForAuthorizationBearer", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_startDownloadRecords(self, seqid, iprot, oprot):
    args = startDownloadRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startDownloadRecords_result()
    try:
      result.success = self._handler.startDownloadRecords(args.auth, args.collectionId)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("startDownloadRecords", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_downloadMoreRecords(self, seqid, iprot, oprot):
    args = downloadMoreRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = downloadMoreRecords_result()
    try:
      result.success = self._handler.downloadMoreRecords(args.auth, args.downloadId, args.maxToReturn)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("downloadMoreRecords", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stopDownloadRecords(self, seqid, iprot, oprot):
    args = stopDownloadRecords_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stopDownloadRecords_result()
    try:
      self._handler.stopDownloadRecords(args.auth, args.downloadId)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("stopDownloadRecords", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listAllCollectionsThriftException(self, seqid, iprot, oprot):
    args = listAllCollectionsThriftException_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listAllCollectionsThriftException_result()
    try:
      result.success = self._handler.listAllCollectionsThriftException(args.auth)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("listAllCollectionsThriftException", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_startDownloadSamples(self, seqid, iprot, oprot):
    args = startDownloadSamples_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startDownloadSamples_result()
    try:
      result.success = self._handler.startDownloadSamples(args.auth, args.collectionId)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("startDownloadSamples", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_downloadMoreSamples(self, seqid, iprot, oprot):
    args = downloadMoreSamples_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = downloadMoreSamples_result()
    try:
      result.success = self._handler.downloadMoreSamples(args.auth, args.downloadId, args.maxToReturn)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("downloadMoreSamples", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stopDownloadSamples(self, seqid, iprot, oprot):
    args = stopDownloadSamples_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stopDownloadSamples_result()
    try:
      self._handler.stopDownloadSamples(args.auth, args.downloadId)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("stopDownloadSamples", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listAllCollectionsServiceException(self, seqid, iprot, oprot):
    args = listAllCollectionsServiceException_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listAllCollectionsServiceException_result()
    try:
      result.success = self._handler.listAllCollectionsServiceException(args.auth)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("listAllCollectionsServiceException", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_listAllCollectionsPersistenceException(self, seqid, iprot, oprot):
    args = listAllCollectionsPersistenceException_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = listAllCollectionsPersistenceException_result()
    try:
      result.success = self._handler.listAllCollectionsPersistenceException(args.auth)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("listAllCollectionsPersistenceException", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAllFieldDetails(self, seqid, iprot, oprot):
    args = getAllFieldDetails_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAllFieldDetails_result()
    try:
      result.success = self._handler.getAllFieldDetails(args.auth, args.collectionId)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("getAllFieldDetails", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getFieldDetails(self, seqid, iprot, oprot):
    args = getFieldDetails_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getFieldDetails_result()
    try:
      result.success = self._handler.getFieldDetails(args.auth, args.collectionId, args.field)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("getFieldDetails", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_createAggregate(self, seqid, iprot, oprot):
    args = createAggregate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = createAggregate_result()
    try:
      self._handler.createAggregate(args.auth, args.aggregate)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("createAggregate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_deleteAggregate(self, seqid, iprot, oprot):
    args = deleteAggregate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = deleteAggregate_result()
    try:
      self._handler.deleteAggregate(args.auth, args.collectionId, args.id)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("deleteAggregate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getAggregate(self, seqid, iprot, oprot):
    args = getAggregate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getAggregate_result()
    try:
      result.success = self._handler.getAggregate(args.auth, args.id)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("getAggregate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getCollectionAggregates(self, seqid, iprot, oprot):
    args = getCollectionAggregates_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getCollectionAggregates_result()
    try:
      result.success = self._handler.getCollectionAggregates(args.auth, args.collectionId)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("getCollectionAggregates", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSparkRDDConf(self, seqid, iprot, oprot):
    args = getSparkRDDConf_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSparkRDDConf_result()
    try:
      result.success = self._handler.getSparkRDDConf(args.auth, args.collectionName)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("getSparkRDDConf", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getNewSparkJobOutputPath(self, seqid, iprot, oprot):
    args = getNewSparkJobOutputPath_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getNewSparkJobOutputPath_result()
    try:
      result.success = self._handler.getNewSparkJobOutputPath(args.auth)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("getNewSparkJobOutputPath", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_addSparkFilesToCollection(self, seqid, iprot, oprot):
    args = addSparkFilesToCollection_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = addSparkFilesToCollection_result()
    try:
      self._handler.addSparkFilesToCollection(args.auth, args.collectionName, args.path)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("addSparkFilesToCollection", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_cleanupSparkImportDir(self, seqid, iprot, oprot):
    args = cleanupSparkImportDir_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = cleanupSparkImportDir_result()
    try:
      self._handler.cleanupSparkImportDir(args.auth, args.importId)
    except koverse.thriftgen.ttypes.TKoverseException, ke:
      result.ke = ke
    except koverse.thriftgen.security.ttypes.TAuthorizationException, ae:
      result.ae = ae
    except koverse.thriftgen.security.ttypes.TCannotUseKoverseException, ce:
      result.ce = ce
    oprot.writeMessageBegin("cleanupSparkImportDir", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class getCollectionById_args:
  """
  Attributes:
   - auth
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionId=None,):
    self.auth = auth
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionById_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionById_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - nfe
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TCollection, TCollection.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nfe', (koverse.thriftgen.ttypes.TNotFoundException, koverse.thriftgen.ttypes.TNotFoundException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, ke=None, ae=None, nfe=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.nfe = nfe
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TCollection()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nfe = koverse.thriftgen.ttypes.TNotFoundException()
          self.nfe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionById_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.nfe is not None:
      oprot.writeFieldBegin('nfe', TType.STRUCT, 3)
      self.nfe.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 4)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionByName_args:
  """
  Attributes:
   - auth
   - collectionName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionName', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionName=None,):
    self.auth = auth
    self.collectionName = collectionName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionByName_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionName is not None:
      oprot.writeFieldBegin('collectionName', TType.STRING, 2)
      oprot.writeString(self.collectionName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionByName_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - nfe
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TCollection, TCollection.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'nfe', (koverse.thriftgen.ttypes.TNotFoundException, koverse.thriftgen.ttypes.TNotFoundException.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 4
  )

  def __init__(self, success=None, ke=None, ae=None, nfe=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.nfe = nfe
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TCollection()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nfe = koverse.thriftgen.ttypes.TNotFoundException()
          self.nfe.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionByName_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.nfe is not None:
      oprot.writeFieldBegin('nfe', TType.STRUCT, 3)
      self.nfe.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 4)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listCollections_args:
  """
  Attributes:
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
  )

  def __init__(self, auth=None,):
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listCollections_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listCollections_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TCollection, TCollection.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype162, _size159) = iprot.readListBegin()
          for _i163 in xrange(_size159):
            _elem164 = TCollection()
            _elem164.read(iprot)
            self.success.append(_elem164)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listCollections_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter165 in self.success:
        iter165.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listCollectionsWithPermission_args:
  """
  Attributes:
   - auth
   - permission
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'permission', None, None, ), # 2
  )

  def __init__(self, auth=None, permission=None,):
    self.auth = auth
    self.permission = permission

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.permission = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listCollectionsWithPermission_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.permission is not None:
      oprot.writeFieldBegin('permission', TType.STRING, 2)
      oprot.writeString(self.permission)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listCollectionsWithPermission_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TCollection, TCollection.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype169, _size166) = iprot.readListBegin()
          for _i170 in xrange(_size166):
            _elem171 = TCollection()
            _elem171.read(iprot)
            self.success.append(_elem171)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listCollectionsWithPermission_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter172 in self.success:
        iter172.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listCollectionPermissionTypes_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listCollectionPermissionTypes_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listCollectionPermissionTypes_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype176, _size173) = iprot.readListBegin()
          for _i177 in xrange(_size173):
            _elem178 = iprot.readString();
            self.success.append(_elem178)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listCollectionPermissionTypes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter179 in self.success:
        oprot.writeString(iter179)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createCollection_args:
  """
  Attributes:
   - auth
   - collection
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'collection', (TCollection, TCollection.thrift_spec), None, ), # 2
  )

  def __init__(self, auth=None, collection=None,):
    self.auth = auth
    self.collection = collection

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.collection = TCollection()
          self.collection.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createCollection_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collection is not None:
      oprot.writeFieldBegin('collection', TType.STRUCT, 2)
      self.collection.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createCollection_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TCollection, TCollection.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TCollection()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createCollection_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateCollection_args:
  """
  Attributes:
   - auth
   - collection
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'collection', (TCollection, TCollection.thrift_spec), None, ), # 2
  )

  def __init__(self, auth=None, collection=None,):
    self.auth = auth
    self.collection = collection

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.collection = TCollection()
          self.collection.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateCollection_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collection is not None:
      oprot.writeFieldBegin('collection', TType.STRUCT, 2)
      self.collection.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class updateCollection_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TCollection, TCollection.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TCollection()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('updateCollection_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteCollection_args:
  """
  Attributes:
   - auth
   - collection
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'collection', (TCollection, TCollection.thrift_spec), None, ), # 2
  )

  def __init__(self, auth=None, collection=None,):
    self.auth = auth
    self.collection = collection

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.collection = TCollection()
          self.collection.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteCollection_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collection is not None:
      oprot.writeFieldBegin('collection', TType.STRUCT, 2)
      self.collection.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteCollection_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteCollection_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearCollection_args:
  """
  Attributes:
   - auth
   - collection
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'collection', (TCollection, TCollection.thrift_spec), None, ), # 2
  )

  def __init__(self, auth=None, collection=None,):
    self.auth = auth
    self.collection = collection

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.collection = TCollection()
          self.collection.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearCollection_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collection is not None:
      oprot.writeFieldBegin('collection', TType.STRUCT, 2)
      self.collection.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clearCollection_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clearCollection_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionStatus_args:
  """
  Attributes:
   - auth
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionId=None,):
    self.auth = auth
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionStatus_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionStatus_result:
  """
  Attributes:
   - success
   - ae
   - ke
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TCollectionStatus, TCollectionStatus.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ae=None, ke=None, ce=None,):
    self.success = success
    self.ae = ae
    self.ke = ke
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype183, _size180) = iprot.readListBegin()
          for _i184 in xrange(_size180):
            _elem185 = TCollectionStatus()
            _elem185.read(iprot)
            self.success.append(_elem185)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter186 in self.success:
        iter186.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 1)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 2)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionSample_args:
  """
  Attributes:
   - auth
   - collectionId
   - maxRecords
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
    (3, TType.I32, 'maxRecords', None, None, ), # 3
  )

  def __init__(self, auth=None, collectionId=None, maxRecords=None,):
    self.auth = auth
    self.collectionId = collectionId
    self.maxRecords = maxRecords

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxRecords = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionSample_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    if self.maxRecords is not None:
      oprot.writeFieldBegin('maxRecords', TType.I32, 3)
      oprot.writeI32(self.maxRecords)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionSample_result:
  """
  Attributes:
   - success
   - ae
   - ke
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(koverse.thriftgen.ttypes.TSimpleRecord, koverse.thriftgen.ttypes.TSimpleRecord.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ae=None, ke=None, ce=None,):
    self.success = success
    self.ae = ae
    self.ke = ke
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype190, _size187) = iprot.readListBegin()
          for _i191 in xrange(_size187):
            _elem192 = koverse.thriftgen.ttypes.TSimpleRecord()
            _elem192.read(iprot)
            self.success.append(_elem192)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionSample_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter193 in self.success:
        iter193.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 1)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 2)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionHistoricalStatus_args:
  """
  Attributes:
   - auth
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionId=None,):
    self.auth = auth
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionHistoricalStatus_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionHistoricalStatus_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TCollectionStatus, TCollectionStatus.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype197, _size194) = iprot.readListBegin()
          for _i198 in xrange(_size194):
            _elem199 = TCollectionStatus()
            _elem199.read(iprot)
            self.success.append(_elem199)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionHistoricalStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter200 in self.success:
        iter200.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllFieldStatistics_args:
  """
  Attributes:
   - auth
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionId=None,):
    self.auth = auth
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllFieldStatistics_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllFieldStatistics_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TCollectionStatistics, TCollectionStatistics.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TCollectionStatistics()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllFieldStatistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFieldStatistics_args:
  """
  Attributes:
   - auth
   - collectionId
   - field
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
    (3, TType.STRING, 'field', None, None, ), # 3
  )

  def __init__(self, auth=None, collectionId=None, field=None,):
    self.auth = auth
    self.collectionId = collectionId
    self.field = field

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.field = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFieldStatistics_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.STRING, 3)
      oprot.writeString(self.field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFieldStatistics_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TCollectionStatistics, TCollectionStatistics.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TCollectionStatistics()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFieldStatistics_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getIndexTermTransformerDescriptors_args:
  """
  Attributes:
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
  )

  def __init__(self, auth=None,):
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getIndexTermTransformerDescriptors_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getIndexTermTransformerDescriptors_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TIndexTermTransformerDescriptor, TIndexTermTransformerDescriptor.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype204, _size201) = iprot.readListBegin()
          for _i205 in xrange(_size201):
            _elem206 = TIndexTermTransformerDescriptor()
            _elem206.read(iprot)
            self.success.append(_elem206)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getIndexTermTransformerDescriptors_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter207 in self.success:
        iter207.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class repair_args:
  """
  Attributes:
   - auth
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionId=None,):
    self.auth = auth
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('repair_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class repair_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('repair_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insert_args:
  """
  Attributes:
   - auth
   - records
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.LIST, 'records', (TType.STRUCT,(koverse.thriftgen.ttypes.TSimpleRecord, koverse.thriftgen.ttypes.TSimpleRecord.thrift_spec)), None, ), # 2
  )

  def __init__(self, auth=None, records=None,):
    self.auth = auth
    self.records = records

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.records = []
          (_etype211, _size208) = iprot.readListBegin()
          for _i212 in xrange(_size208):
            _elem213 = koverse.thriftgen.ttypes.TSimpleRecord()
            _elem213.read(iprot)
            self.records.append(_elem213)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insert_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.records is not None:
      oprot.writeFieldBegin('records', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.records))
      for iter214 in self.records:
        iter214.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insert_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insert_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class incrementRecordCount_args:
  """
  Attributes:
   - auth
   - collectionId
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
    (3, TType.I64, 'count', None, None, ), # 3
  )

  def __init__(self, auth=None, collectionId=None, count=None,):
    self.auth = auth
    self.collectionId = collectionId
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.count = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('incrementRecordCount_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I64, 3)
      oprot.writeI64(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class incrementRecordCount_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('incrementRecordCount_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setRecordCount_args:
  """
  Attributes:
   - auth
   - collectionId
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
    (3, TType.I64, 'count', None, None, ), # 3
  )

  def __init__(self, auth=None, collectionId=None, count=None,):
    self.auth = auth
    self.collectionId = collectionId
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.count = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setRecordCount_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    if self.count is not None:
      oprot.writeFieldBegin('count', TType.I64, 3)
      oprot.writeI64(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setRecordCount_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setRecordCount_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDataCollectionPermissionsForAuthorizationBearer_args:
  """
  Attributes:
   - auth
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionId=None,):
    self.auth = auth
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDataCollectionPermissionsForAuthorizationBearer_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getDataCollectionPermissionsForAuthorizationBearer_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype218, _size215) = iprot.readListBegin()
          for _i219 in xrange(_size215):
            _elem220 = iprot.readString();
            self.success.append(_elem220)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getDataCollectionPermissionsForAuthorizationBearer_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter221 in self.success:
        oprot.writeString(iter221)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startDownloadRecords_args:
  """
  Attributes:
   - auth
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionId=None,):
    self.auth = auth
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startDownloadRecords_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startDownloadRecords_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startDownloadRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class downloadMoreRecords_args:
  """
  Attributes:
   - auth
   - downloadId
   - maxToReturn
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'downloadId', None, None, ), # 2
    (3, TType.I16, 'maxToReturn', None, None, ), # 3
  )

  def __init__(self, auth=None, downloadId=None, maxToReturn=None,):
    self.auth = auth
    self.downloadId = downloadId
    self.maxToReturn = maxToReturn

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.downloadId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.maxToReturn = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('downloadMoreRecords_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.downloadId is not None:
      oprot.writeFieldBegin('downloadId', TType.STRING, 2)
      oprot.writeString(self.downloadId)
      oprot.writeFieldEnd()
    if self.maxToReturn is not None:
      oprot.writeFieldBegin('maxToReturn', TType.I16, 3)
      oprot.writeI16(self.maxToReturn)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class downloadMoreRecords_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TDownloadRecords, TDownloadRecords.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TDownloadRecords()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('downloadMoreRecords_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopDownloadRecords_args:
  """
  Attributes:
   - auth
   - downloadId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'downloadId', None, None, ), # 2
  )

  def __init__(self, auth=None, downloadId=None,):
    self.auth = auth
    self.downloadId = downloadId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.downloadId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopDownloadRecords_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.downloadId is not None:
      oprot.writeFieldBegin('downloadId', TType.STRING, 2)
      oprot.writeString(self.downloadId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopDownloadRecords_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopDownloadRecords_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listAllCollectionsThriftException_args:
  """
  Attributes:
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
  )

  def __init__(self, auth=None,):
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listAllCollectionsThriftException_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listAllCollectionsThriftException_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TCollection, TCollection.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype225, _size222) = iprot.readListBegin()
          for _i226 in xrange(_size222):
            _elem227 = TCollection()
            _elem227.read(iprot)
            self.success.append(_elem227)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listAllCollectionsThriftException_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter228 in self.success:
        iter228.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startDownloadSamples_args:
  """
  Attributes:
   - auth
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionId=None,):
    self.auth = auth
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startDownloadSamples_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startDownloadSamples_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startDownloadSamples_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class downloadMoreSamples_args:
  """
  Attributes:
   - auth
   - downloadId
   - maxToReturn
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'downloadId', None, None, ), # 2
    (3, TType.I16, 'maxToReturn', None, None, ), # 3
  )

  def __init__(self, auth=None, downloadId=None, maxToReturn=None,):
    self.auth = auth
    self.downloadId = downloadId
    self.maxToReturn = maxToReturn

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.downloadId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.maxToReturn = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('downloadMoreSamples_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.downloadId is not None:
      oprot.writeFieldBegin('downloadId', TType.STRING, 2)
      oprot.writeString(self.downloadId)
      oprot.writeFieldEnd()
    if self.maxToReturn is not None:
      oprot.writeFieldBegin('maxToReturn', TType.I16, 3)
      oprot.writeI16(self.maxToReturn)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class downloadMoreSamples_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TDownloadRecords, TDownloadRecords.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TDownloadRecords()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('downloadMoreSamples_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopDownloadSamples_args:
  """
  Attributes:
   - auth
   - downloadId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'downloadId', None, None, ), # 2
  )

  def __init__(self, auth=None, downloadId=None,):
    self.auth = auth
    self.downloadId = downloadId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.downloadId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopDownloadSamples_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.downloadId is not None:
      oprot.writeFieldBegin('downloadId', TType.STRING, 2)
      oprot.writeString(self.downloadId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopDownloadSamples_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopDownloadSamples_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listAllCollectionsServiceException_args:
  """
  Attributes:
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
  )

  def __init__(self, auth=None,):
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listAllCollectionsServiceException_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listAllCollectionsServiceException_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TCollection, TCollection.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype232, _size229) = iprot.readListBegin()
          for _i233 in xrange(_size229):
            _elem234 = TCollection()
            _elem234.read(iprot)
            self.success.append(_elem234)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listAllCollectionsServiceException_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter235 in self.success:
        iter235.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listAllCollectionsPersistenceException_args:
  """
  Attributes:
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
  )

  def __init__(self, auth=None,):
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listAllCollectionsPersistenceException_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class listAllCollectionsPersistenceException_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TCollection, TCollection.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype239, _size236) = iprot.readListBegin()
          for _i240 in xrange(_size236):
            _elem241 = TCollection()
            _elem241.read(iprot)
            self.success.append(_elem241)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('listAllCollectionsPersistenceException_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter242 in self.success:
        iter242.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllFieldDetails_args:
  """
  Attributes:
   - auth
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionId=None,):
    self.auth = auth
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllFieldDetails_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAllFieldDetails_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(TFieldDetails, TFieldDetails.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype246, _size243) = iprot.readListBegin()
          for _i247 in xrange(_size243):
            _elem248 = TFieldDetails()
            _elem248.read(iprot)
            self.success.append(_elem248)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAllFieldDetails_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter249 in self.success:
        iter249.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFieldDetails_args:
  """
  Attributes:
   - auth
   - collectionId
   - field
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
    (3, TType.STRING, 'field', None, None, ), # 3
  )

  def __init__(self, auth=None, collectionId=None, field=None,):
    self.auth = auth
    self.collectionId = collectionId
    self.field = field

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.field = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFieldDetails_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    if self.field is not None:
      oprot.writeFieldBegin('field', TType.STRING, 3)
      oprot.writeString(self.field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getFieldDetails_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TFieldDetails, TFieldDetails.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TFieldDetails()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getFieldDetails_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createAggregate_args:
  """
  Attributes:
   - auth
   - aggregate
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'aggregate', (koverse.thriftgen.aggregate.ttypes.TAggregate, koverse.thriftgen.aggregate.ttypes.TAggregate.thrift_spec), None, ), # 2
  )

  def __init__(self, auth=None, aggregate=None,):
    self.auth = auth
    self.aggregate = aggregate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.aggregate = koverse.thriftgen.aggregate.ttypes.TAggregate()
          self.aggregate.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createAggregate_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.aggregate is not None:
      oprot.writeFieldBegin('aggregate', TType.STRUCT, 2)
      self.aggregate.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class createAggregate_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('createAggregate_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteAggregate_args:
  """
  Attributes:
   - auth
   - collectionId
   - id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
    (3, TType.I64, 'id', None, None, ), # 3
  )

  def __init__(self, auth=None, collectionId=None, id=None,):
    self.auth = auth
    self.collectionId = collectionId
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteAggregate_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 3)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class deleteAggregate_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('deleteAggregate_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAggregate_args:
  """
  Attributes:
   - auth
   - id
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.I64, 'id', None, None, ), # 2
  )

  def __init__(self, auth=None, id=None,):
    self.auth = auth
    self.id = id

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAggregate_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.I64, 2)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getAggregate_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (koverse.thriftgen.aggregate.ttypes.TAggregate, koverse.thriftgen.aggregate.ttypes.TAggregate.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = koverse.thriftgen.aggregate.ttypes.TAggregate()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getAggregate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionAggregates_args:
  """
  Attributes:
   - auth
   - collectionId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionId', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionId=None,):
    self.auth = auth
    self.collectionId = collectionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionAggregates_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionId is not None:
      oprot.writeFieldBegin('collectionId', TType.STRING, 2)
      oprot.writeString(self.collectionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getCollectionAggregates_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(koverse.thriftgen.aggregate.ttypes.TAggregate, koverse.thriftgen.aggregate.ttypes.TAggregate.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype253, _size250) = iprot.readListBegin()
          for _i254 in xrange(_size250):
            _elem255 = koverse.thriftgen.aggregate.ttypes.TAggregate()
            _elem255.read(iprot)
            self.success.append(_elem255)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getCollectionAggregates_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter256 in self.success:
        iter256.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSparkRDDConf_args:
  """
  Attributes:
   - auth
   - collectionName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionName', None, None, ), # 2
  )

  def __init__(self, auth=None, collectionName=None,):
    self.auth = auth
    self.collectionName = collectionName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSparkRDDConf_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionName is not None:
      oprot.writeFieldBegin('collectionName', TType.STRING, 2)
      oprot.writeString(self.collectionName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSparkRDDConf_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype258, _vtype259, _size257 ) = iprot.readMapBegin()
          for _i261 in xrange(_size257):
            _key262 = iprot.readString();
            _val263 = iprot.readString();
            self.success[_key262] = _val263
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSparkRDDConf_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter264,viter265 in self.success.items():
        oprot.writeString(kiter264)
        oprot.writeString(viter265)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNewSparkJobOutputPath_args:
  """
  Attributes:
   - auth
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
  )

  def __init__(self, auth=None,):
    self.auth = auth

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNewSparkJobOutputPath_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getNewSparkJobOutputPath_result:
  """
  Attributes:
   - success
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, success=None, ke=None, ae=None, ce=None,):
    self.success = success
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getNewSparkJobOutputPath_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addSparkFilesToCollection_args:
  """
  Attributes:
   - auth
   - collectionName
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.STRING, 'collectionName', None, None, ), # 2
    (3, TType.STRING, 'path', None, None, ), # 3
  )

  def __init__(self, auth=None, collectionName=None, path=None,):
    self.auth = auth
    self.collectionName = collectionName
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.collectionName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addSparkFilesToCollection_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.collectionName is not None:
      oprot.writeFieldBegin('collectionName', TType.STRING, 2)
      oprot.writeString(self.collectionName)
      oprot.writeFieldEnd()
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 3)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class addSparkFilesToCollection_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('addSparkFilesToCollection_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cleanupSparkImportDir_args:
  """
  Attributes:
   - auth
   - importId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'auth', (koverse.thriftgen.security.ttypes.TAuthInfo, koverse.thriftgen.security.ttypes.TAuthInfo.thrift_spec), None, ), # 1
    (2, TType.I32, 'importId', None, None, ), # 2
  )

  def __init__(self, auth=None, importId=None,):
    self.auth = auth
    self.importId = importId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.auth = koverse.thriftgen.security.ttypes.TAuthInfo()
          self.auth.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.importId = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cleanupSparkImportDir_args')
    if self.auth is not None:
      oprot.writeFieldBegin('auth', TType.STRUCT, 1)
      self.auth.write(oprot)
      oprot.writeFieldEnd()
    if self.importId is not None:
      oprot.writeFieldBegin('importId', TType.I32, 2)
      oprot.writeI32(self.importId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class cleanupSparkImportDir_result:
  """
  Attributes:
   - ke
   - ae
   - ce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ke', (koverse.thriftgen.ttypes.TKoverseException, koverse.thriftgen.ttypes.TKoverseException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ae', (koverse.thriftgen.security.ttypes.TAuthorizationException, koverse.thriftgen.security.ttypes.TAuthorizationException.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'ce', (koverse.thriftgen.security.ttypes.TCannotUseKoverseException, koverse.thriftgen.security.ttypes.TCannotUseKoverseException.thrift_spec), None, ), # 3
  )

  def __init__(self, ke=None, ae=None, ce=None,):
    self.ke = ke
    self.ae = ae
    self.ce = ce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ke = koverse.thriftgen.ttypes.TKoverseException()
          self.ke.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ae = koverse.thriftgen.security.ttypes.TAuthorizationException()
          self.ae.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.ce = koverse.thriftgen.security.ttypes.TCannotUseKoverseException()
          self.ce.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('cleanupSparkImportDir_result')
    if self.ke is not None:
      oprot.writeFieldBegin('ke', TType.STRUCT, 1)
      self.ke.write(oprot)
      oprot.writeFieldEnd()
    if self.ae is not None:
      oprot.writeFieldBegin('ae', TType.STRUCT, 2)
      self.ae.write(oprot)
      oprot.writeFieldEnd()
    if self.ce is not None:
      oprot.writeFieldBegin('ce', TType.STRUCT, 3)
      self.ce.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
