#!/usr/bin/python

files = {'iterators.cpp': '#include "iterators.hpp"\n\nstruct range : public Generator<int> {\n    int maxCount;\n    int index;\n    range() :maxCount(0), index(0) {     };\n    range(int max) :maxCount(max), index(0) {     };\n    ~range() {     };\n\n    virtual int next() {\n    GENERATOR_CODE_START\n    while (index<maxCount) {\n         YIELD(index);\n         index += 1;\n    }\n    GENERATOR_CODE_END\n    }\n};\n', 'iterators.hpp': '#ifndef PYXIE_ITERATORS_HPP\n#define PYXIE_ITERATORS_HPP\n\n/*\n * Python Style Iterators in C++, based in part on experiment work in Kamaelia\n * \n */\n\n#include <exception>\n\n#define GENERATOR_CODE_START  if (this->__generator_state == -1)      \\\n                     { throw StopIteration(); }         \\\n                     switch(this->__generator_state)         \\\n                     { default:\n#define YIELD(v)         this->__generator_state = __LINE__; \\\n                         return (v);                         \\\n                         case __LINE__:\n#define GENERATOR_CODE_END     };                                      \\\n                     this->__generator_state = -1; throw StopIteration();\n\nclass StopIteration : public std::exception {\n  virtual const char* what() const throw()\n  {\n    return "StopIteration";\n  }\n};\n\ntemplate<class T>\nstruct Iterator {\n    virtual T next() {  }\n};\n\ntemplate<class T>\nclass Generator : public Iterator<T> {\n  protected:\n    int __generator_state;\n  public:\n    Generator()  {     };\n    ~Generator() {     };\n};\n\n#endif\n', 'iterators_test.cpp': '/*\n * Test of a C++ version of Python style generators.\n * \n */\n\n#include <iostream>\n#include "iterators.cpp"\n/*\n\nWhile it may be a little unclear, this C++ program is equivalent\nto this python program:\n\nfor count in range(5):\n    print count,\n\nprint\n\nIt doesn\'t do this:\n\nfor(int count=0; count<5; count++) {\n    std::cout << count;\n}\nstd::cout << "." << std::endl;\n\nBecause doing it the way we do makes it avoid treating for/range as a\nspecial case, meaning we solve the harder problem first.  Optimisations\nspecific to certain code structures can come later.\n\n*/\n\n\nint main(int argc, char* argv[]) {\n    // Code to be replaced with a range() style iterator\n    int count;\n    range range_gen = range(5);\n    while (true) {\n        try {\n            count = range_gen.next();\n        } catch (StopIteration s) {\n            break;\n        }\n        std::cout << count;\n    }\n    std::cout << "." << std::endl;\n\n    return 0;\n}\n'}

