// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: simple.proto

#ifndef PROTOBUF_simple_2eproto__INCLUDED
#define PROTOBUF_simple_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_simple_2eproto();
void protobuf_AssignDesc_simple_2eproto();
void protobuf_ShutdownFile_simple_2eproto();

class EchoRequest;
class RAMSizeRequest;
class RAMDataSizeRequest;
class RAMBssSizeRequest;
class RAMHeapSizeRequest;
class RAMStackSizeRequest;
class RAMFreeRequest;
class CommandRequest;
class EchoResponse;
class RAMSizeResponse;
class RAMDataSizeResponse;
class RAMBssSizeResponse;
class RAMHeapSizeResponse;
class RAMStackSizeResponse;
class RAMFreeResponse;
class CommandResponse;

enum CommandType {
  ECHO = 2,
  RAM_SIZE = 3,
  RAM_DATA_SIZE = 4,
  RAM_BSS_SIZE = 5,
  RAM_HEAP_SIZE = 6,
  RAM_STACK_SIZE = 7,
  RAM_FREE = 8
};
bool CommandType_IsValid(int value);
const CommandType CommandType_MIN = ECHO;
const CommandType CommandType_MAX = RAM_FREE;
const int CommandType_ARRAYSIZE = CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommandType_descriptor();
inline const ::std::string& CommandType_Name(CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommandType_descriptor(), value);
}
inline bool CommandType_Parse(
    const ::std::string& name, CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandType>(
    CommandType_descriptor(), name, value);
}
// ===================================================================

class EchoRequest : public ::google::protobuf::Message {
 public:
  EchoRequest();
  virtual ~EchoRequest();

  EchoRequest(const EchoRequest& from);

  inline EchoRequest& operator=(const EchoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EchoRequest& default_instance();

  void Swap(EchoRequest* other);

  // implements Message ----------------------------------------------

  EchoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EchoRequest& from);
  void MergeFrom(const EchoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:EchoRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static EchoRequest* default_instance_;
};
// -------------------------------------------------------------------

class RAMSizeRequest : public ::google::protobuf::Message {
 public:
  RAMSizeRequest();
  virtual ~RAMSizeRequest();

  RAMSizeRequest(const RAMSizeRequest& from);

  inline RAMSizeRequest& operator=(const RAMSizeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RAMSizeRequest& default_instance();

  void Swap(RAMSizeRequest* other);

  // implements Message ----------------------------------------------

  RAMSizeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RAMSizeRequest& from);
  void MergeFrom(const RAMSizeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RAMSizeRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static RAMSizeRequest* default_instance_;
};
// -------------------------------------------------------------------

class RAMDataSizeRequest : public ::google::protobuf::Message {
 public:
  RAMDataSizeRequest();
  virtual ~RAMDataSizeRequest();

  RAMDataSizeRequest(const RAMDataSizeRequest& from);

  inline RAMDataSizeRequest& operator=(const RAMDataSizeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RAMDataSizeRequest& default_instance();

  void Swap(RAMDataSizeRequest* other);

  // implements Message ----------------------------------------------

  RAMDataSizeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RAMDataSizeRequest& from);
  void MergeFrom(const RAMDataSizeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RAMDataSizeRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static RAMDataSizeRequest* default_instance_;
};
// -------------------------------------------------------------------

class RAMBssSizeRequest : public ::google::protobuf::Message {
 public:
  RAMBssSizeRequest();
  virtual ~RAMBssSizeRequest();

  RAMBssSizeRequest(const RAMBssSizeRequest& from);

  inline RAMBssSizeRequest& operator=(const RAMBssSizeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RAMBssSizeRequest& default_instance();

  void Swap(RAMBssSizeRequest* other);

  // implements Message ----------------------------------------------

  RAMBssSizeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RAMBssSizeRequest& from);
  void MergeFrom(const RAMBssSizeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RAMBssSizeRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static RAMBssSizeRequest* default_instance_;
};
// -------------------------------------------------------------------

class RAMHeapSizeRequest : public ::google::protobuf::Message {
 public:
  RAMHeapSizeRequest();
  virtual ~RAMHeapSizeRequest();

  RAMHeapSizeRequest(const RAMHeapSizeRequest& from);

  inline RAMHeapSizeRequest& operator=(const RAMHeapSizeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RAMHeapSizeRequest& default_instance();

  void Swap(RAMHeapSizeRequest* other);

  // implements Message ----------------------------------------------

  RAMHeapSizeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RAMHeapSizeRequest& from);
  void MergeFrom(const RAMHeapSizeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RAMHeapSizeRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static RAMHeapSizeRequest* default_instance_;
};
// -------------------------------------------------------------------

class RAMStackSizeRequest : public ::google::protobuf::Message {
 public:
  RAMStackSizeRequest();
  virtual ~RAMStackSizeRequest();

  RAMStackSizeRequest(const RAMStackSizeRequest& from);

  inline RAMStackSizeRequest& operator=(const RAMStackSizeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RAMStackSizeRequest& default_instance();

  void Swap(RAMStackSizeRequest* other);

  // implements Message ----------------------------------------------

  RAMStackSizeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RAMStackSizeRequest& from);
  void MergeFrom(const RAMStackSizeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RAMStackSizeRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static RAMStackSizeRequest* default_instance_;
};
// -------------------------------------------------------------------

class RAMFreeRequest : public ::google::protobuf::Message {
 public:
  RAMFreeRequest();
  virtual ~RAMFreeRequest();

  RAMFreeRequest(const RAMFreeRequest& from);

  inline RAMFreeRequest& operator=(const RAMFreeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RAMFreeRequest& default_instance();

  void Swap(RAMFreeRequest* other);

  // implements Message ----------------------------------------------

  RAMFreeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RAMFreeRequest& from);
  void MergeFrom(const RAMFreeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RAMFreeRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static RAMFreeRequest* default_instance_;
};
// -------------------------------------------------------------------

class CommandRequest : public ::google::protobuf::Message {
 public:
  CommandRequest();
  virtual ~CommandRequest();

  CommandRequest(const CommandRequest& from);

  inline CommandRequest& operator=(const CommandRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandRequest& default_instance();

  void Swap(CommandRequest* other);

  // implements Message ----------------------------------------------

  CommandRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandRequest& from);
  void MergeFrom(const CommandRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CommandType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::CommandType type() const;
  inline void set_type(::CommandType value);

  // optional .EchoRequest echo = 2;
  inline bool has_echo() const;
  inline void clear_echo();
  static const int kEchoFieldNumber = 2;
  inline const ::EchoRequest& echo() const;
  inline ::EchoRequest* mutable_echo();
  inline ::EchoRequest* release_echo();
  inline void set_allocated_echo(::EchoRequest* echo);

  // optional .RAMSizeRequest ram_size = 3;
  inline bool has_ram_size() const;
  inline void clear_ram_size();
  static const int kRamSizeFieldNumber = 3;
  inline const ::RAMSizeRequest& ram_size() const;
  inline ::RAMSizeRequest* mutable_ram_size();
  inline ::RAMSizeRequest* release_ram_size();
  inline void set_allocated_ram_size(::RAMSizeRequest* ram_size);

  // optional .RAMDataSizeRequest ram_data_size = 4;
  inline bool has_ram_data_size() const;
  inline void clear_ram_data_size();
  static const int kRamDataSizeFieldNumber = 4;
  inline const ::RAMDataSizeRequest& ram_data_size() const;
  inline ::RAMDataSizeRequest* mutable_ram_data_size();
  inline ::RAMDataSizeRequest* release_ram_data_size();
  inline void set_allocated_ram_data_size(::RAMDataSizeRequest* ram_data_size);

  // optional .RAMBssSizeRequest ram_bss_size = 5;
  inline bool has_ram_bss_size() const;
  inline void clear_ram_bss_size();
  static const int kRamBssSizeFieldNumber = 5;
  inline const ::RAMBssSizeRequest& ram_bss_size() const;
  inline ::RAMBssSizeRequest* mutable_ram_bss_size();
  inline ::RAMBssSizeRequest* release_ram_bss_size();
  inline void set_allocated_ram_bss_size(::RAMBssSizeRequest* ram_bss_size);

  // optional .RAMHeapSizeRequest ram_heap_size = 6;
  inline bool has_ram_heap_size() const;
  inline void clear_ram_heap_size();
  static const int kRamHeapSizeFieldNumber = 6;
  inline const ::RAMHeapSizeRequest& ram_heap_size() const;
  inline ::RAMHeapSizeRequest* mutable_ram_heap_size();
  inline ::RAMHeapSizeRequest* release_ram_heap_size();
  inline void set_allocated_ram_heap_size(::RAMHeapSizeRequest* ram_heap_size);

  // optional .RAMStackSizeRequest ram_stack_size = 7;
  inline bool has_ram_stack_size() const;
  inline void clear_ram_stack_size();
  static const int kRamStackSizeFieldNumber = 7;
  inline const ::RAMStackSizeRequest& ram_stack_size() const;
  inline ::RAMStackSizeRequest* mutable_ram_stack_size();
  inline ::RAMStackSizeRequest* release_ram_stack_size();
  inline void set_allocated_ram_stack_size(::RAMStackSizeRequest* ram_stack_size);

  // optional .RAMFreeRequest ram_free = 8;
  inline bool has_ram_free() const;
  inline void clear_ram_free();
  static const int kRamFreeFieldNumber = 8;
  inline const ::RAMFreeRequest& ram_free() const;
  inline ::RAMFreeRequest* mutable_ram_free();
  inline ::RAMFreeRequest* release_ram_free();
  inline void set_allocated_ram_free(::RAMFreeRequest* ram_free);

  // @@protoc_insertion_point(class_scope:CommandRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_echo();
  inline void clear_has_echo();
  inline void set_has_ram_size();
  inline void clear_has_ram_size();
  inline void set_has_ram_data_size();
  inline void clear_has_ram_data_size();
  inline void set_has_ram_bss_size();
  inline void clear_has_ram_bss_size();
  inline void set_has_ram_heap_size();
  inline void clear_has_ram_heap_size();
  inline void set_has_ram_stack_size();
  inline void clear_has_ram_stack_size();
  inline void set_has_ram_free();
  inline void clear_has_ram_free();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::EchoRequest* echo_;
  ::RAMSizeRequest* ram_size_;
  ::RAMDataSizeRequest* ram_data_size_;
  ::RAMBssSizeRequest* ram_bss_size_;
  ::RAMHeapSizeRequest* ram_heap_size_;
  ::RAMStackSizeRequest* ram_stack_size_;
  ::RAMFreeRequest* ram_free_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static CommandRequest* default_instance_;
};
// -------------------------------------------------------------------

class EchoResponse : public ::google::protobuf::Message {
 public:
  EchoResponse();
  virtual ~EchoResponse();

  EchoResponse(const EchoResponse& from);

  inline EchoResponse& operator=(const EchoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EchoResponse& default_instance();

  void Swap(EchoResponse* other);

  // implements Message ----------------------------------------------

  EchoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EchoResponse& from);
  void MergeFrom(const EchoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:EchoResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static EchoResponse* default_instance_;
};
// -------------------------------------------------------------------

class RAMSizeResponse : public ::google::protobuf::Message {
 public:
  RAMSizeResponse();
  virtual ~RAMSizeResponse();

  RAMSizeResponse(const RAMSizeResponse& from);

  inline RAMSizeResponse& operator=(const RAMSizeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RAMSizeResponse& default_instance();

  void Swap(RAMSizeResponse* other);

  // implements Message ----------------------------------------------

  RAMSizeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RAMSizeResponse& from);
  void MergeFrom(const RAMSizeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RAMSizeResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static RAMSizeResponse* default_instance_;
};
// -------------------------------------------------------------------

class RAMDataSizeResponse : public ::google::protobuf::Message {
 public:
  RAMDataSizeResponse();
  virtual ~RAMDataSizeResponse();

  RAMDataSizeResponse(const RAMDataSizeResponse& from);

  inline RAMDataSizeResponse& operator=(const RAMDataSizeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RAMDataSizeResponse& default_instance();

  void Swap(RAMDataSizeResponse* other);

  // implements Message ----------------------------------------------

  RAMDataSizeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RAMDataSizeResponse& from);
  void MergeFrom(const RAMDataSizeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RAMDataSizeResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static RAMDataSizeResponse* default_instance_;
};
// -------------------------------------------------------------------

class RAMBssSizeResponse : public ::google::protobuf::Message {
 public:
  RAMBssSizeResponse();
  virtual ~RAMBssSizeResponse();

  RAMBssSizeResponse(const RAMBssSizeResponse& from);

  inline RAMBssSizeResponse& operator=(const RAMBssSizeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RAMBssSizeResponse& default_instance();

  void Swap(RAMBssSizeResponse* other);

  // implements Message ----------------------------------------------

  RAMBssSizeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RAMBssSizeResponse& from);
  void MergeFrom(const RAMBssSizeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RAMBssSizeResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static RAMBssSizeResponse* default_instance_;
};
// -------------------------------------------------------------------

class RAMHeapSizeResponse : public ::google::protobuf::Message {
 public:
  RAMHeapSizeResponse();
  virtual ~RAMHeapSizeResponse();

  RAMHeapSizeResponse(const RAMHeapSizeResponse& from);

  inline RAMHeapSizeResponse& operator=(const RAMHeapSizeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RAMHeapSizeResponse& default_instance();

  void Swap(RAMHeapSizeResponse* other);

  // implements Message ----------------------------------------------

  RAMHeapSizeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RAMHeapSizeResponse& from);
  void MergeFrom(const RAMHeapSizeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RAMHeapSizeResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static RAMHeapSizeResponse* default_instance_;
};
// -------------------------------------------------------------------

class RAMStackSizeResponse : public ::google::protobuf::Message {
 public:
  RAMStackSizeResponse();
  virtual ~RAMStackSizeResponse();

  RAMStackSizeResponse(const RAMStackSizeResponse& from);

  inline RAMStackSizeResponse& operator=(const RAMStackSizeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RAMStackSizeResponse& default_instance();

  void Swap(RAMStackSizeResponse* other);

  // implements Message ----------------------------------------------

  RAMStackSizeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RAMStackSizeResponse& from);
  void MergeFrom(const RAMStackSizeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RAMStackSizeResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static RAMStackSizeResponse* default_instance_;
};
// -------------------------------------------------------------------

class RAMFreeResponse : public ::google::protobuf::Message {
 public:
  RAMFreeResponse();
  virtual ~RAMFreeResponse();

  RAMFreeResponse(const RAMFreeResponse& from);

  inline RAMFreeResponse& operator=(const RAMFreeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RAMFreeResponse& default_instance();

  void Swap(RAMFreeResponse* other);

  // implements Message ----------------------------------------------

  RAMFreeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RAMFreeResponse& from);
  void MergeFrom(const RAMFreeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RAMFreeResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static RAMFreeResponse* default_instance_;
};
// -------------------------------------------------------------------

class CommandResponse : public ::google::protobuf::Message {
 public:
  CommandResponse();
  virtual ~CommandResponse();

  CommandResponse(const CommandResponse& from);

  inline CommandResponse& operator=(const CommandResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandResponse& default_instance();

  void Swap(CommandResponse* other);

  // implements Message ----------------------------------------------

  CommandResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandResponse& from);
  void MergeFrom(const CommandResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CommandType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::CommandType type() const;
  inline void set_type(::CommandType value);

  // optional .EchoResponse echo = 2;
  inline bool has_echo() const;
  inline void clear_echo();
  static const int kEchoFieldNumber = 2;
  inline const ::EchoResponse& echo() const;
  inline ::EchoResponse* mutable_echo();
  inline ::EchoResponse* release_echo();
  inline void set_allocated_echo(::EchoResponse* echo);

  // optional .RAMSizeResponse ram_size = 3;
  inline bool has_ram_size() const;
  inline void clear_ram_size();
  static const int kRamSizeFieldNumber = 3;
  inline const ::RAMSizeResponse& ram_size() const;
  inline ::RAMSizeResponse* mutable_ram_size();
  inline ::RAMSizeResponse* release_ram_size();
  inline void set_allocated_ram_size(::RAMSizeResponse* ram_size);

  // optional .RAMDataSizeResponse ram_data_size = 4;
  inline bool has_ram_data_size() const;
  inline void clear_ram_data_size();
  static const int kRamDataSizeFieldNumber = 4;
  inline const ::RAMDataSizeResponse& ram_data_size() const;
  inline ::RAMDataSizeResponse* mutable_ram_data_size();
  inline ::RAMDataSizeResponse* release_ram_data_size();
  inline void set_allocated_ram_data_size(::RAMDataSizeResponse* ram_data_size);

  // optional .RAMBssSizeResponse ram_bss_size = 5;
  inline bool has_ram_bss_size() const;
  inline void clear_ram_bss_size();
  static const int kRamBssSizeFieldNumber = 5;
  inline const ::RAMBssSizeResponse& ram_bss_size() const;
  inline ::RAMBssSizeResponse* mutable_ram_bss_size();
  inline ::RAMBssSizeResponse* release_ram_bss_size();
  inline void set_allocated_ram_bss_size(::RAMBssSizeResponse* ram_bss_size);

  // optional .RAMHeapSizeResponse ram_heap_size = 6;
  inline bool has_ram_heap_size() const;
  inline void clear_ram_heap_size();
  static const int kRamHeapSizeFieldNumber = 6;
  inline const ::RAMHeapSizeResponse& ram_heap_size() const;
  inline ::RAMHeapSizeResponse* mutable_ram_heap_size();
  inline ::RAMHeapSizeResponse* release_ram_heap_size();
  inline void set_allocated_ram_heap_size(::RAMHeapSizeResponse* ram_heap_size);

  // optional .RAMStackSizeResponse ram_stack_size = 7;
  inline bool has_ram_stack_size() const;
  inline void clear_ram_stack_size();
  static const int kRamStackSizeFieldNumber = 7;
  inline const ::RAMStackSizeResponse& ram_stack_size() const;
  inline ::RAMStackSizeResponse* mutable_ram_stack_size();
  inline ::RAMStackSizeResponse* release_ram_stack_size();
  inline void set_allocated_ram_stack_size(::RAMStackSizeResponse* ram_stack_size);

  // optional .RAMFreeResponse ram_free = 8;
  inline bool has_ram_free() const;
  inline void clear_ram_free();
  static const int kRamFreeFieldNumber = 8;
  inline const ::RAMFreeResponse& ram_free() const;
  inline ::RAMFreeResponse* mutable_ram_free();
  inline ::RAMFreeResponse* release_ram_free();
  inline void set_allocated_ram_free(::RAMFreeResponse* ram_free);

  // @@protoc_insertion_point(class_scope:CommandResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_echo();
  inline void clear_has_echo();
  inline void set_has_ram_size();
  inline void clear_has_ram_size();
  inline void set_has_ram_data_size();
  inline void clear_has_ram_data_size();
  inline void set_has_ram_bss_size();
  inline void clear_has_ram_bss_size();
  inline void set_has_ram_heap_size();
  inline void clear_has_ram_heap_size();
  inline void set_has_ram_stack_size();
  inline void clear_has_ram_stack_size();
  inline void set_has_ram_free();
  inline void clear_has_ram_free();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::EchoResponse* echo_;
  ::RAMSizeResponse* ram_size_;
  ::RAMDataSizeResponse* ram_data_size_;
  ::RAMBssSizeResponse* ram_bss_size_;
  ::RAMHeapSizeResponse* ram_heap_size_;
  ::RAMStackSizeResponse* ram_stack_size_;
  ::RAMFreeResponse* ram_free_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_simple_2eproto();
  friend void protobuf_AssignDesc_simple_2eproto();
  friend void protobuf_ShutdownFile_simple_2eproto();

  void InitAsDefaultInstance();
  static CommandResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// EchoRequest

// -------------------------------------------------------------------

// RAMSizeRequest

// -------------------------------------------------------------------

// RAMDataSizeRequest

// -------------------------------------------------------------------

// RAMBssSizeRequest

// -------------------------------------------------------------------

// RAMHeapSizeRequest

// -------------------------------------------------------------------

// RAMStackSizeRequest

// -------------------------------------------------------------------

// RAMFreeRequest

// -------------------------------------------------------------------

// CommandRequest

// required .CommandType type = 1;
inline bool CommandRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandRequest::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::CommandType CommandRequest::type() const {
  return static_cast< ::CommandType >(type_);
}
inline void CommandRequest::set_type(::CommandType value) {
  assert(::CommandType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .EchoRequest echo = 2;
inline bool CommandRequest::has_echo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandRequest::set_has_echo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandRequest::clear_has_echo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandRequest::clear_echo() {
  if (echo_ != NULL) echo_->::EchoRequest::Clear();
  clear_has_echo();
}
inline const ::EchoRequest& CommandRequest::echo() const {
  return echo_ != NULL ? *echo_ : *default_instance_->echo_;
}
inline ::EchoRequest* CommandRequest::mutable_echo() {
  set_has_echo();
  if (echo_ == NULL) echo_ = new ::EchoRequest;
  return echo_;
}
inline ::EchoRequest* CommandRequest::release_echo() {
  clear_has_echo();
  ::EchoRequest* temp = echo_;
  echo_ = NULL;
  return temp;
}
inline void CommandRequest::set_allocated_echo(::EchoRequest* echo) {
  delete echo_;
  echo_ = echo;
  if (echo) {
    set_has_echo();
  } else {
    clear_has_echo();
  }
}

// optional .RAMSizeRequest ram_size = 3;
inline bool CommandRequest::has_ram_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandRequest::set_has_ram_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandRequest::clear_has_ram_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandRequest::clear_ram_size() {
  if (ram_size_ != NULL) ram_size_->::RAMSizeRequest::Clear();
  clear_has_ram_size();
}
inline const ::RAMSizeRequest& CommandRequest::ram_size() const {
  return ram_size_ != NULL ? *ram_size_ : *default_instance_->ram_size_;
}
inline ::RAMSizeRequest* CommandRequest::mutable_ram_size() {
  set_has_ram_size();
  if (ram_size_ == NULL) ram_size_ = new ::RAMSizeRequest;
  return ram_size_;
}
inline ::RAMSizeRequest* CommandRequest::release_ram_size() {
  clear_has_ram_size();
  ::RAMSizeRequest* temp = ram_size_;
  ram_size_ = NULL;
  return temp;
}
inline void CommandRequest::set_allocated_ram_size(::RAMSizeRequest* ram_size) {
  delete ram_size_;
  ram_size_ = ram_size;
  if (ram_size) {
    set_has_ram_size();
  } else {
    clear_has_ram_size();
  }
}

// optional .RAMDataSizeRequest ram_data_size = 4;
inline bool CommandRequest::has_ram_data_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandRequest::set_has_ram_data_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandRequest::clear_has_ram_data_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandRequest::clear_ram_data_size() {
  if (ram_data_size_ != NULL) ram_data_size_->::RAMDataSizeRequest::Clear();
  clear_has_ram_data_size();
}
inline const ::RAMDataSizeRequest& CommandRequest::ram_data_size() const {
  return ram_data_size_ != NULL ? *ram_data_size_ : *default_instance_->ram_data_size_;
}
inline ::RAMDataSizeRequest* CommandRequest::mutable_ram_data_size() {
  set_has_ram_data_size();
  if (ram_data_size_ == NULL) ram_data_size_ = new ::RAMDataSizeRequest;
  return ram_data_size_;
}
inline ::RAMDataSizeRequest* CommandRequest::release_ram_data_size() {
  clear_has_ram_data_size();
  ::RAMDataSizeRequest* temp = ram_data_size_;
  ram_data_size_ = NULL;
  return temp;
}
inline void CommandRequest::set_allocated_ram_data_size(::RAMDataSizeRequest* ram_data_size) {
  delete ram_data_size_;
  ram_data_size_ = ram_data_size;
  if (ram_data_size) {
    set_has_ram_data_size();
  } else {
    clear_has_ram_data_size();
  }
}

// optional .RAMBssSizeRequest ram_bss_size = 5;
inline bool CommandRequest::has_ram_bss_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandRequest::set_has_ram_bss_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandRequest::clear_has_ram_bss_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandRequest::clear_ram_bss_size() {
  if (ram_bss_size_ != NULL) ram_bss_size_->::RAMBssSizeRequest::Clear();
  clear_has_ram_bss_size();
}
inline const ::RAMBssSizeRequest& CommandRequest::ram_bss_size() const {
  return ram_bss_size_ != NULL ? *ram_bss_size_ : *default_instance_->ram_bss_size_;
}
inline ::RAMBssSizeRequest* CommandRequest::mutable_ram_bss_size() {
  set_has_ram_bss_size();
  if (ram_bss_size_ == NULL) ram_bss_size_ = new ::RAMBssSizeRequest;
  return ram_bss_size_;
}
inline ::RAMBssSizeRequest* CommandRequest::release_ram_bss_size() {
  clear_has_ram_bss_size();
  ::RAMBssSizeRequest* temp = ram_bss_size_;
  ram_bss_size_ = NULL;
  return temp;
}
inline void CommandRequest::set_allocated_ram_bss_size(::RAMBssSizeRequest* ram_bss_size) {
  delete ram_bss_size_;
  ram_bss_size_ = ram_bss_size;
  if (ram_bss_size) {
    set_has_ram_bss_size();
  } else {
    clear_has_ram_bss_size();
  }
}

// optional .RAMHeapSizeRequest ram_heap_size = 6;
inline bool CommandRequest::has_ram_heap_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandRequest::set_has_ram_heap_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandRequest::clear_has_ram_heap_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandRequest::clear_ram_heap_size() {
  if (ram_heap_size_ != NULL) ram_heap_size_->::RAMHeapSizeRequest::Clear();
  clear_has_ram_heap_size();
}
inline const ::RAMHeapSizeRequest& CommandRequest::ram_heap_size() const {
  return ram_heap_size_ != NULL ? *ram_heap_size_ : *default_instance_->ram_heap_size_;
}
inline ::RAMHeapSizeRequest* CommandRequest::mutable_ram_heap_size() {
  set_has_ram_heap_size();
  if (ram_heap_size_ == NULL) ram_heap_size_ = new ::RAMHeapSizeRequest;
  return ram_heap_size_;
}
inline ::RAMHeapSizeRequest* CommandRequest::release_ram_heap_size() {
  clear_has_ram_heap_size();
  ::RAMHeapSizeRequest* temp = ram_heap_size_;
  ram_heap_size_ = NULL;
  return temp;
}
inline void CommandRequest::set_allocated_ram_heap_size(::RAMHeapSizeRequest* ram_heap_size) {
  delete ram_heap_size_;
  ram_heap_size_ = ram_heap_size;
  if (ram_heap_size) {
    set_has_ram_heap_size();
  } else {
    clear_has_ram_heap_size();
  }
}

// optional .RAMStackSizeRequest ram_stack_size = 7;
inline bool CommandRequest::has_ram_stack_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandRequest::set_has_ram_stack_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandRequest::clear_has_ram_stack_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandRequest::clear_ram_stack_size() {
  if (ram_stack_size_ != NULL) ram_stack_size_->::RAMStackSizeRequest::Clear();
  clear_has_ram_stack_size();
}
inline const ::RAMStackSizeRequest& CommandRequest::ram_stack_size() const {
  return ram_stack_size_ != NULL ? *ram_stack_size_ : *default_instance_->ram_stack_size_;
}
inline ::RAMStackSizeRequest* CommandRequest::mutable_ram_stack_size() {
  set_has_ram_stack_size();
  if (ram_stack_size_ == NULL) ram_stack_size_ = new ::RAMStackSizeRequest;
  return ram_stack_size_;
}
inline ::RAMStackSizeRequest* CommandRequest::release_ram_stack_size() {
  clear_has_ram_stack_size();
  ::RAMStackSizeRequest* temp = ram_stack_size_;
  ram_stack_size_ = NULL;
  return temp;
}
inline void CommandRequest::set_allocated_ram_stack_size(::RAMStackSizeRequest* ram_stack_size) {
  delete ram_stack_size_;
  ram_stack_size_ = ram_stack_size;
  if (ram_stack_size) {
    set_has_ram_stack_size();
  } else {
    clear_has_ram_stack_size();
  }
}

// optional .RAMFreeRequest ram_free = 8;
inline bool CommandRequest::has_ram_free() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandRequest::set_has_ram_free() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandRequest::clear_has_ram_free() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandRequest::clear_ram_free() {
  if (ram_free_ != NULL) ram_free_->::RAMFreeRequest::Clear();
  clear_has_ram_free();
}
inline const ::RAMFreeRequest& CommandRequest::ram_free() const {
  return ram_free_ != NULL ? *ram_free_ : *default_instance_->ram_free_;
}
inline ::RAMFreeRequest* CommandRequest::mutable_ram_free() {
  set_has_ram_free();
  if (ram_free_ == NULL) ram_free_ = new ::RAMFreeRequest;
  return ram_free_;
}
inline ::RAMFreeRequest* CommandRequest::release_ram_free() {
  clear_has_ram_free();
  ::RAMFreeRequest* temp = ram_free_;
  ram_free_ = NULL;
  return temp;
}
inline void CommandRequest::set_allocated_ram_free(::RAMFreeRequest* ram_free) {
  delete ram_free_;
  ram_free_ = ram_free;
  if (ram_free) {
    set_has_ram_free();
  } else {
    clear_has_ram_free();
  }
}

// -------------------------------------------------------------------

// EchoResponse

// -------------------------------------------------------------------

// RAMSizeResponse

// required uint32 result = 1;
inline bool RAMSizeResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RAMSizeResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RAMSizeResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RAMSizeResponse::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 RAMSizeResponse::result() const {
  return result_;
}
inline void RAMSizeResponse::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RAMDataSizeResponse

// required uint32 result = 1;
inline bool RAMDataSizeResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RAMDataSizeResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RAMDataSizeResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RAMDataSizeResponse::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 RAMDataSizeResponse::result() const {
  return result_;
}
inline void RAMDataSizeResponse::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RAMBssSizeResponse

// required uint32 result = 1;
inline bool RAMBssSizeResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RAMBssSizeResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RAMBssSizeResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RAMBssSizeResponse::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 RAMBssSizeResponse::result() const {
  return result_;
}
inline void RAMBssSizeResponse::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RAMHeapSizeResponse

// required uint32 result = 1;
inline bool RAMHeapSizeResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RAMHeapSizeResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RAMHeapSizeResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RAMHeapSizeResponse::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 RAMHeapSizeResponse::result() const {
  return result_;
}
inline void RAMHeapSizeResponse::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RAMStackSizeResponse

// required uint32 result = 1;
inline bool RAMStackSizeResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RAMStackSizeResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RAMStackSizeResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RAMStackSizeResponse::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 RAMStackSizeResponse::result() const {
  return result_;
}
inline void RAMStackSizeResponse::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RAMFreeResponse

// required uint32 result = 1;
inline bool RAMFreeResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RAMFreeResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RAMFreeResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RAMFreeResponse::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 RAMFreeResponse::result() const {
  return result_;
}
inline void RAMFreeResponse::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// CommandResponse

// required .CommandType type = 1;
inline bool CommandResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandResponse::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::CommandType CommandResponse::type() const {
  return static_cast< ::CommandType >(type_);
}
inline void CommandResponse::set_type(::CommandType value) {
  assert(::CommandType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .EchoResponse echo = 2;
inline bool CommandResponse::has_echo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandResponse::set_has_echo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandResponse::clear_has_echo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandResponse::clear_echo() {
  if (echo_ != NULL) echo_->::EchoResponse::Clear();
  clear_has_echo();
}
inline const ::EchoResponse& CommandResponse::echo() const {
  return echo_ != NULL ? *echo_ : *default_instance_->echo_;
}
inline ::EchoResponse* CommandResponse::mutable_echo() {
  set_has_echo();
  if (echo_ == NULL) echo_ = new ::EchoResponse;
  return echo_;
}
inline ::EchoResponse* CommandResponse::release_echo() {
  clear_has_echo();
  ::EchoResponse* temp = echo_;
  echo_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_echo(::EchoResponse* echo) {
  delete echo_;
  echo_ = echo;
  if (echo) {
    set_has_echo();
  } else {
    clear_has_echo();
  }
}

// optional .RAMSizeResponse ram_size = 3;
inline bool CommandResponse::has_ram_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommandResponse::set_has_ram_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommandResponse::clear_has_ram_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommandResponse::clear_ram_size() {
  if (ram_size_ != NULL) ram_size_->::RAMSizeResponse::Clear();
  clear_has_ram_size();
}
inline const ::RAMSizeResponse& CommandResponse::ram_size() const {
  return ram_size_ != NULL ? *ram_size_ : *default_instance_->ram_size_;
}
inline ::RAMSizeResponse* CommandResponse::mutable_ram_size() {
  set_has_ram_size();
  if (ram_size_ == NULL) ram_size_ = new ::RAMSizeResponse;
  return ram_size_;
}
inline ::RAMSizeResponse* CommandResponse::release_ram_size() {
  clear_has_ram_size();
  ::RAMSizeResponse* temp = ram_size_;
  ram_size_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_ram_size(::RAMSizeResponse* ram_size) {
  delete ram_size_;
  ram_size_ = ram_size;
  if (ram_size) {
    set_has_ram_size();
  } else {
    clear_has_ram_size();
  }
}

// optional .RAMDataSizeResponse ram_data_size = 4;
inline bool CommandResponse::has_ram_data_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommandResponse::set_has_ram_data_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommandResponse::clear_has_ram_data_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommandResponse::clear_ram_data_size() {
  if (ram_data_size_ != NULL) ram_data_size_->::RAMDataSizeResponse::Clear();
  clear_has_ram_data_size();
}
inline const ::RAMDataSizeResponse& CommandResponse::ram_data_size() const {
  return ram_data_size_ != NULL ? *ram_data_size_ : *default_instance_->ram_data_size_;
}
inline ::RAMDataSizeResponse* CommandResponse::mutable_ram_data_size() {
  set_has_ram_data_size();
  if (ram_data_size_ == NULL) ram_data_size_ = new ::RAMDataSizeResponse;
  return ram_data_size_;
}
inline ::RAMDataSizeResponse* CommandResponse::release_ram_data_size() {
  clear_has_ram_data_size();
  ::RAMDataSizeResponse* temp = ram_data_size_;
  ram_data_size_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_ram_data_size(::RAMDataSizeResponse* ram_data_size) {
  delete ram_data_size_;
  ram_data_size_ = ram_data_size;
  if (ram_data_size) {
    set_has_ram_data_size();
  } else {
    clear_has_ram_data_size();
  }
}

// optional .RAMBssSizeResponse ram_bss_size = 5;
inline bool CommandResponse::has_ram_bss_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommandResponse::set_has_ram_bss_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommandResponse::clear_has_ram_bss_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommandResponse::clear_ram_bss_size() {
  if (ram_bss_size_ != NULL) ram_bss_size_->::RAMBssSizeResponse::Clear();
  clear_has_ram_bss_size();
}
inline const ::RAMBssSizeResponse& CommandResponse::ram_bss_size() const {
  return ram_bss_size_ != NULL ? *ram_bss_size_ : *default_instance_->ram_bss_size_;
}
inline ::RAMBssSizeResponse* CommandResponse::mutable_ram_bss_size() {
  set_has_ram_bss_size();
  if (ram_bss_size_ == NULL) ram_bss_size_ = new ::RAMBssSizeResponse;
  return ram_bss_size_;
}
inline ::RAMBssSizeResponse* CommandResponse::release_ram_bss_size() {
  clear_has_ram_bss_size();
  ::RAMBssSizeResponse* temp = ram_bss_size_;
  ram_bss_size_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_ram_bss_size(::RAMBssSizeResponse* ram_bss_size) {
  delete ram_bss_size_;
  ram_bss_size_ = ram_bss_size;
  if (ram_bss_size) {
    set_has_ram_bss_size();
  } else {
    clear_has_ram_bss_size();
  }
}

// optional .RAMHeapSizeResponse ram_heap_size = 6;
inline bool CommandResponse::has_ram_heap_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommandResponse::set_has_ram_heap_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommandResponse::clear_has_ram_heap_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommandResponse::clear_ram_heap_size() {
  if (ram_heap_size_ != NULL) ram_heap_size_->::RAMHeapSizeResponse::Clear();
  clear_has_ram_heap_size();
}
inline const ::RAMHeapSizeResponse& CommandResponse::ram_heap_size() const {
  return ram_heap_size_ != NULL ? *ram_heap_size_ : *default_instance_->ram_heap_size_;
}
inline ::RAMHeapSizeResponse* CommandResponse::mutable_ram_heap_size() {
  set_has_ram_heap_size();
  if (ram_heap_size_ == NULL) ram_heap_size_ = new ::RAMHeapSizeResponse;
  return ram_heap_size_;
}
inline ::RAMHeapSizeResponse* CommandResponse::release_ram_heap_size() {
  clear_has_ram_heap_size();
  ::RAMHeapSizeResponse* temp = ram_heap_size_;
  ram_heap_size_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_ram_heap_size(::RAMHeapSizeResponse* ram_heap_size) {
  delete ram_heap_size_;
  ram_heap_size_ = ram_heap_size;
  if (ram_heap_size) {
    set_has_ram_heap_size();
  } else {
    clear_has_ram_heap_size();
  }
}

// optional .RAMStackSizeResponse ram_stack_size = 7;
inline bool CommandResponse::has_ram_stack_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommandResponse::set_has_ram_stack_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommandResponse::clear_has_ram_stack_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommandResponse::clear_ram_stack_size() {
  if (ram_stack_size_ != NULL) ram_stack_size_->::RAMStackSizeResponse::Clear();
  clear_has_ram_stack_size();
}
inline const ::RAMStackSizeResponse& CommandResponse::ram_stack_size() const {
  return ram_stack_size_ != NULL ? *ram_stack_size_ : *default_instance_->ram_stack_size_;
}
inline ::RAMStackSizeResponse* CommandResponse::mutable_ram_stack_size() {
  set_has_ram_stack_size();
  if (ram_stack_size_ == NULL) ram_stack_size_ = new ::RAMStackSizeResponse;
  return ram_stack_size_;
}
inline ::RAMStackSizeResponse* CommandResponse::release_ram_stack_size() {
  clear_has_ram_stack_size();
  ::RAMStackSizeResponse* temp = ram_stack_size_;
  ram_stack_size_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_ram_stack_size(::RAMStackSizeResponse* ram_stack_size) {
  delete ram_stack_size_;
  ram_stack_size_ = ram_stack_size;
  if (ram_stack_size) {
    set_has_ram_stack_size();
  } else {
    clear_has_ram_stack_size();
  }
}

// optional .RAMFreeResponse ram_free = 8;
inline bool CommandResponse::has_ram_free() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommandResponse::set_has_ram_free() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommandResponse::clear_has_ram_free() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommandResponse::clear_ram_free() {
  if (ram_free_ != NULL) ram_free_->::RAMFreeResponse::Clear();
  clear_has_ram_free();
}
inline const ::RAMFreeResponse& CommandResponse::ram_free() const {
  return ram_free_ != NULL ? *ram_free_ : *default_instance_->ram_free_;
}
inline ::RAMFreeResponse* CommandResponse::mutable_ram_free() {
  set_has_ram_free();
  if (ram_free_ == NULL) ram_free_ = new ::RAMFreeResponse;
  return ram_free_;
}
inline ::RAMFreeResponse* CommandResponse::release_ram_free() {
  clear_has_ram_free();
  ::RAMFreeResponse* temp = ram_free_;
  ram_free_ = NULL;
  return temp;
}
inline void CommandResponse::set_allocated_ram_free(::RAMFreeResponse* ram_free) {
  delete ram_free_;
  ram_free_ = ram_free;
  if (ram_free) {
    set_has_ram_free();
  } else {
    clear_has_ram_free();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CommandType>() {
  return ::CommandType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_simple_2eproto__INCLUDED
