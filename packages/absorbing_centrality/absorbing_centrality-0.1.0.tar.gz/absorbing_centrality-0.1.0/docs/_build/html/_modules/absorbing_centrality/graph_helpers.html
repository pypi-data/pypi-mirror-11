

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>absorbing_centrality.graph_helpers &mdash; absorbing-centrality  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="absorbing-centrality  documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../../index.html" class="icon icon-home"> absorbing-centrality
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../readme.html#absorbing-random-walk-centrality">Absorbing Random-Walk Centrality</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../readme.html#installation">Installation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../readme.html#documentation">Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../readme.html#development">Development</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reference/index.html#computing-the-centrality-of-a-set">Computing the centrality of a set</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/absorbing_centrality.absorbing_centrality.html">absorbing_centrality.absorbing_centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/absorbing_centrality.absorbing_centrality_inversion.html">absorbing_centrality.absorbing_centrality_inversion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/index.html#team-selection-algorithms">Team-selection algorithms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/absorbing_centrality.greedy_team.html">absorbing_centrality.greedy_team</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/index.html#matrix-related-functions">Matrix-related functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/absorbing_centrality.compute_fundamental_matrix.html">absorbing_centrality.compute_fundamental_matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/absorbing_centrality.compute_transition_matrix.html">absorbing_centrality.compute_transition_matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/absorbing_centrality.compute_personalized_transition_matrix.html">absorbing_centrality.compute_personalized_transition_matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/absorbing_centrality.update_fundamental_matrix.html">absorbing_centrality.update_fundamental_matrix</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/index.html#preprocessing-the-graph">Preprocessing the graph</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/absorbing_centrality.canonical_relabel_nodes.html">absorbing_centrality.canonical_relabel_nodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/absorbing_centrality.is_canonical.html">absorbing_centrality.is_canonical</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/absorbing_centrality.add_supernode.html">absorbing_centrality.add_supernode</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/absorbing_centrality.has_supernode.html">absorbing_centrality.has_supernode</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../reference/index.html#exceptions">Exceptions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../reference/generated/absorbing_centrality.CanonicalizationError.html">absorbing_centrality.CanonicalizationError</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../contributing.html#bug-reports">Bug reports</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing.html#documentation-improvements">Documentation improvements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing.html#feature-requests-and-feedback">Feature requests and feedback</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing.html#development">Development</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../contributing.html#pull-request-guidelines">Pull Request Guidelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../contributing.html#tips">Tips</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#id1">0.1 (2015-08-31)</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">absorbing-centrality</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>absorbing_centrality.graph_helpers</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for absorbing_centrality.graph_helpers</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    graph_helpers</span>
<span class="sd">    ~~~~~~~~~~</span>

<span class="sd">    Provides helper functions that are used for:</span>
<span class="sd">        * graph preprocessing</span>
<span class="sd">        * matrix genereration (fundamental, transition)</span>
<span class="sd">        * Sherman-Morrison formula</span>
<span class="sd">        * absorbing random-walk centrality computation</span>


<span class="sd">    :copyright: 2015 Charalampos Mavroforakis, &lt;cmav@bu.edu&gt; and contributors</span>
<span class="sd">    :license: ISC</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">maxint</span>

<span class="kn">from</span> <span class="nn">networkx</span> <span class="kn">import</span> <span class="p">(</span><span class="n">DiGraph</span><span class="p">,</span> <span class="n">adjacency_matrix</span><span class="p">,</span> <span class="n">connected_component_subgraphs</span><span class="p">,</span>
                      <span class="n">relabel_nodes</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">arange</span><span class="p">,</span> <span class="n">argwhere</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">eye</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">zeros</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">eye</span> <span class="k">as</span> <span class="n">speye</span><span class="p">,</span> <span class="n">csc_matrix</span><span class="p">,</span> <span class="n">diags</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">inv</span> <span class="k">as</span> <span class="n">spinv</span><span class="p">,</span> <span class="n">spilu</span>

<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="n">CanonicalizationError</span>

<span class="n">SUPER_NODE</span> <span class="o">=</span> <span class="s">&#39;_super_&#39;</span>


<span class="k">def</span> <span class="nf">keep_largest_component</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Keeps the largest connected component of the graph and removes all the</span>
<span class="sd">    self loops.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The input graph.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NetworkX graph</span>
<span class="sd">        The largest connected subgraph of G. All self-loops have been removed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G_largest</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">connected_component_subgraphs</span><span class="p">(</span><span class="n">G</span><span class="p">),</span>
                       <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">G_largest</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">G_largest</span><span class="o">.</span><span class="n">selfloop_edges</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">G_largest</span>


<div class="viewcode-block" id="is_canonical"><a class="viewcode-back" href="../../reference/generated/absorbing_centrality.is_canonical.html#absorbing_centrality.is_canonical">[docs]</a><span class="k">def</span> <span class="nf">is_canonical</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tests if the graph has been canonicalized.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">    Returns True, if the graph has been canonicalized.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s">&#39;label_map&#39;</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span> <span class="ow">and</span> <span class="s">&#39;canonical_map&#39;</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span></div>


<div class="viewcode-block" id="canonical_relabel_nodes"><a class="viewcode-back" href="../../reference/generated/absorbing_centrality.canonical_relabel_nodes.html#absorbing_centrality.canonical_relabel_nodes">[docs]</a><span class="k">def</span> <span class="nf">canonical_relabel_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Relabels the nodes in the graph, such that the new names belong in</span>
<span class="sd">    the set [1,n]. The labeling information is stored in the dictionaries</span>
<span class="sd">    `G.graph[&#39;canonical_map&#39;]` and `G.graph[&#39;label_map&#39;]`. These provide a way</span>
<span class="sd">    to map original to canonical node names and vice-versa, respectively.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    G_prime : NetworkX graph</span>
<span class="sd">        The relabeled graph. It includes two attributes:</span>

<span class="sd">        (i) `G_prime.graph[&#39;canonical_map&#39;]` : dict</span>
<span class="sd">                Holds the mapping between the original names of the nodes and</span>
<span class="sd">                the new, canonical, names (original -&gt; new).</span>

<span class="sd">        (ii) `G_prime.graph[&#39;label_map&#39;]` : dict</span>
<span class="sd">                Holds the mapping between the new, canonical, names and the</span>
<span class="sd">                original names of the nodes (new -&gt; original).</span>


<span class="sd">    Note: The relabeling of a particular node might not be consistent</span>
<span class="sd">    across two consecutive runs. Also, the relabeling happens on a copy, so the</span>
<span class="sd">    original graph will be untouched.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="n">G_prime</span> <span class="o">=</span> <span class="n">relabel_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">G_prime</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;canonical_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">G_prime</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;label_map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">iteritems</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">G_prime</span></div>


<div class="viewcode-block" id="compute_fundamental_matrix"><a class="viewcode-back" href="../../reference/generated/absorbing_centrality.compute_fundamental_matrix.html#absorbing_centrality.compute_fundamental_matrix">[docs]</a><span class="k">def</span> <span class="nf">compute_fundamental_matrix</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">drop_tol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">fill_factor</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the fundamental matrix for an absorbing random walk.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    P : scipy.sparse matrix</span>
<span class="sd">        The transition probability matrix of the absorbing random walk. To</span>
<span class="sd">        construct this matrix, you start from the original transition matrix</span>
<span class="sd">        and delete the rows that correspond to the absorbing nodes.</span>

<span class="sd">    fast : bool, optional</span>
<span class="sd">    If True (default), use the iterative SuperLU solver from</span>
<span class="sd">    scipy.sparse.linalg.</span>

<span class="sd">    drop_tol : float, optional</span>
<span class="sd">        If `fast` is True, the `drop_tol` parameter of the SuperLU solver is</span>
<span class="sd">        set to this value (default is 1e-5).</span>

<span class="sd">    fill_factor: int, optional</span>
<span class="sd">        If `If `fast` is True, the `fill_factor` parameter of the SuperLU</span>
<span class="sd">        solver is set to this value (default is 1000).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    F : scipy.sparse matrix</span>
<span class="sd">        The fundamental matrix of the random walk. Element (i,j) holds the</span>
<span class="sd">        expected number of times the random walk will be in state j before</span>
<span class="sd">        absorption, when it starts from state i. For more information, check</span>
<span class="sd">        [1]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Doyle, Peter G., and J. Laurie Snell.</span>
<span class="sd">       Random walks and electric networks.</span>
<span class="sd">       Carus mathematical monographs 22 (2000).</span>
<span class="sd">       https://math.dartmouth.edu/~doyle/docs/walks/walks.pdf</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">F_inv</span> <span class="o">=</span> <span class="n">speye</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;csc&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">P</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">fast</span><span class="p">:</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="n">spilu</span><span class="p">(</span><span class="n">F_inv</span><span class="p">,</span> <span class="n">drop_tol</span><span class="o">=</span><span class="n">drop_tol</span><span class="p">,</span> <span class="n">fill_factor</span><span class="o">=</span><span class="n">fill_factor</span><span class="p">)</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">spinv</span><span class="p">(</span><span class="n">F_inv</span><span class="p">)</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">F</span></div>


<div class="viewcode-block" id="compute_personalized_transition_matrix"><a class="viewcode-back" href="../../reference/generated/absorbing_centrality.compute_personalized_transition_matrix.html#absorbing_centrality.compute_personalized_transition_matrix">[docs]</a><span class="k">def</span> <span class="nf">compute_personalized_transition_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.85</span><span class="p">,</span>
                                           <span class="n">restart_set</span><span class="o">=</span><span class="p">[</span><span class="n">SUPER_NODE</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Returns the transition matrix of the random walk with restarts.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : graph</span>

<span class="sd">    alpha : float, optional</span>
<span class="sd">        The probability of the random surfer to continue their walk (default is</span>
<span class="sd">        0.85).</span>

<span class="sd">    restart_set : list, optional</span>
<span class="sd">        The set of nodes to restart from. If not supplied, the restarts lead to</span>
<span class="sd">        the supernode (default is [SUPER_NODE]).</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : scipy.sparse.matrix</span>
<span class="sd">        The probability matrix for the random walk with restarts.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">has_supernode</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="ow">and</span> <span class="n">SUPER_NODE</span> <span class="ow">in</span> <span class="n">restart_set</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">CanonicalizationError</span><span class="p">(</span><span class="s">&#39;Cannot restart the random walks at the &#39;</span>
                                    <span class="s">&#39;supernode&#39;</span><span class="p">)</span>
    <span class="n">canonical_restart_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;canonical_map&#39;</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">restart_set</span><span class="p">]</span>
    <span class="n">restart_graph</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>
    <span class="n">restart_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">canonical_restart_set</span><span class="p">]</span>
    <span class="c"># add a self loop edge at the supernode, if there is one, to avoid division</span>
    <span class="c"># by zero when computing the transition matrix</span>
    <span class="k">if</span> <span class="n">has_supernode</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="c"># TODO Why is this edge added -- and then removed?</span>
        <span class="n">restart_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;canonical_map&#39;</span><span class="p">][</span><span class="n">SUPER_NODE</span><span class="p">],</span>
                              <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;canonical_map&#39;</span><span class="p">][</span><span class="n">SUPER_NODE</span><span class="p">]))</span>
    <span class="n">restart_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">restart_edges</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">compute_transition_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">P_restart</span> <span class="o">=</span> <span class="n">compute_transition_matrix</span><span class="p">(</span><span class="n">restart_graph</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">has_supernode</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="c"># remove the bottom right corner (the added self-loop)</span>
        <span class="n">P_restart</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">P_final</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">P</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">P_restart</span>
    <span class="c"># TODO do the transition probabilities from SUPER_NODE sum up to 1?</span>
    <span class="c"># Does it matter?</span>
    <span class="k">return</span> <span class="n">P_final</span></div>


<div class="viewcode-block" id="compute_transition_matrix"><a class="viewcode-back" href="../../reference/generated/absorbing_centrality.compute_transition_matrix.html#absorbing_centrality.compute_transition_matrix">[docs]</a><span class="k">def</span> <span class="nf">compute_transition_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Builds the random transition matrix P. The probability of going from</span>
<span class="sd">    node `i` to node`j` is equal to:</span>

<span class="sd">    .. math::</span>
<span class="sd">       P_{i,j} = \frac{1}{\text{degree}(i)}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : scipy.sparse matrix</span>
<span class="sd">        The random transition probability matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># TODO: make this function work for weighted graphs</span>
    <span class="n">adjacency</span> <span class="o">=</span> <span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">degrees</span> <span class="o">=</span> <span class="n">adjacency</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">inverse_degrees</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">degrees</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">diags</span><span class="p">(</span><span class="n">inverse_degrees</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">adjacency</span>
    <span class="k">return</span> <span class="n">P</span></div>


<span class="k">def</span> <span class="nf">_fast_update_fundamental_rows</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">row</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">row_previous</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Updates the rows of the fundamental matrix by adding an absorbing node,</span>
<span class="sd">    using the Woodbury identity.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    P : matrix</span>
<span class="sd">        The transition matrix of the graph.</span>

<span class="sd">    F : matrix</span>
<span class="sd">        The fundamental matrix of the graph after setting `row_previous` to be</span>
<span class="sd">        an absorbing node.</span>

<span class="sd">    row : int, optional</span>
<span class="sd">        The index of the row of `F` that will be set to be absorbing (default is</span>
<span class="sd">        0).</span>

<span class="sd">    row_previous : int, optional</span>
<span class="sd">        The index of the row of `P` that was set to be absorbing when</span>
<span class="sd">        computing `F` (default is 0).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    F_updated_row : matrix</span>
<span class="sd">        The new fundamental matrix, where row of the absorbing node has been</span>
<span class="sd">        updated.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_P</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_F</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c"># These are the rows of the matrix P that were used in order to compute F</span>
    <span class="n">previous_non_absorbing</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">row_previous</span><span class="p">)</span> <span class="o">+</span> <span class="nb">range</span><span class="p">(</span><span class="n">row_previous</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_P</span><span class="p">)</span>
    <span class="c"># Re-order the transition matrix P without row and column `row_previous`,</span>
    <span class="c"># such that the row (and column) that is absorbing will be first.</span>
    <span class="n">reordering</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">+</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">+</span> <span class="nb">range</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_F</span><span class="p">)</span>
    <span class="n">P_non_absorbing</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">previous_non_absorbing</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">previous_non_absorbing</span><span class="p">]</span>
    <span class="n">F_reordered</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">reordering</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">reordering</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">csc_matrix</span><span class="p">((</span><span class="n">n_F</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">P_non_absorbing</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">reordering</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">V</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">F_reordered</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">VF</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">F_reordered</span><span class="p">)</span>
    <span class="n">F_updated_row</span> <span class="o">=</span> <span class="n">F_reordered</span> <span class="o">-</span> <span class="n">F_reordered</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">VF</span><span class="p">)</span> <span class="o">/</span> <span class="n">y</span>
    <span class="k">return</span> <span class="n">F_updated_row</span>


<span class="k">def</span> <span class="nf">_fast_update_fundamental_columns</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">col_previous</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Updates the columns of the fundamental matrix by adding an absorbing</span>
<span class="sd">    node, using the Woodbury identity.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    P : matrix</span>
<span class="sd">        The transition matrix of the graph.</span>

<span class="sd">    F : matrix</span>
<span class="sd">        The fundamental matrix of the graph after setting `col_previous` to be</span>
<span class="sd">        an absorbing node. `F` needs to be the result of the</span>
<span class="sd">        _fast_update_fundamental_rows(), otherwise the order of the columns is</span>
<span class="sd">        wrong.</span>

<span class="sd">    col : int, optional</span>
<span class="sd">        The index of the column of `F` that corresponds to the new absorbing</span>
<span class="sd">        node (default is 0).</span>

<span class="sd">    col_previous : int, optional</span>
<span class="sd">        The index of the column of `P` that corresponds to the absorbing node</span>
<span class="sd">        when computing `F` (default is 0).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    F_updated_col : matrix</span>
<span class="sd">        The new fundamental matrix, in which the column of the absorbing</span>
<span class="sd">        node has been updated.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_P</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_F</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># These are the rows of the matrix P that were used in order to compute FP</span>
    <span class="n">previous_round_indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">col_previous</span><span class="p">)</span> <span class="o">+</span> <span class="nb">range</span><span class="p">(</span><span class="n">col_previous</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_P</span><span class="p">)</span>
    <span class="c"># Re-order the transition matrix P without row and column `col_previous`,</span>
    <span class="c"># such that the col (and row) that is absorbing will be first.</span>
    <span class="n">current_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">+</span> <span class="nb">range</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">+</span> <span class="nb">range</span><span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_F</span><span class="p">)</span>
    <span class="n">P_non_absorbing</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">previous_round_indices</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">previous_round_indices</span><span class="p">]</span>
    <span class="c"># F is the result of the _fast_update_fundamental_rows(), so it is already</span>
    <span class="c"># re-arranged in the way we want it.</span>
    <span class="n">F_reordered</span> <span class="o">=</span> <span class="n">F</span>
    <span class="n">U</span> <span class="o">=</span> <span class="n">P_non_absorbing</span><span class="p">[</span><span class="n">current_indices</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">T</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">F_reordered</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">FU</span> <span class="o">=</span> <span class="n">F_reordered</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
    <span class="n">F_updated_col</span> <span class="o">=</span> <span class="n">F_reordered</span> <span class="o">-</span> <span class="n">FU</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">F_reordered</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="n">y</span>
    <span class="k">return</span> <span class="n">F_updated_col</span>


<div class="viewcode-block" id="update_fundamental_matrix"><a class="viewcode-back" href="../../reference/generated/absorbing_centrality.update_fundamental_matrix.html#absorbing_centrality.update_fundamental_matrix">[docs]</a><span class="k">def</span> <span class="nf">update_fundamental_matrix</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="nb">next</span><span class="p">,</span> <span class="n">previous</span><span class="p">,</span> <span class="n">previous_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                              <span class="n">node_order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Applies Woodbury&#39;s formula to update the fundamental matrix in order to</span>
<span class="sd">    avoid doing an inversion.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    P : matrix</span>
<span class="sd">        The transition matrix of the graph, where `previous` is non absorbing.</span>

<span class="sd">    F : matrix</span>
<span class="sd">        The fundamental matrix of the graph after setting the node `previous`</span>
<span class="sd">        as an absorbing node.</span>

<span class="sd">    next : int</span>
<span class="sd">        The node that will be set as absorbing next. The result of this call</span>
<span class="sd">        will result in a fundamental matrix where `next` is an absorbing node.</span>

<span class="sd">    previous : int</span>
<span class="sd">        The node that was set as absorbing when computing F.</span>

<span class="sd">    previous_index : int, optional</span>
<span class="sd">        The row/col index of node `previous` in P (default is 0).</span>

<span class="sd">    node_order : list, optional</span>
<span class="sd">        The nodes that corresponds to the rows/cols of `P`, in order. If not</span>
<span class="sd">        supplied, the order is considered to be [0, .. , n_P - 1], where</span>
<span class="sd">        n_P is the the number of rows/cols in `P`.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P_updated : matrix</span>
<span class="sd">        The new transition matrix, where `previous` is absorbing.</span>

<span class="sd">    F_updated : matrix</span>
<span class="sd">        The fundamental matrix after adding `previous` and `next` in the set of</span>
<span class="sd">        absorbing nodes.</span>

<span class="sd">    node_order_updated : list</span>
<span class="sd">        The new order of the non absorbing nodes in the `F_new`.</span>

<span class="sd">    next_index : int</span>
<span class="sd">        The row/col index of the node `next`, that we just set as absorbing,</span>
<span class="sd">        in `P_new`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_P</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_F</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">node_order</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">node_order</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">n_P</span><span class="p">)</span>
        <span class="n">node_order</span> <span class="o">=</span> <span class="n">node_order</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span> <span class="o">+</span> <span class="nb">range</span><span class="p">(</span><span class="n">previous</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_P</span><span class="p">)]</span>
        <span class="n">previous_index</span> <span class="o">=</span> <span class="n">previous</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">node_order</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">node_order</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">node_order</span><span class="p">)</span>
    <span class="c"># We need to find which row/column corresponds to the node `next`</span>
    <span class="n">next_index</span> <span class="o">=</span> <span class="n">argwhere</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">node_order</span><span class="p">)</span> <span class="o">==</span> <span class="nb">next</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">node_order</span> <span class="o">=</span> <span class="n">node_order</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">next_index</span><span class="p">)</span> <span class="o">+</span> <span class="nb">range</span><span class="p">(</span><span class="n">next_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_F</span><span class="p">)]</span>
    <span class="n">row_update</span> <span class="o">=</span> <span class="n">_fast_update_fundamental_rows</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">row</span><span class="o">=</span><span class="n">next_index</span><span class="p">,</span>
                                               <span class="n">row_previous</span><span class="o">=</span><span class="n">previous_index</span><span class="p">)</span>
    <span class="n">col_update</span> <span class="o">=</span> <span class="n">_fast_update_fundamental_columns</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">row_update</span><span class="p">,</span>
                                                  <span class="n">col</span><span class="o">=</span><span class="n">next_index</span><span class="p">,</span>
                                                  <span class="n">col_previous</span><span class="o">=</span><span class="n">previous_index</span><span class="p">)</span>
    <span class="n">P_updated</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">previous_index</span><span class="p">)</span> <span class="o">+</span>
                  <span class="nb">range</span><span class="p">(</span><span class="n">previous_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">:]</span> \
                 <span class="p">[:,</span> <span class="nb">range</span><span class="p">(</span><span class="n">previous_index</span><span class="p">)</span> <span class="o">+</span>
                  <span class="nb">range</span><span class="p">(</span><span class="n">previous_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="n">F_updated</span> <span class="o">=</span> <span class="n">col_update</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">node_order_updated</span> <span class="o">=</span> <span class="n">node_order</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">P_updated</span><span class="p">,</span> <span class="n">F_updated</span><span class="p">,</span> <span class="n">node_order_updated</span><span class="p">,</span> <span class="n">next_index</span></div>


<div class="viewcode-block" id="add_supernode"><a class="viewcode-back" href="../../reference/generated/absorbing_centrality.add_supernode.html#absorbing_centrality.add_supernode">[docs]</a><span class="k">def</span> <span class="nf">add_supernode</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Adds a supernode to the graph and connects it with directed edges to the</span>
<span class="sd">    query nodes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The graph in which we want to add a supernode.</span>

<span class="sd">    query : list, default is None</span>
<span class="sd">        The list of nodes that the supernode will be connected to. If `query`</span>
<span class="sd">        is None, the supernode will be connected to all the nodes in `G`. These</span>
<span class="sd">        new edges will be directed.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NetworkX graph</span>
<span class="sd">        A directed graph with the supernode, and the new edges, added. The</span>
<span class="sd">        attributes of the graph, i.e. &#39;label_map&#39; and &#39;canonical_map&#39;, are also</span>
<span class="sd">        updated (or created if the input graph was not canonicalized) to</span>
<span class="sd">        reflect the new node.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">has_supernode</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">G</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">query</span><span class="p">:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_canonical</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">canonical_relabel_nodes</span><span class="p">(</span><span class="n">keep_largest_component</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">query</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;canonical_map&#39;</span><span class="p">][</span><span class="n">q</span><span class="p">]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">query</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">SUPER_NODE</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;canonical_map&#39;</span><span class="p">]:</span>
        <span class="c"># make sure that SUPER_NODE is the last node returned by nodes()</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;label_map&#39;</span><span class="p">][</span><span class="n">nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="n">SUPER_NODE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CanonicalizationError</span><span class="p">(</span><span class="s">&#39;Supernode is not the last node.&#39;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;canonical_map&#39;</span><span class="p">][</span><span class="n">SUPER_NODE</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;label_map&#39;</span><span class="p">][</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">SUPER_NODE</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">query</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="has_supernode"><a class="viewcode-back" href="../../reference/generated/absorbing_centrality.has_supernode.html#absorbing_centrality.has_supernode">[docs]</a><span class="k">def</span> <span class="nf">has_supernode</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks if there exist a supernode in the graph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    has_supernode : bool</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_canonical</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="ow">and</span> <span class="n">SUPER_NODE</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;canonical_map&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span></div>


<div class="viewcode-block" id="absorbing_centrality_inversion"><a class="viewcode-back" href="../../reference/generated/absorbing_centrality.absorbing_centrality_inversion.html#absorbing_centrality.absorbing_centrality_inversion">[docs]</a><span class="k">def</span> <span class="nf">absorbing_centrality_inversion</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">team</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">with_restarts</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                   <span class="n">alpha</span><span class="o">=</span><span class="mf">0.85</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the absorbing centrality of a team using a fast inversion with</span>
<span class="sd">    SuperLU solver.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The graph on which to compute the centrality.</span>

<span class="sd">    team : list</span>
<span class="sd">        The team of nodes, whose centrality to compute.</span>

<span class="sd">    query : list, optional</span>
<span class="sd">        The set of query nodes to use for the random walks. If None (default)</span>
<span class="sd">        or empty, the query set is equal to the set of all nodes in the graph.</span>

<span class="sd">    with_restarts : bool, optional</span>
<span class="sd">        If True, restarts the random surfer to the the query set (default is</span>
<span class="sd">        False).</span>

<span class="sd">    alpha : float, optional</span>
<span class="sd">        The probability of the random surfer to continue (default is 0.85).</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    score : float</span>
<span class="sd">        The absorbing centrality score.</span>


<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Both `team` and `query` should  use the original node names.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_canonical</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">canonical_relabel_nodes</span><span class="p">(</span><span class="n">keep_largest_component</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">canonical_query</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;canonical_map&#39;</span><span class="p">][</span><span class="n">q</span><span class="p">]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">query</span><span class="p">]</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">add_supernode</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">canonical_query</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">with_restarts</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">compute_personalized_transition_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">compute_transition_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">team_ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;canonical_map&#39;</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">team</span><span class="p">]</span>
    <span class="n">non_absorbing_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">team_ind</span><span class="p">]</span>
    <span class="n">P_non_absorbing</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">non_absorbing_nodes</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">non_absorbing_nodes</span><span class="p">]</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">compute_fundamental_matrix</span><span class="p">(</span><span class="n">P_non_absorbing</span><span class="p">)</span>
    <span class="n">row_sums</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">score</span> <span class="o">=</span> <span class="n">row_sums</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">score</span></div>


<div class="viewcode-block" id="absorbing_centrality"><a class="viewcode-back" href="../../reference/generated/absorbing_centrality.absorbing_centrality.html#absorbing_centrality.absorbing_centrality">[docs]</a><span class="k">def</span> <span class="nf">absorbing_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">team</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
                         <span class="n">max_iterations</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">with_restarts</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                         <span class="n">alpha</span><span class="o">=</span><span class="mf">0.85</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Compute the absorbing centrality of a team. The algorithm works by</span>
<span class="sd">    iteratively computing the powers of the non-absorbing submatrix of the</span>
<span class="sd">    transition matrix P.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : NetworkX graph</span>
<span class="sd">        The graph on which to compute the centrality.</span>

<span class="sd">    team : list</span>
<span class="sd">        The team of nodes, whose centrality to compute.</span>

<span class="sd">    query : list, optional</span>
<span class="sd">        The set of query nodes to use for the random walks. If None (default)</span>
<span class="sd">        or empty, the query set is equal to the set of all nodes in the graph.</span>

<span class="sd">    P : matrix, optional</span>
<span class="sd">        The precomputed transition matrix of the graph (default is None).</span>

<span class="sd">    epsilon : float, optional</span>
<span class="sd">        The iterative algorithm stops when the error between the centrality</span>
<span class="sd">        computed by two successive iterations falls below epsilon (default is</span>
<span class="sd">        1e-5).</span>

<span class="sd">    max_iterations : int, optional</span>
<span class="sd">        The upper limit to the number of iteratios of the algorithm (default</span>
<span class="sd">        is None).</span>

<span class="sd">    with_restarts : bool, optional</span>
<span class="sd">        If True, restarts the random surfer to the the query set (default is</span>
<span class="sd">        False).</span>

<span class="sd">    alpha : float, optional</span>
<span class="sd">        The probability of the random surfer to continue (default is 0.85).</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    score : float</span>
<span class="sd">        The absorbing centrality score.</span>


<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Both `team` and `query` should  use the original node names.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_canonical</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">canonical_relabel_nodes</span><span class="p">(</span><span class="n">keep_largest_component</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">query</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">canonical_query</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;canonical_map&#39;</span><span class="p">][</span><span class="n">q</span><span class="p">]</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">query</span><span class="p">]</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">add_supernode</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">canonical_query</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">P</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">with_restarts</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">compute_personalized_transition_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">P</span> <span class="o">=</span> <span class="n">compute_transition_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">team_ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s">&#39;canonical_map&#39;</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">team</span><span class="p">]</span>
    <span class="n">non_absorbing_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">team_ind</span><span class="p">]</span>
    <span class="n">P_non_absorbing</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">non_absorbing_nodes</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">non_absorbing_nodes</span><span class="p">]</span>

    <span class="n">step</span> <span class="o">=</span> <span class="n">maxint</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">G</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">(),</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">X_current</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">non_absorbing_nodes</span><span class="p">]</span>
    <span class="c"># Don&#39;t count the first jump, from the supernode to the queries</span>
    <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="n">epsilon</span><span class="p">:</span>
        <span class="n">X_current</span> <span class="o">=</span> <span class="n">P_non_absorbing</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X_current</span><span class="p">)</span>
        <span class="c"># Disregard the steps from the supernode to the queries</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">X_current</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">X_current</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="n">step</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">max_iterations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">max_iterations</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">score</span></div>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015 Charalampos Mavroforakis.
      Last updated on Sep 04, 2015.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>