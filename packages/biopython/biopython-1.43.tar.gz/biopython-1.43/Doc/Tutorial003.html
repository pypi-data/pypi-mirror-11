<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.07">
<TITLE>
Quick Start -- What can you do with Biopython?
</TITLE>
</HEAD>
<BODY >
<A HREF="Tutorial002.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Tutorial004.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1><A NAME="htoc6">Chapter&nbsp;2</A>&nbsp;&nbsp;Quick Start -- What can you do with Biopython?</H1>
This section is designed to get you started quickly with Biopython, and to give a general overview of what is available and how to use it. All of the examples in this section assume that you have some general working knowledge of python, and that you have successfully installed Biopython on your system. If you think you need to brush up on your python, the main python web site provides quite a bit of free documentation to get started with (<A HREF="http://www.python.org/doc/"><TT>http://www.python.org/doc/</TT></A>). <BR>
<BR>
Since much biological work on the computer involves connecting with databases on the internet, some of the examples will also require a working internet connection in order to run. <BR>
<BR>
Now that that is all out of the way, let's get into what we can do with Biopython.<BR>
<BR>
<A NAME="toc4"></A>
<H2><A NAME="htoc7">2.1</A>&nbsp;&nbsp;General overview of what Biopython provides</H2>
As mentioned in the introduction, Biopython is a set of libraries to provide the ability to deal with ''things'' of interest to biologists working on the computer. In general this means that you will need to have at least some programming experience (in python, of course!) or at least an interest in learning to program. Biopython's job is to make your job easier as a programmer by supplying reusable libraries so that you can focus on answering your specific question of interest, instead of focusing on the internals of parsing a particular file format (of course, if you want to help by writing a parser that doesn't exist and contributing it to Biopython, please go ahead!). So Biopython's job is to make you happy!<BR>
<BR>
One thing to note about Biopython is that it often provides multiple ways of ``doing the same thing.'' To me, this can be frustrating since I often way to just know the one right way to do something. However, this is also a real benefit because it gives you lots of flexibility and control over the libraries. The tutorial helps to show you the common or easy ways to do things so that you can just make things work. To learn more about the alternative possibilities, look into the Cookbook section (which tells you some cools tricks and tips) and the Advanced section (which provides you with as much detail as you'd ever want to know!). <BR>
<BR>
<A NAME="toc5"></A>
<H2><A NAME="htoc8">2.2</A>&nbsp;&nbsp;Working with sequences</H2>
<A NAME="sec:sequences"></A>
Disputedly (of course!), the central object in bioinformatics is the sequence. Thus, we'll start with the Biopython mechanisms for dealing with sequences. When I think of a sequence the first thing that pops into my mind is a string of letters:<CODE> 'AGTACACTGGT'</CODE> which seems natural since this is the most common way that sequences are seen in biological file formats. However, a simple string of letters by itself is also very uninformative -- is it a DNA or protein sequence (okay, a protein with a lot of Alanines, Glycines, Cysteines and Threonines!), what type of organism did it come from, what is so interesting about it, and so on. The challenge in designing a sequence interface is to pick a representation that is informative enough to take into account the more complex information, yet is as lightweight and easy to work with as just a simple sequence.<BR>
<BR>
The approach taken in the Biopython sequence class is to utilize a class that holds more complex information, yet can be manipulated as if it were a simple string. This is accomplished by utilizing operator overloading to make manipulating a sequence object feel like manipulating a python string. The sequence class, referred to simply as Seq, is defined in the file <CODE>Bio/Seq.py</CODE>. Let's look at the Seq class deeper to see what it has to offer.<BR>
<BR>
A biopython Seq object has two important attributes:
<OL type=1><LI><CODE>data</CODE> -- as the name implies, this is the actual sequence data string of the sequence.<BR>
<BR>
<LI><CODE>alphabet</CODE> -- an object describing what the individual characters making up the string ``mean'' and how they should be interpreted.</OL>
Clearly the alphabet object is the important thing that is making the Seq object more than just a string. The currently available alphabets for Biopython are defined in the <CODE>Bio/Alphabet</CODE> module. We'll use the IUPAC alphabets (<A HREF="http://www.chem.qmw.ac.uk/iupac/"><TT>http://www.chem.qmw.ac.uk/iupac/</TT></A>) here to deal with some of our favorite objects: DNA, RNA and Proteins. <BR>
<BR>
<CODE>Bio/Alphabet/IUPAC.py</CODE> provides basic definitions for proteins, DNA and RNA, but additionally provides the ability to extend and customize the basic definitions. For instance, for proteins, there is a basic IUPACProtein class, but there is an additional ExtendedIUPACProtein class providing for the additional elements ``Asx'' (asparagine or aspartic acid), ``Sec'' (selenocysteine), and ``Glx'' (glutamine or glutamic acid). For DNA you've got choices of IUPACUnambiguousDNA, which provides for just the basic letters, IUPACAmbiguousDNA (which provides for ambiguity letters for every possible situation) and ExtendedIUPACDNA, which allows letters for modified bases. Similarly, RNA can be represented by IUPACAmbiguousRNA or IUPACUnambiguousRNA.<BR>
<BR>
The advantages of having an alphabet class are two fold. First, this gives an idea of the type of information the <CODE>data</CODE> object contains. Secondly, this provides a means of constraining the information you have in the data object, as a means of type checking.<BR>
<BR>
Now that we know what we are dealing with, let's look at how to utilize this class to do interesting work.<BR>
<BR>
First, create a Sequence object from a string of information we've got. We'll create an unambiguous DNA object:
<PRE>
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; my_alpha = IUPAC.unambiguous_dna
&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; my_seq = Seq('GATCGATGGGCCTATATAGGATCGAAAATCGC', my_alpha)
&gt;&gt;&gt; print my_seq
Seq('GATCGATGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
</PRE>
Even though this is a sequence object, we can deal with it in some ways as if it were a normal python string. For instance, let's get a slice of the sequence.
<PRE>
&gt;&gt;&gt; my_seq[4:12]
Seq('GATGGGCC', IUPACUnambiguousDNA())
</PRE>
Two things are interesting to note. First, this follows the normal conventions for python sequences. So the first element of the sequence is 0 (which is normal for computer science, but not so normal for biology). When you do a slice the first item is included (i.&nbsp;e.&nbsp;4 in this case) and the last is excluded (12 in this case), which is the way things work in python, but of course not necessarily the way everyone in the world would expect. The main goal is to stay consistent with what python does. The second thing to notice is that the slice is performed on the sequence data string, but the new object produced retains the alphabet information from the original Seq object.<BR>
<BR>
You can treat the Seq object like the string in many ways:
<PRE>
&gt;&gt;&gt; len(my_seq)
32
&gt;&gt;&gt; new_seq = my_seq[0:5]
&gt;&gt;&gt; print new_seq
Seq('GATCG', IUPACUnambiguousDNA())
&gt;&gt;&gt; my_seq + new_seq
Seq('GATCGATGGGCCTATATAGGATCGAAAATCGCGATCG', IUPACUnambiguousDNA())
&gt;&gt;&gt; my_seq[5]
'A'
&gt;&gt;&gt; my_seq == new_seq
True
</PRE>
In all of the operations, the alphabet property is maintained. This is very useful in case you accidentally end up trying to do something weird like add a protein sequence and a DNA sequence:
<PRE>
&gt;&gt;&gt; protein_seq = Seq('EVRNAK', IUPAC.protein)
&gt;&gt;&gt; dna_seq = Seq('ACGT', IUPAC.unambiguous_dna)
&gt;&gt;&gt; protein_seq + dna_seq
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "/usr/local/lib/python1.6/site-packages/Bio/Seq.py", line 42, in __add__
    raise TypeError, ("incompatable alphabets", str(self.alphabet),
TypeError: ('incompatable alphabets', 'IUPACProtein()', 'IUPACUnambiguousDNA()')
</PRE>
And if you are really just need the string to insert into something, this is very easy to extract:
<PRE>
&gt;&gt;&gt; my_seq.tostring()
'GATCGATGGGCCTATATAGGATCGAAAATCGC'
</PRE>
The sequence object is not mutable by default, since in many biological applications you want to ensure you are not changing your data:
<PRE>
&gt;&gt;&gt; my_seq[5] = 'G'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
AttributeError: 'Seq' instance has no attribute '__setitem__'
</PRE>
However, you can convert it into a mutable sequence and do pretty much anything you want with it:
<PRE>
&gt;&gt;&gt; mutable_seq = my_seq.tomutable()
&gt;&gt;&gt; print mutable_seq
MutableSeq('GATCGATGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
&gt;&gt;&gt; mutable_seq[5] = 'T'
&gt;&gt;&gt; print mutable_seq
MutableSeq('GATCGTTGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
&gt;&gt;&gt; mutable_seq.remove('T')
&gt;&gt;&gt; print mutable_seq
MutableSeq('GACGTTGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
&gt;&gt;&gt; mutable_seq.reverse()
&gt;&gt;&gt; print mutable_seq
MutableSeq('CGCTAAAAGCTAGGATATATCCGGGTTGCAG', IUPACUnambiguousDNA())
</PRE>
Now that the nature of the sequence object makes some sense, the next
thing to look at is what kind of things we can do with a sequence. The
<CODE>Bio</CODE> directory contains two useful modules to transcribe and
translate a sequence object. These tools work based on the alphabet of
the sequence. For instance, let's supposed we want to transcribe our
<CODE>my_seq</CODE> object. Remember that this contains an unambiguous
alphabet, so to transcribe we would do the following:
<PRE>
&gt;&gt;&gt; from Bio import Transcribe
&gt;&gt;&gt; transcriber = Transcribe.unambiguous_transcriber
&gt;&gt;&gt; my_rna_seq = transcriber.transcribe(my_seq)
&gt;&gt;&gt; print my_rna_seq
Seq('GAUCGAUGGGCCUAUAUAGGAUCGAAAAUCGC', IUPACUnambiguousRNA())
</PRE>
The alphabet of the new RNA Seq object is created for free, so again, dealing with a Seq object is no more difficult then dealing with a simple string.<BR>
<BR>
You can also reverse transcribe RNA sequences:
<PRE>
&gt;&gt;&gt; transcriber.back_transcribe(my_rna_seq)
Seq('GATCGATGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
</PRE>
To translate our DNA object we have quite a few choices. First, we can use any number of translation tables depending on what we know about our DNA sequence. The translation tables available in biopython were taken from information at <A HREF="ftp://ftp.ncbi.nlm.nih.gov/entrez/misc/data/gc.prt"><TT>ftp://ftp.ncbi.nlm.nih.gov/entrez/misc/data/gc.prt</TT></A>. So, you have tons of choices to pick from. For this, let's just focus on two choices: the Standard translation table, and the Translation table for Vertebrate Mitochondrial DNA. These tables are labeled with id numbers 1 and 2, respectively. Now that we know what tables we are looking to get, we're all set to perform a basic translation. First, we need to get our translators that use these tables. Since we are still dealing with our unambiguous DNA object, we want to fetch translators that take this into account:
<PRE>
&gt;&gt;&gt; from Bio import Translate
&gt;&gt;&gt; standard_translator = Translate.unambiguous_dna_by_id[1] 
&gt;&gt;&gt; mito_translator = Translate.unambiguous_dna_by_id[2]
</PRE>
Once we've got the proper translators, it's time to go ahead and translate a sequence:
<PRE>
&gt;&gt;&gt; my_seq = Seq('GCCATTGTAATGGGCCGCTGAAAGGGTGCCCGA', IUPAC.unambiguous_dna)
&gt;&gt;&gt; standard_translator.translate(my_seq)
Seq('AIVMGR*KGAR', IUPACProtein())
&gt;&gt;&gt; mito_translator.translate(my_seq)
Seq('AIVMGRWKGAR', IUPACProtein())
</PRE>
Notice that the default translation will just go ahead and proceed blindly through a stop codon. If you are aware that you are translating some kind of open reading frame and want to just see everything up until the stop codon, this can be easily done with the <CODE>translate_to_stop</CODE> function:
<PRE>
&gt;&gt;&gt; standard_translator.translate_to_stop(my_seq)
Seq('AIVMGR', IUPACProtein())
</PRE>
Similar to the transcriber, it is also possible to reverse translate a protein into a DNA sequence:
<PRE>
&gt;&gt;&gt; my_protein = Seq('AVMGRWKGGRAAG', IUPAC.protein)
&gt;&gt;&gt; standard_translator.back_translate(my_protein)
Seq('GCTGTTATGGGTCGTTGGAAGGGTGGTCGTGCTGCTGGT', IUPACUnambiguousDNA())
</PRE>
This covers the basic features and uses of the Biopython sequence class. There is a more detailed description of the design ideas behind the sequence class in the Advanced section of this tutorial. This class is still under development and comments on the design and use are, of course, very welcome. Now that you've got some idea of what it is like to interact with the Biopython libraries, it's time to delve into the fun, fun world of dealing with biological file formats!<BR>
<BR>
<A NAME="toc6"></A>
<H2><A NAME="htoc9">2.3</A>&nbsp;&nbsp;A usage example</H2>
<A NAME="sec:orchids"></A>
Before we jump right into parsers and everything else to do with Biopython, let's set up an example to motivate everything we do and make life more interesting. After all, if there wasn't any biology in this tutorial, why would you want you read it?<BR>
<BR>
Since I love plants, I think we're just going to have to have a plant based example (sorry to all the fans of other organisms out there!). Having just completed a recent trip to our local greenhouse, we've suddenly developed an incredible obsession with Lady Slipper Orchids (if you wonder why, have a look at some <A HREF="http://www.flickr.com/search/?q=lady+slipper+orchid&s=int&z=t">Lady Slipper Orchids photos on Flickr</A>, or try a <A HREF="http://images.google.com/images?q=lady%20slipper%20orchid">Google Image Search</A>). Of course, orchids are not only beautiful to look at, they are also extremely interesting for people studying evolution and systematics. So we're thinking about writing a little proposal to do a molecular study of Lady Slipper evolution and would like to see what kind of research has already been done and how we can add to that.<BR>
<BR>
After a little bit of reading up we discover that the Lady Slipper Orchids are in the Orchidaceae family and the Cypripedioideae sub-family and are made up of 5 genera: <EM>Cypripedium</EM>, <EM>Paphiopedilum</EM>, <EM>Phragmipedium</EM>, <EM>Selenipedium</EM> and <EM>Mexipedium</EM>.<BR>
<BR>
That gives us enough to get started delving for more information. So, let's look at how the Biopython tools can help us. We'll start with sequence parsing in Section&nbsp;<A HREF="#sec:sequence-parsing">2.4</A>, but the orchids will be back later on as well - for example we'll extra data from Swiss-Prot from certain orchid proteins in Section&nbsp;<A HREF="Tutorial005.html#sec:swiss_prot">4.1</A>, search PubMed for papers about orchids in Section&nbsp;<A HREF="Tutorial005.html#sec:pub_med">4.2</A>, extract sequence data from GenBank in Section&nbsp;<A HREF="Tutorial005.html#genbank-retrieval">4.3.1</A>, and work with ClustalW multiple sequence alignments of orchid proteins in Section&nbsp;<A HREF="Tutorial005.html#sec:align_clustal">4.4.1</A>.<BR>
<BR>
<A NAME="toc7"></A>
<H2><A NAME="htoc10">2.4</A>&nbsp;&nbsp;Parsing sequence file formats</H2>
<A NAME="sec:sequence-parsing"></A>
A large part of much bioinformatics work involves dealing with the many types of file formats designed to hold biological data. These files are loaded with interesting biological data, and a special challenge is parsing these files into a format so that you can manipulate them with some kind of programming language. However the task of parsing these files can be frustrated by the fact that the formats can change quite regularly, and that formats may contain small subtleties which can break even the most well designed parsers. <BR>
<BR>
We are going to introduce the <CODE>Bio.SeqIO</CODE> module, available in Biopython 1.43 and later. If you are using an older version of Biopython we encourage you to update (or find an old edition of this tutorial!).<BR>
<BR>
We'll start with an online search for our friends, the lady slipper orchids. Let's just take a look through the nucleotide databases at NCBI, using an Entrez online search (<A HREF="http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?db=Nucleotide"><TT>http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?db=Nucleotide</TT></A>) for everything mentioning the text Cypripedioideae (this is the subfamily of lady slipper orchids). When this tutorial was originally written, this search gave us only 94 hits, which we saved as a FASTA formatted text file (<A HREF="examples/ls_orchid.fasta">ls_orchid.fasta</A>; also available online <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.fasta">here</A>) and as a GenBank formatted text file (<A HREF="examples/ls_orchid.gbk">ls_orchid.gbk</A>; also available online <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.gbk">here</A>).<BR>
<BR>
If you run the search today, you'll get hundreds of results! When following the tutorial, if you want to see the same list of genes, just download the two files above or copy them from <CODE>docs/examples/</CODE> in the Biopython source code. In Section&nbsp;<A HREF="#sec:connecting-with-biological-databases">2.5</A> we will look at how to do a search like this from within python.<BR>
<BR>

<H3><A NAME="htoc11">2.4.1</A>&nbsp;&nbsp;Simple FASTA parsing example</H3>
<A NAME="sec:fasta-parsing"></A>
If you open the lady slipper orchids FASTA file in your favourite text editor, you'll see that the file starts like this:
<PRE>
&gt;gi|2765658|emb|Z78533.1|CIZ78533 C.irapeanum 5.8S rRNA gene and ITS1 and ITS2 DNA
CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGGAATAAACGATCGAGTG
AATCCGGAGGACCGGTGTACTCAGCTCACCGGGGGCATTGCTCCCGTGGTGACCCTGATTTGTTGTTGGG
...
</PRE>
It contains 94 records, each has a line starting with ``&gt;'' (greater-than symbol) followed by the sequence on one or more lines. Now try this in python:
<PRE>
from Bio import SeqIO
handle = open("ls_orchid.fasta")
for seq_record in SeqIO.parse(handle, "fasta") :
    print seq_record.id
    print seq_record.seq
    print len(seq_record.seq)
handle.close()
</PRE>
You should get something like this on your screen:
<PRE>
gi|2765658|emb|Z78533.1|CIZ78533
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGGAATAAA ...', SingleLetterAlphabet())
740
...
gi|2765564|emb|Z78439.1|PBZ78439
Seq('CATTGTTGAGATCACATAATAATTGATCGAGTTAATCTGGAGGATCTGTTTACTTTGGTC ...', SingleLetterAlphabet())
592
</PRE>
Notice that the FASTA format does not specify the alphabet, so <CODE>Bio.SeqIO</CODE> has defaulted to the rather generic <CODE>SingleLetterAlphabet()</CODE> rather than something DNA specific.<BR>
<BR>

<H3><A NAME="htoc12">2.4.2</A>&nbsp;&nbsp;Simple GenBank parsing example</H3>
Now let's load the GenBank file instead - notice that the code to do this is almost identical to the snippet used above for a FASTA file.
<PRE>
from Bio import SeqIO
handle = open("ls_orchid.gbk")
for seq_record in SeqIO.parse(handle, "genbank") :
    print seq_record.id
    print seq_record.seq
    print len(seq_record.seq)
handle.close()
</PRE>
This should give:
<PRE>
Z78533.1
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGGAATAAA ...', IUPACAmbiguousDNA())
740
...
Z78439.1
Seq('CATTGTTGAGATCACATAATAATTGATCGAGTTAATCTGGAGGATCTGTTTACTTTGGTC ...', IUPACAmbiguousDNA())
592
</PRE>
This time <CODE>Bio.SeqIO</CODE> has been able to choose a sensible alphabet, Ambiguous DNA. You'll also notice that a shorter string has been used as the <CODE>seq_record.id</CODE> in this case.<BR>
<BR>

<H3><A NAME="htoc13">2.4.3</A>&nbsp;&nbsp;Iterating over the records in a sequence file</H3>
In the above examples, we have used a for loop to iterate over all the records in the file one by one. You can use the for loop for all sorts of python objects (including lists, tuples and strings) which support the iteration interface.<BR>
<BR>
The object returned by <CODE>Bio.SeqIO</CODE> is actually an iterator which returns SeqRecord objects. You get to see each record in turn, but once and only once. The plus point is that an iterator can save you memory when dealing with large files.<BR>
<BR>
Note that you can also use the <CODE>next</CODE> method of an iterator to step through the entries, like this:
<PRE>
from Bio import SeqIO
handle = open("ls_orchid.fasta")
record_iterator = SeqIO.parse(handle, "fasta")

first_record = record_iterator.next()
print first_record.id
print first_record.description

handle.close()
</PRE>
The above style is useful if your sequence files have only one record.<BR>
<BR>

<H3><A NAME="htoc14">2.4.4</A>&nbsp;&nbsp;Getting a list of the records in a sequence file</H3>
In the previous section we talked about the fact that <CODE>Bio.SeqIO</CODE> gives you a SeqRecord iterator, and that you get the records one by one. Very often you need to be able to access the records in any order - and for this we use the built-in python function <CODE>list</CODE> like so:
<PRE>
from Bio import SeqIO
handle = open("ls_orchid.gbk")
records = list(SeqIO.parse(handle, "genbank"))
handle.close()

print "Found %i records" % len(records)

print "The last record"
last_record = records[-1] #using python's list tricks
print last_record.id
print last_record.seq
print len(last_record.seq)

print "The first record"
first_record = records[0] #remember, python counts from zero
print first_record.id
print first_record.seq
print len(first_record.seq)
</PRE>
Giving:
<PRE>
Found 94 records
The last record
Z78439.1
Seq('CATTGTTGAGATCACATAATAATTGATCGAGTTAATCTGGAGGATCTGTTTACTTTGGTC ...', IUPACAmbiguousDNA())
592
The first record
Z78533.1
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGGAATAAA ...', IUPACAmbiguousDNA())
740
</PRE>
You can of course still use a for loop with a list of SeqRecord objects. Using a list is much more flexible, but does need more memory to hold all the records at once.<BR>
<BR>

<H3><A NAME="htoc15">2.4.5</A>&nbsp;&nbsp;Sequence files as Dictionaries</H3>
The next thing that we'll do with our ubiquitous orchid files is to show how to index them and access them like a database. This is very useful for large files where you only need to access certain elements of the file, and makes for a nice quick 'n dirty database.<BR>
<BR>
You can use the function <CODE>SeqIO.to_dict</CODE> to make a SeqRecord dictionary (in memory). By default this will use each record's identifier (i.e. the <CODE>.id</CODE> attribute) as the key. Let's try this using our GenBank file:
<PRE>
from Bio import SeqIO
handle = open("ls_orchid.gbk")
orchid_dict = SeqIO.to_dict(SeqIO.parse(handle, "genbank"))
handle.close()
</PRE>
Since this variable <CODE>orchid_dict</CODE> is a dictionary, we can look at all of the keys we have available:
<PRE>
&gt;&gt;&gt; print orchid_dict.keys()
['Z78484.1', 'Z78464.1', 'Z78455.1', 'Z78442.1', 'Z78532.1', 'Z78453.1', ..., 'Z78471.1']
</PRE>
We can access a single <CODE>SeqRecord</CODE> object via the keys and manipulate the object as normal:
<PRE>
&gt;&gt;&gt; seq_record = orchid_dict["Z78475.1"]
&gt;&gt;&gt; print seq_record.description
P.supardii 5.8S rRNA gene and ITS1 and ITS2 DNA
&gt;&gt;&gt; print seq_record.seq
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGTTGAGATCACATAATAAT ...', IUPACAmbiguousDNA())
</PRE>
That easily, we have created a database of our GenBank file that will spit out <CODE>SeqRecord</CODE> objects. Now let's try this for the FASTA file instead:
<PRE>
from Bio import SeqIO
handle = open("ls_orchid.fasta")
orchid_dict = SeqIO.to_dict(SeqIO.parse(handle, "fasta"))
handle.close()
print orchid_dict.keys()
</PRE>
This time the keys are:
<PRE>
['gi|2765596|emb|Z78471.1|PDZ78471', 'gi|2765646|emb|Z78521.1|CCZ78521', ...
 ..., 'gi|2765613|emb|Z78488.1|PTZ78488', 'gi|2765583|emb|Z78458.1|PHZ78458']
</PRE>
You should recognised these strings from when we parsed the FASTA file earlier in Section&nbsp;<A HREF="#sec:fasta-parsing">2.4.1</A>. Suppose you would rather have something else as the keys - like the accesion numbers. This brings us nicely to <CODE>SeqIO.to_dict</CODE>'s optional argument <CODE>key_function</CODE>, which lets you define what to use as the dictionary key for your records.<BR>
<BR>
First you must write your own function to return the key you want (as a string) when given a SeqRecord object. In general, the details of function will depend on the sort of input records you are dealing with. But for our orchids, we can just split up the record's identifier using the ``pipe'' character (the vertical line) and return the fourth entry (field three):
<PRE>
def get_accession(record) :
    """"Given a SeqRecord, return the accession number as a string
    
    e.g. "gi|2765613|emb|Z78488.1|PTZ78488" -&gt; "Z78488.1"
    """
    parts = record.id.split("|")
    assert len(parts) == 5 and parts[0] == "gi" and parts[2] == "emb"
    return parts[3]
</PRE>
Then we can give this function to the <CODE>SeqIO.to_dict</CODE> function to use in building the dictionary:
<PRE>
from Bio import SeqIO
handle = open("ls_orchid.fasta")
orchid_dict = SeqIO.to_dict(SeqIO.parse(handle, "fasta"), key_function=get_accession)
handle.close()
print orchid_dict.keys()
</PRE>
Finally, as desired, the new dictionary keys:
<PRE>
&gt;&gt;&gt; print orchid_dict.keys()
['Z78484.1', 'Z78464.1', 'Z78455.1', 'Z78442.1', 'Z78532.1', 'Z78453.1', ..., 'Z78471.1']
</PRE>
Not too complicated, I hope!<BR>
<BR>

<H3><A NAME="htoc16">2.4.6</A>&nbsp;&nbsp;Extracting data</H3>
Suppose you wanted to extract a list of the species from your GenBank file. Let's have a close look at the first record in the file and see where the species gets stored:
<PRE>
from Bio import SeqIO
record_iterator = SeqIO.parse(open("ls_orchid.gbk"), "genbank")
first_record = record_iterator.next()
print first_record
</PRE>
That should give something like this:
<PRE>
ID: Z78533.1
Name: Z78533
Desription: C.irapeanum 5.8S rRNA gene and ITS1 and ITS2 DNA.
/source=Cypripedium irapeanum
/taxonomy=['Eukaryota', 'Viridiplantae', 'Streptophyta', ..., 'Cypripedium']
/keywords=['5.8S ribosomal RNA', '5.8S rRNA gene', 'internal transcribed spacer', 'ITS1', 'ITS2']
/references=[...]
/data_file_division=PLN
/date=30-NOV-2006
/organism=Cypripedium irapeanum
/gi=2765658
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGGAATAAA ...', IUPACAmbiguousDNA())
</PRE>
The information we want, <EM>Cypripedium irapeanum</EM>, is held in the annotations dictionary under 'source' and 'organism', which we can access like this:
<PRE>
print first_record.annotations["source"]
</PRE>
or:
<PRE>
print first_record.annotations["organism"]
</PRE>
Now let's go through all the records, building up a list of the name of the orchid species each sequence is from:
<PRE>
from Bio import SeqIO
handle = open("ls_orchid.gbk")
all_species = []
for seq_record in SeqIO.parse(handle, "genbank") :
    all_species.append(seq_record.annotations["organism"])
handle.close()
print all_species
</PRE>
Another way of writing this code is to use a list comprehension (introduced in Python 2.0) like this:
<PRE>
from Bio import SeqIO
all_species == [seq_record.annotations["organism"] for seq_record in \
                SeqIO.parse(open("ls_orchid.gbk"), "genbank")]
print all_species
</PRE>
In either case, the result is:
<PRE>
['Cypripedium irapeanum', 'Cypripedium californicum', ..., 'Paphiopedilum barbatum']
</PRE>
Great. That was pretty easy because GenBank files are annotated in a standardised way.<BR>
<BR>
Now, let's suppose you wanted to extract a list of the species from your FASTA file, rather than the GenBank file. The trick is to notice that if you break up the description line at the spaces, then the species is there as field number one (field zero is the record identifier). That means we can do this:
<PRE>
from Bio import SeqIO
handle = open("ls_orchid.fasta")
all_species = []
for seq_record in SeqIO.parse(handle, "fasta") :
    all_species.append(seq_record.description.split()[1])
handle.close()
print all_species
</PRE>
This gives:
<PRE>
['C.irapeanum', 'C.californicum', 'C.fasciculatum', 'C.margaritaceum', ..., 'P.barbatum']
</PRE>
The concise alternative using list comprehensions (Python 2.0 or later) would be:
<PRE>
from Bio import SeqIO
all_species == [seq_record.description.split()[1] for seq_record in \
                SeqIO.parse(open("ls_orchid.fasta"), "fasta")]
print all_species
</PRE>
In general, extracting information from the FASTA description line is not very nice. If you can get your sequences in a well annotated file format like GenBank or EMBL, then this sort of annotation information is much easier to deal with.<BR>
<BR>

<H3><A NAME="htoc17">2.4.7</A>&nbsp;&nbsp;I love parsing -- please don't stop talking about it!</H3>
Biopython has a lot of parsers, and each has its own little special niches based on the sequence format it is parsing and all of that. While the most popular file formats have parsers integrated into <CODE>Bio.SeqIO</CODE>, for some of the rarer and unloved file formats there is either no parser at all, or an old parser which has not been linked in yet. Please check the Bio.SeqIO wiki page (<A HREF="http://biopython.org/wiki/SeqIO"><TT>http://biopython.org/wiki/SeqIO</TT></A>) for the latest information, or ask on the mailing list.<BR>
<BR>
The wiki page also includes a list of supported file types, and more examples including writing sequences to a file, and converting between file formats.<BR>
<BR>
The next place to look for information about specific parsers and how to do cool things with them is in the Cookbook, Section&nbsp;<A HREF="Tutorial005.html#sec:cookbook">4</A> of this Tutorial. If you don't find the information you are looking for, please consider helping out your poor overworked documentors and submitting a cookbook entry about it! (once you figure out how to do it, that is!)<BR>
<BR>
<A NAME="toc8"></A>
<H2><A NAME="htoc18">2.5</A>&nbsp;&nbsp;Connecting with biological databases</H2>
<A NAME="sec:connecting-with-biological-databases"></A>
One of the very common things that you need to do in bioinformatics is extract information from biological databases. It can be quite tedious to access these databases manually, especially if you have a lot of repetitive work to do. Biopython attempts to save you time and energy by making some on-line databases available from python scripts. Currently, Biopython has code to extract information from the following databases:
<UL><LI>
 <A HREF="http://www.expasy.org/">ExPASy</A> -- See section&nbsp;<A HREF="Tutorial005.html#sec:swiss_prot">4.1</A> in the Cookbook for more information.
 <LI><A HREF="http://www.ncbi.nlm.nih.gov/Entrez/">Entrez from NCBI</A> -- See below
 <LI><A HREF="http://www.ncbi.nlm.nih.gov/PubMed/">PubMed from NCBI</A> -- See section&nbsp;<A HREF="Tutorial005.html#sec:pub_med">4.2</A> in the Cookbook for example code detailing how to use this.
 <LI><A HREF="http://scop.mrc-lmb.cam.ac.uk/scop/">SCOP</A>
</UL>
The code is these modules basically makes it easy to write python code that interact with the CGI scripts on these pages, so that you can get results in an easy to deal with format. In some cases, the results can be tightly integrated with the Biopython parsers to make it even easier to extract information.<BR>
<BR>
Here we'll show a simple example of performing a remote Entrez query. More information on the other services is available in the Cookbook, which begins on page&nbsp;<A HREF="Tutorial005.html#sec:cookbook">??</A>.<BR>
<BR>
In section&nbsp;<A HREF="#sec:orchids">2.3</A> of the parsing examples, we talked about using Entrez website to search the NCBI nucleotide databases for info on Cypripedioideae, our friends the lady slipper orchids. Now, we'll look at how to automate that process using a python script. For Entrez searching, this is more useful for displaying results then as a tool for getting sequences. The NCBI web site is mostly set up to allow remote queries so that you could write our own local CGI scripts that return information from NCBI pages. For this reason, the results are returned as HTML and it is pretty tough to get a flat file in a quick manner.<BR>
<BR>
In this example, we'll just show how to connect, get the results, and display them in a web browser. First, we'll start by defining our search and how to display the results:
<PRE>
search_command = 'Search'
search_database = 'Nucleotide'
return_format = 'FASTA'
search_term = 'Cypripedioideae'

my_browser = 'lynx'
</PRE>
The first four terms define the search we are going to do. To use the Entrez module, you'll need to know a bit about how the remote CGI scripts at NCBI work, and you can find out more about this at <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/linking.html"><TT>http://www.ncbi.nlm.nih.gov/entrez/query/static/linking.html</TT></A>. The final term just describes the browser to display the results in.<BR>
<BR>
Now that we've got this all set up, we can query Entrez and get a handle with the results. This is done with the following code:
<PRE>
from Bio.WWW import NCBI

result_handle = NCBI.query(search_command, search_database, term = search_term,
                           doptcmdl = return_format)
</PRE>
The query function does all of the work of preparing the CGI script command line and rounding up the HTML results.<BR>
<BR>
Now that we've got the results, we are ready to save them to a file and display them in our browser, which we can do with code like:
<PRE>
import os

result_file_name = os.path.join(os.getcwd(), "results.html")
result_file = open(result_file_name, "w")
result_file.write(result_handle.read())
result_file.close()

if my_browser == "lynx":
    os.system("lynx -force_html " + result_file_name)
elif my_browser == "netscape":
    os.system("netscape file:" + result_file_name)
</PRE>
Snazzy! We can fetch things and display them automatically -- you could use this to quickly set up searches that you want to repeat on a daily basis and check by hand, or to set up a small CGI script to do queries and locally save the results before displaying them (as a kind of lab notebook of our search results). Hopefully whatever your task, the database connectivity code will make things lots easier for you!<BR>
<BR>
<A NAME="toc9"></A>
<H2><A NAME="htoc19">2.6</A>&nbsp;&nbsp;What to do next</H2>
Now that you've made it this far, you hopefully have a good understanding of the basics of Biopython and are ready to start using it for doing useful work. The best thing to do now is to start snooping around in the source code and looking at the automatically generated documentation. <BR>
<BR>
Once you get a picture of what you want to do, and what libraries in Biopython will do it, you should take a peak at the Cookbook, which may have example code to do something similar to what you want to do. <BR>
<BR>
If you know what you want to do, but can't figure out how to do it, please feel free to post questions to the main biopython list (biopython@biopython.org). This will not only help us answer your question, it will also allow us to improve the documentation so it can help the next person do what you want to do.<BR>
<BR>
Enjoy the code!<BR>
<BR>
<HR>
<A HREF="Tutorial002.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Tutorial004.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
