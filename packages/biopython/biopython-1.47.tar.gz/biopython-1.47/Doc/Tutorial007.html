<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="Tutorial.css">
<TITLE>BLAST</TITLE>
</HEAD>
<BODY >
<A HREF="Tutorial006.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="Tutorial008.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc48">Chapter&#XA0;6</A>&#XA0;&#XA0;BLAST</H1><P>
<A NAME="chapter:blast"></A>
Hey, everybody loves BLAST right? I mean, geez, how can get it get any easier to do comparisons between one of your sequences and every other sequence in the known world? But, of course, this section isn&#X2019;t about how cool BLAST is, since we already know that. It is about the problem with BLAST &#X2013; it can be really difficult to deal with the volume of data generated by large runs, and to automate BLAST runs in general.</P><P>Fortunately, the Biopython folks know this only too well, so they&#X2019;ve developed lots of tools for dealing with BLAST and making things much easier. This section details how to use these tools and do useful things with them.</P><P>Dealing with BLAST can be split up into two steps, both of which can be done from within Biopython.
Firstly, running BLAST for your query sequence(s), and getting some output.
Secondly, parsing the BLAST output in python for further analysis.
We&#X2019;ll start by talking about running the BLAST command line tools locally, and then discuss running BLAST via the web.</P><H2 CLASS="section"><A NAME="toc25"></A><A NAME="htoc49">6.1</A>&#XA0;&#XA0;Running BLAST locally</H2><P>
<A NAME="sec:running-local-blast"></A></P><P>Running BLAST locally (as opposed to over the internet, see
Section&#XA0;<A HREF="#sec:running-www-blast">6.2</A>) has two advantages:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Local BLAST may be faster than BLAST over the internet;
</LI><LI CLASS="li-itemize">Local BLAST allows you to make your own database to search for sequences against.
</LI></UL><P>
Dealing with proprietary or unpublished sequence data can be another reason to run BLAST locally. You may not be allowed to redistribute the sequences, so submitting them to the NCBI as a BLAST query would not be an option.</P><P>Biopython provides lots of nice code to enable you to call local BLAST executables from your scripts, and have full access to the many command line options that these executables provide. You can obtain local BLAST precompiled for a number of platforms at <A HREF="ftp://ftp.ncbi.nlm.nih.gov/blast/executables/"><TT>ftp://ftp.ncbi.nlm.nih.gov/blast/executables/</TT></A>, or can compile it yourself in the NCBI toolbox (<A HREF="ftp://ftp.ncbi.nlm.nih.gov/toolbox/"><TT>ftp://ftp.ncbi.nlm.nih.gov/toolbox/</TT></A>).</P><P>The code for dealing with local BLAST is found in <CODE>Bio.Blast.NCBIStandalone</CODE>, specifically in the functions <CODE>blastall</CODE>, <CODE>blastpgp</CODE> and <CODE>rpsblast</CODE>, which correspond with the BLAST executables that their names imply.</P><P>Let&#X2019;s use these functions to run a <CODE>blastall</CODE> against a local database and return the results. First, we want to set up the paths to everything that we&#X2019;ll need to do the BLAST. What we need to know is the path to the database (which should have been prepared using <CODE>formatdb</CODE>, see <A HREF="ftp://ftp.ncbi.nlm.nih.gov/blast/documents/formatdb.html"><TT>ftp://ftp.ncbi.nlm.nih.gov/blast/documents/formatdb.html</TT></A>) to search against, the path to the file we want to search, and the path to the <CODE>blastall</CODE> executable.</P><P>On Linux or Mac OS X your paths might look like this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_blast_db = "/home/mdehoon/Data/Genomes/Databases/bsubtilis"
# I used formatdb to create a BLAST database named bsubtilis
# (for Bacillus subtilis) consisting of the following three files:
# /home/mdehoon/Data/Genomes/Databases/bsubtilis.nhr
# /home/mdehoon/Data/Genomes/Databases/bsubtilis.nin
# /home/mdehoon/Data/Genomes/Databases/bsubtilis.nsq

&gt;&gt;&gt; my_blast_file = "m_cold.fasta"
# A FASTA file with the sequence I want to BLAST

&gt;&gt;&gt; my_blast_exe = "/usr/local/blast/bin/blastall"
# The name of my BLAST executable
</PRE><P>while on Windows you might have something like this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; my_blast_db = r"C:\Blast\Data\bsubtilis"
# Assuming you used formatdb to create a BLAST database named bsubtilis
# (for Bacillus subtilis) consisting of the following three files:
# C:\Blast\Data\bsubtilis\bsubtilis.nhr
# C:\Blast\Data\bsubtilis\bsubtilis.nin
# C:\Blast\Data\bsubtilis\bsubtilis.nsq
&gt;&gt;&gt; my_blast_file = "m_cold.fasta"
&gt;&gt;&gt; my_blast_exe =r"C:\Blast\bin\blastall.exe"
</PRE><P>The FASTA file used in this example is available
<A HREF="examples/m_cold.fasta">here</A> as well as
<A HREF="http://biopython.org/DIST/docs/tutorial/examples/m_cold.fasta">online</A>.</P><P>Now that we&#X2019;ve got that all set, we are ready to run the BLAST and collect the results. We can do this with two lines:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIStandalone
&gt;&gt;&gt; result_handle, error_handle = NCBIStandalone.blastall(my_blast_exe, "blastn",
                                                    my_blast_db, my_blast_file)
</PRE><P>Note that the Biopython interfaces to local blast programs returns two values. The first is a handle to the blast output, which is ready to either be saved or passed to a parser. The second is the possible error output generated by the blast command. See Section&#XA0;<A HREF="Tutorial013.html#sec:appendix-handles">12.1</A> for more about handles.</P><P>The error info can be hard to deal with, because if you try to do a <CODE>error_handle.read()</CODE> and there was no error info returned, then the <CODE>read()</CODE> call will block and not return, locking your script. In my opinion, the best way to deal with the error is only to print it out if you are not getting <CODE>result_handle</CODE> results to be parsed, but otherwise to leave it alone.</P><P>This command will generate BLAST output in XML format, as that is the format expected by the XML parser, described in Section&#XA0;<A HREF="#sec:parsing-blast">6.4</A>. For plain text output, use the <CODE>align_view='0'</CODE> keyword. To parse text output instead of XML output, see the Section&#XA0;<A HREF="#sec:parsing-blast-deprecated">6.6</A> below. However, parsing text output is not recommended, as the BLAST plain text output changes frequently, breaking our parsers.</P><P>If you are interested in saving your results to a file before parsing them,
see Section&#XA0;<A HREF="#sec:saving-blast-output">6.3</A>. To find out how to parse the BLAST
results, go to Section&#XA0;<A HREF="#sec:parsing-blast">6.4</A></P><H2 CLASS="section"><A NAME="toc26"></A><A NAME="htoc50">6.2</A>&#XA0;&#XA0;Running BLAST over the Internet</H2><P>
<A NAME="sec:running-www-blast"></A></P><P>The first step in automating BLASTing is to make everything accessible
from Python scripts. So, Biopython contains code that allows you to
run the WWW version of BLAST (<A HREF="http://www.ncbi.nlm.nih.gov/BLAST/"><TT>http://www.ncbi.nlm.nih.gov/BLAST/</TT></A>)
directly from your Python scripts. This is very nice, especially since
otherwise BLAST can be a real pain to deal with from scripts, especially
with the whole BLAST queue thing and the separate results page.</P><P>The code to deal with the WWW version of BLAST is found in the
<CODE>Bio.Blast.NCBIWWW</CODE> module, and the <CODE>qblast</CODE> function. Let&#X2019;s
say we want to BLAST info we have in a FASTA formatted file against
the database. First, we need to get the info in the FASTA file.</P><P>The easiest way to do this is to use the <CODE>Bio.SeqIO</CODE> module (see
Chapter&#XA0;<A HREF="Tutorial005.html#chapter:Bio.SeqIO">4</A>). In this example we&#X2019;ll use the
<CODE>Bio.SeqIO.read</CODE> function to turn a FASTA file containing a single
entry into a SeqRecord object:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; record = SeqIO.read(open("m_cold.fasta"), format="fasta")
</PRE><P>Now we can take the sequence as a plain string from the SeqRecord
and run BLAST on it. The code to do the simplest possible BLAST
(a simple blastn of the FASTA file against all of the non-redundant
databases) is:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIWWW
&gt;&gt;&gt; result_handle = NCBIWWW.qblast("blastn", "nr", record.seq.tostring())
</PRE><P>The first three arguments to our <CODE>NCBIWWW.qblast</CODE> function are non-optional:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The first argument is the blast program to use for the search, as a
lower case string. The options and descriptions of the programs are
available at <A HREF="http://www.ncbi.nlm.nih.gov/BLAST/blast_program.html"><TT>http://www.ncbi.nlm.nih.gov/BLAST/blast_program.html</TT></A>.
Currently <CODE>qblast</CODE> only works with blastn, blastp, blastx, tblast
and tblastx.
</LI><LI CLASS="li-itemize">The second argument specifies the databases to search against. Again,
the options for this are available on the NCBI web pages at
<A HREF="http://www.ncbi.nlm.nih.gov/BLAST/blast_databases.html"><TT>http://www.ncbi.nlm.nih.gov/BLAST/blast_databases.html</TT></A>.
</LI><LI CLASS="li-itemize">The third argument is a string containing your query sequence. This
can either be the sequence itself (as above), the sequence in fasta format,
or an identifier like a GI number.
</LI></UL><P>The <CODE>qblast</CODE> function also take a number of other option arguments
which are basically analogous to the different parameters you can set
on the BLAST web page. We&#X2019;ll just highlight a few of them here:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The <CODE>qblast</CODE> function can return the BLAST results in various
formats, which you can choose with the optional <CODE>format_type</CODE> keyword:
<CODE>"HTML"</CODE>, <CODE>"Text"</CODE>, <CODE>"ASN.1"</CODE>, or <CODE>"XML"</CODE>.
The default is <CODE>"XML"</CODE>, as that is the format expected by the parser,
described in section&#XA0;<A HREF="#sec:parsing-blast">6.4</A> below.
</LI><LI CLASS="li-itemize">The argument <CODE>expect</CODE> sets the expectation or e-value threshold.
</LI></UL><P>For more about the optional BLAST arguments, we refer you to the NCBI&#X2019;s own
documentation, or that built into Biopython:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIWWW
&gt;&gt;&gt; help(NCBIWWW.qblast)
</PRE><P>After you have set the search options, you are all ready to BLAST.
Biopython takes care of worrying about when the results are available,
and will pause until it can get the results and return them.</P><H2 CLASS="section"><A NAME="toc27"></A><A NAME="htoc51">6.3</A>&#XA0;&#XA0;Saving BLAST output</H2><P>
<A NAME="sec:saving-blast-output"></A></P><P>Before parsing the results, it is often useful to save them into a
file so that you can use them later without having to go back and
re-blast everything. I find this especially useful when debugging my
code that extracts info from the BLAST files, but it could also be
useful just for making backups of things you&#X2019;ve done.</P><P>If you don&#X2019;t want to save the BLAST output, you can skip to
section&#XA0;<A HREF="#sec:parsing-blast">6.4</A>. If you do, read on.</P><P>We need to be a bit careful since we can use <CODE>result_handle.read()</CODE> to
read the BLAST output only once &#X2013; calling <CODE>result_handle.read()</CODE> again
returns an empty string. First, we use <CODE>read()</CODE> and store all of
the information from the handle into a string:</P><PRE CLASS="verbatim">&gt;&gt;&gt; blast_results = result_handle.read()
</PRE><P>Next, we save this string in a file:</P><PRE CLASS="verbatim">&gt;&gt;&gt; save_file = open("my_blast.xml", "w")
&gt;&gt;&gt; save_file.write(blast_results)
&gt;&gt;&gt; save_file.close()
</PRE><P>After doing this, the results are in the file <CODE>my_blast.xml</CODE> and the
variable <CODE>blast_results</CODE> contains the BLAST results in a string
form. However, the <CODE>parse</CODE> function of the BLAST parser (described
in&#XA0;<A HREF="#sec:parsing-blast">6.4</A>) takes a file-handle-like object, not a
plain string. To get a handle, there are two things you can do:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Use the Python standard library module <CODE>cStringIO</CODE>. The
following code will turn the plain string into a handle, which we can
feed directly into the BLAST parser:
<PRE CLASS="verbatim">&gt;&gt;&gt; import cStringIO
&gt;&gt;&gt; result_handle = cStringIO.StringIO(blast_results)
</PRE></LI><LI CLASS="li-itemize">Open the saved file for reading. Duh.
<PRE CLASS="verbatim">&gt;&gt;&gt; result_handle = open("my_blast.xml")
</PRE></LI></UL><P>Now that we&#X2019;ve got the BLAST results, we are ready to do
something with them, so this leads us right into the parsing section.</P><H2 CLASS="section"><A NAME="toc28"></A><A NAME="htoc52">6.4</A>&#XA0;&#XA0;Parsing BLAST output</H2><P>
<A NAME="sec:parsing-blast"></A></P><P>As mentioned above, BLAST can generate output in various formats,
such as XML, HTML, and plain text. Originally, Biopython had a parser for
BLAST plain text and HTML output, as these were the only output formats supported
by BLAST. Unfortunately, the BLAST output in these formats kept changing,
each time breaking the Biopython parsers. As keeping up with changes in BLAST
became a hopeless endeavor, especially with users running different BLAST
versions, we now recommend to parse the output in XML format, which can be
generated by recent versions of BLAST. Not only is the XML output more stable
than the plain text and HTML output, it is also much easier to parse
automatically, making Biopython a whole lot more stable.</P><P>Though deprecated, the parsers for BLAST output in plain text or HTML output
are still available in Biopython
(see Section&#XA0;<A HREF="#sec:parsing-blast-deprecated">6.6</A>).
Use them at your own risk: they may or may not work, depending on which BLAST
version you&#X2019;re using.</P><P>You can get BLAST output in XML format in various ways. For the parser, it
doesn&#X2019;t matter how the output was generated, as long as it is in the XML format.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
You can use Biopython to run BLAST locally, as described in
section&#XA0;<A HREF="#sec:running-local-blast">6.1</A>.
</LI><LI CLASS="li-itemize">You can use Biopython to run BLAST over the internet, as described in
section&#XA0;<A HREF="#sec:running-www-blast">6.2</A>.
</LI><LI CLASS="li-itemize">You can do the BLAST seach yourself on the NCBI site through your
web browser, and then save the results. You need to choose XML as the format
in which to receive the results, and save the final BLAST page you get
(you know, the one with all of the interesting results!) to a file.
</LI><LI CLASS="li-itemize">You can also run BLAST locally without using Biopython, and save
the output in a file. Again, you need to choose XML as the format in which
to receive the results.
</LI></UL><P>
The important point is that you do not have to use Biopython
scripts to fetch the data in order to be able to parse it.</P><P>Doing things in one of these ways, you then need to get a handle
to the results. In Python, a handle is just a nice general way of
describing input to any info source so that the info can be retrieved
using <CODE>read()</CODE> and <CODE>readline()</CODE> functions. This is the type
of input the BLAST parser (and most other Biopython parsers) take.</P><P>If you followed the code above for interacting with BLAST through a
script, then you already have <CODE>result_handle</CODE>, the handle to the
BLAST results. For example:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio import SeqIO
&gt;&gt;&gt; record = SeqIO.read(open("m_cold.fasta"), format="fasta")
&gt;&gt;&gt; from Bio.Blast import NCBIWWW
&gt;&gt;&gt; result_handle = NCBIWWW.qblast("blastn", "nr", record.seq.tostring())
</PRE><P>If instead you ran BLAST some other way, and have the
BLAST output (in XML format) in the file <CODE>my_blast.xml</CODE>, all you
need to do is to open the file for reading:</P><PRE CLASS="verbatim">&gt;&gt;&gt; result_handle = open("my_blast.xml")
</PRE><P>Now that we&#X2019;ve got a handle, we are ready to parse the output. The
code to parse it is really quite small:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIXML
&gt;&gt;&gt; blast_records = NCBIXML.parse(result_handle)
</PRE><P>To understand what <CODE>NCBIXML.parse</CODE> returns, there are two things
that you need to keep in mind:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The BLAST output may contain the output of more than
one BLAST search. This will for example be the case if you ran BLAST locally
on a Fasta file containing more than one sequence. For each sequence, the
BLAST parser will return one BLAST record.
</LI><LI CLASS="li-itemize">The BLAST output may therefore be huge.
</LI></UL><P>To be able to handle these situations, <CODE>NCBIXML.parse</CODE> returns an
iterator (just like <CODE>Bio.SeqIO.parse</CODE>). In plain English, an iterator
allows you to step through the BLAST output, retrieving BLAST records one
by one for each BLAST search:</P><PRE CLASS="verbatim">&gt;&gt;&gt; blast_record = blast_records.next()
# ... do something with blast_record
&gt;&gt;&gt; blast_record = blast_records.next()
# ... do something with blast_record
&gt;&gt;&gt; blast_record = blast_records.next()
# ... do something with blast_record
&gt;&gt;&gt; blast_record = blast_records.next()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
# No further records
</PRE><P>Or, you can use a <CODE>for</CODE>-loop:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; for blast_record in blast_records:
...     # Do something with blast_record
</PRE><P>Note though that you can step through the BLAST records only once.
Usually, from each BLAST record you would save the information that
you are interested in. If you want to save all returned BLAST records,
you can convert the iterator into a list:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; blast_records = list(blast_records)
</PRE><P>Now you can access each BLAST record in the list with an index as usual.
If your BLAST file is huge though, you may run into problems trying to
save them all in a list.</P><P>Usually, you&#X2019;ll be running one BLAST search at a time. Then, all you need
to do is to pick up the first (and only) BLAST record in <CODE>blast_records</CODE>:
</P><PRE CLASS="verbatim">&gt;&gt;&gt; blast_record = blast_records.next()
</PRE><P>I guess by now you&#X2019;re wondering what is in a BLAST record.</P><H2 CLASS="section"><A NAME="toc29"></A><A NAME="htoc53">6.5</A>&#XA0;&#XA0;The BLAST record class</H2><P>A BLAST Record contains everything you might ever want to extract from the
BLAST output. Right now we&#X2019;ll just show
an example of how to get some info out of the BLAST report, but if you
want something in particular that is not described here, look at the
info on the record class in detail, and take a gander into the code or
automatically generated documentation &#X2013; the docstrings have lots of
good info about what is stored in each piece of information.</P><P>To continue with our example, let&#X2019;s just print out some summary info
about all hits in our blast report greater than a particular
threshold. The following code does this:</P><PRE CLASS="verbatim">&gt;&gt;&gt; E_VALUE_THRESH = 0.04

&gt;&gt;&gt; for alignment in blast_record.alignments:
...     for hsp in alignment.hsps:
...         if hsp.expect &lt; E_VALUE_THRESH:
...             print '****Alignment****'
...             print 'sequence:', alignment.title
...             print 'length:', alignment.length
...             print 'e value:', hsp.expect
...             print hsp.query[0:75] + '...'
...             print hsp.match[0:75] + '...'
...             print hsp.sbjct[0:75] + '...'
</PRE><P>This will print out summary reports like the following:</P><PRE CLASS="verbatim">****Alignment****
sequence: &gt;gb|AF283004.1|AF283004 Arabidopsis thaliana cold acclimation protein WCOR413-like protein
alpha form mRNA, complete cds
length: 783
e value: 0.034
tacttgttgatattggatcgaacaaactggagaaccaacatgctcacgtcacttttagtcccttacatattcctc...
||||||||| | ||||||||||| || ||||  || || |||||||| |||||| |  | |||||||| ||| ||...
tacttgttggtgttggatcgaaccaattggaagacgaatatgctcacatcacttctcattccttacatcttcttc...
</PRE><P>Basically, you can do anything you want to with the info in the BLAST
report once you have parsed it. This will, of course, depend on what
you want to use it for, but hopefully this helps you get started on
doing what you need to do!</P><P>An important consideration for extracting information from a BLAST report is the type of objects that the information is stored in. In Biopython, the parsers return <CODE>Record</CODE> objects, either <CODE>Blast</CODE> or <CODE>PSIBlast</CODE> depending on what you are parsing. These objects are defined in <CODE>Bio.Blast.Record</CODE> and are quite complete.</P><P>Here are my attempts at UML class diagrams for the <CODE>Blast</CODE> and <CODE>PSIBlast</CODE> record classes. If you are good at UML and see mistakes/improvements that can be made, please let me know. The Blast class diagram is shown in Figure&#XA0;<A HREF="#fig:blastrecord">6.5</A>.</P><P>
<A NAME="fig:blastrecord"></A>
<IMG SRC="images/BlastRecord.png" width=650, height=750>
</P><P>The PSIBlast record object is similar, but has support for the rounds that are used in the iteration steps of PSIBlast. The class diagram for PSIBlast is shown in Figure&#XA0;<A HREF="#fig:psiblastrecord">6.5</A>.</P><P>
<A NAME="fig:psiblastrecord"></A>
<IMG SRC="images/PSIBlastRecord.png" width=650, height=750>
</P><H2 CLASS="section"><A NAME="toc30"></A><A NAME="htoc54">6.6</A>&#XA0;&#XA0;Deprecated BLAST parsers</H2><P>
<A NAME="sec:parsing-blast-deprecated"></A></P><P>Older versions of Biopython had parsers for BLAST output in plain text or HTML
format. Over the years, we discovered that it is very hard to maintain these
parsers in working order. Basically, any small change to the BLAST output in
newly released BLAST versions tends to cause the plain text and HTML parsers
to break. We therefore recommend parsing BLAST output in XML format, as
described in section&#XA0;<A HREF="#sec:parsing-blast">6.4</A>.
Whereas the plain text and HTML parsers are still available in
Biopython, use them at your own risk. They may or may not work, depending on
which BLAST versions you&#X2019;re using.</P><H3 CLASS="subsection"><A NAME="htoc55">6.6.1</A>&#XA0;&#XA0;Parsing plain-text BLAST output</H3><P>The plain text BLAST parser is located in <CODE>Bio.Blast.NCBIStandalone</CODE>.</P><P>As with the XML parser, we need to have a handle object that we can pass to the parser. The handle must implement the <CODE>readline()</CODE> method and do this properly. The common ways to get such a handle are to either use the provided <CODE>blastall</CODE> or <CODE>blastpgp</CODE> functions to run the local blast, or to run a local blast via the command line, and then do something like the following:</P><PRE CLASS="verbatim">&gt;&gt;&gt; result_handle = open("my_file_of_blast_output.txt")
</PRE><P>Well, now that we&#X2019;ve got a handle (which we&#X2019;ll call <CODE>result_handle</CODE>),
we are ready to parse it. This can be done with the following code:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIStandalone
&gt;&gt;&gt; blast_parser = NCBIStandalone.BlastParser()
&gt;&gt;&gt; blast_record = blast_parser.parse(result_handle)
</PRE><P>This will parse the BLAST report into a Blast Record class (either a Blast or a PSIBlast record, depending on what you are parsing) so that you can extract the information from it. In our case, let&#X2019;s just use print out a quick summary of all of the alignments greater than some threshold value.</P><PRE CLASS="verbatim">&gt;&gt;&gt; E_VALUE_THRESH = 0.04
&gt;&gt;&gt; for alignment in b_record.alignments:
...     for hsp in alignment.hsps:
...         if hsp.expect &lt; E_VALUE_THRESH:
...             print '****Alignment****'
...             print 'sequence:', alignment.title
...             print 'length:', alignment.length
...             print 'e value:', hsp.expect
...             print hsp.query[0:75] + '...'
...             print hsp.match[0:75] + '...'
...             print hsp.sbjct[0:75] + '...'
</PRE><P>If you also read the section&#XA0;<A HREF="#sec:parsing-blast">6.4</A> on parsing BLAST XML output, you&#X2019;ll notice that the above code is identical to what is found in that section. Once you parse something into a record class you can deal with it independent of the format of the original BLAST info you were parsing. Pretty snazzy!</P><P>Sure, parsing one record is great, but I&#X2019;ve got a BLAST file with tons of records &#X2013; how can I parse them all? Well, fear not, the answer lies in the very next section.</P><H3 CLASS="subsection"><A NAME="htoc56">6.6.2</A>&#XA0;&#XA0;Parsing a file full of BLAST runs</H3><P>Of course, local blast is cool because you can run a whole bunch of sequences against a database and get back a nice report on all of it. So, Biopython definitely has facilities to make it easy to parse humongous files without memory problems.</P><P>We can do this using the blast iterator. To set up an iterator, we first set up a parser, to parse our blast reports in Blast Record objects:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIStandalone
&gt;&gt;&gt; blast_parser = NCBIStandalone.BlastParser()
</PRE><P>Then we will assume we have a handle to a bunch of blast records, which we&#X2019;ll call <CODE>result_handle</CODE>. Getting a handle is described in full detail above in the blast parsing sections.</P><P>Now that we&#X2019;ve got a parser and a handle, we are ready to set up the iterator with the following command:</P><PRE CLASS="verbatim">&gt;&gt;&gt; blast_iterator = NCBIStandalone.Iterator(blast_handle, blast_parser)
</PRE><P>The second option, the parser, is optional. If we don&#X2019;t supply a parser, then the iterator will just return the raw BLAST reports one at a time.</P><P>Now that we&#X2019;ve got an iterator, we start retrieving blast records (generated by our parser) using <CODE>next()</CODE>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; blast_record = blast_iterator.next()
</PRE><P>Each call to next will return a new record that we can deal with. Now we can iterate through this records and generate our old favorite, a nice little blast report:</P><PRE CLASS="verbatim">&gt;&gt;&gt; for b_record in b_iterator :
...     E_VALUE_THRESH = 0.04
...     for alignment in b_record.alignments:
...         for hsp in alignment.hsps:
...             if hsp.expect &lt; E_VALUE_THRESH:
...                 print '****Alignment****'
...                 print 'sequence:', alignment.title
...                 print 'length:', alignment.length
...                 print 'e value:', hsp.expect
...                 if len(hsp.query) &gt; 75:
...                     dots = '...'
...                 else:
...                     dots = ''
...                 print hsp.query[0:75] + dots
...                 print hsp.match[0:75] + dots
...                 print hsp.sbjct[0:75] + dots
</PRE><P>The iterator allows you to deal with huge blast records without any memory problems, since things are read in one at a time. I have parsed tremendously huge files without any problems using this.</P><H3 CLASS="subsection"><A NAME="htoc57">6.6.3</A>&#XA0;&#XA0;Finding a bad record somewhere in a huge file</H3><P>One really ugly problem that happens to me is that I&#X2019;ll be parsing a huge blast file for a while, and the parser will bomb out with a ValueError. This is a serious problem, since you can&#X2019;t tell if the ValueError is due to a parser problem, or a problem with the BLAST. To make it even worse, you have no idea where the parse failed, so you can&#X2019;t just ignore the error, since this could be ignoring an important data point.</P><P>We used to have to make a little script to get around this problem, but the <CODE>Bio.Blast</CODE> module now includes a <CODE>BlastErrorParser</CODE> which really helps make this easier. The <CODE>BlastErrorParser</CODE> works very similar to the regular <CODE>BlastParser</CODE>, but it adds an extra layer of work by catching ValueErrors that are generated by the parser, and attempting to diagnose the errors.</P><P>Let&#X2019;s take a look at using this parser &#X2013; first we define the file we are going to parse and the file to write the problem reports to:</P><PRE CLASS="verbatim">&gt;&gt;&gt; import os
&gt;&gt;&gt; blast_file = os.path.join(os.getcwd(), "blast_out", "big_blast.out")
&gt;&gt;&gt; error_file = os.path.join(os.getcwd(), "blast_out", "big_blast.problems")
</PRE><P>Now we want to get a <CODE>BlastErrorParser</CODE>:</P><PRE CLASS="verbatim">&gt;&gt;&gt; from Bio.Blast import NCBIStandalone
&gt;&gt;&gt; error_handle = open(error_file, "w")
&gt;&gt;&gt; blast_error_parser = NCBIStandalone.BlastErrorParser(error_handle)
</PRE><P>Notice that the parser take an optional argument of a handle. If a handle is passed, then the parser will write any blast records which generate a ValueError to this handle. Otherwise, these records will not be recorded.</P><P>Now we can use the <CODE>BlastErrorParser</CODE> just like a regular blast parser. Specifically, we might want to make an iterator that goes through our blast records one at a time and parses them with the error parser:</P><PRE CLASS="verbatim">&gt;&gt;&gt; result_handle = open(blast_file)
&gt;&gt;&gt; iterator = NCBIStandalone.Iterator(result_handle, blast_error_parser)
</PRE><P>We can read these records one a time, but now we can catch and deal with errors that are due to problems with Blast (and not with the parser itself):</P><PRE CLASS="verbatim">&gt;&gt;&gt; try:
...     next_record = iterator.next()
... except NCBIStandalone.LowQualityBlastError, info:
...     print "LowQualityBlastError detected in id %s" % info[1]
</PRE><P>The <CODE>.next()</CODE> method is normally called indirectly via a <CODE>for</CODE>-loop.
Right now the <CODE>BlastErrorParser</CODE> can generate the following errors:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>ValueError</CODE> &#X2013; This is the same error generated by the regular BlastParser, and is due to the parser not being able to parse a specific file. This is normally either due to a bug in the parser, or some kind of discrepancy between the version of BLAST you are using and the versions the parser is able to handle.</LI><LI CLASS="li-itemize"><CODE>LowQualityBlastError</CODE> &#X2013; When BLASTing a sequence that is of really bad quality (for example, a short sequence that is basically a stretch of one nucleotide), it seems that Blast ends up masking out the entire sequence and ending up with nothing to parse. In this case it will produce a truncated report that causes the parser to generate a ValueError. <CODE>LowQualityBlastError</CODE> is reported in these cases. This error returns an info item with the following information:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>item[0]</CODE> &#X2013; The error message
</LI><LI CLASS="li-itemize"><CODE>item[1]</CODE> &#X2013; The id of the input record that caused the error. This is really useful if you want to record all of the records that are causing problems.
</LI></UL>
</LI></UL><P>As mentioned, with each error generated, the BlastErrorParser will write the offending record to the specified <CODE>error_handle</CODE>. You can then go ahead and look and these and deal with them as you see fit. Either you will be able to debug the parser with a single blast report, or will find out problems in your blast runs. Either way, it will definitely be a useful experience!</P><P>Hopefully the <CODE>BlastErrorParser</CODE> will make it much easier to debug and deal with large Blast files.</P><H2 CLASS="section"><A NAME="toc31"></A><A NAME="htoc58">6.7</A>&#XA0;&#XA0;Dealing with PSIBlast</H2><P>We should write some stuff to make it easier to deal directly with PSIBlast from scripts (i.&#XA0;e.&#XA0;output the align file in the proper format from an alignment). I need to look at PSIBlast more and come up with some good ways of going this...</P><HR>
<A HREF="Tutorial006.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="Tutorial008.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
