<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>



<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.08">
<LINK rel="stylesheet" type="text/css" href="Tutorial.css">
<TITLE>
Quick Start &ndash; What can you do with Biopython?
</TITLE>
</HEAD>
<BODY >
<A HREF="Tutorial002.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Tutorial004.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1 CLASS="chapter"><A NAME="htoc6">Chapter&nbsp;2</A>&nbsp;&nbsp;Quick Start &ndash; What can you do with Biopython?</H1>
This section is designed to get you started quickly with Biopython, and to give a general overview of what is available and how to use it. All of the examples in this section assume that you have some general working knowledge of python, and that you have successfully installed Biopython on your system. If you think you need to brush up on your python, the main python web site provides quite a bit of free documentation to get started with (<A HREF="http://www.python.org/doc/"><TT>http://www.python.org/doc/</TT></A>). <BR>
<BR>
Since much biological work on the computer involves connecting with databases on the internet, some of the examples will also require a working internet connection in order to run. <BR>
<BR>
Now that that is all out of the way, let's get into what we can do with Biopython.<BR>
<BR>
<A NAME="toc4"></A>
<H2 CLASS="section"><A NAME="htoc7">2.1</A>&nbsp;&nbsp;General overview of what Biopython provides</H2>
As mentioned in the introduction, Biopython is a set of libraries to provide the ability to deal with &#8221;things&#8221; of interest to biologists working on the computer. In general this means that you will need to have at least some programming experience (in python, of course!) or at least an interest in learning to program. Biopython's job is to make your job easier as a programmer by supplying reusable libraries so that you can focus on answering your specific question of interest, instead of focusing on the internals of parsing a particular file format (of course, if you want to help by writing a parser that doesn't exist and contributing it to Biopython, please go ahead!). So Biopython's job is to make you happy!<BR>
<BR>
One thing to note about Biopython is that it often provides multiple ways of &#8220;doing the same thing.&#8221; To me, this can be frustrating since I often way to just know the one right way to do something. However, this is also a real benefit because it gives you lots of flexibility and control over the libraries. The tutorial helps to show you the common or easy ways to do things so that you can just make things work. To learn more about the alternative possibilities, look into the Cookbook section (which tells you some cools tricks and tips) and the Advanced section (which provides you with as much detail as you'd ever want to know!). <BR>
<BR>
<A NAME="toc5"></A>
<H2 CLASS="section"><A NAME="htoc8">2.2</A>&nbsp;&nbsp;Working with sequences</H2>
<A NAME="sec:sequences"></A>
Disputedly (of course!), the central object in bioinformatics is the sequence. Thus, we'll start with the Biopython mechanisms for dealing with sequences. When I think of a sequence the first thing that pops into my mind is a string of letters:<CODE> 'AGTACACTGGT'</CODE> which seems natural since this is the most common way that sequences are seen in biological file formats. However, a simple string of letters by itself is also very uninformative &ndash; is it a DNA or protein sequence (okay, a protein with a lot of Alanines, Glycines, Cysteines and Threonines!), what type of organism did it come from, what is so interesting about it, and so on. The challenge in designing a sequence interface is to pick a representation that is informative enough to take into account the more complex information, yet is as lightweight and easy to work with as just a simple sequence.<BR>
<BR>
The approach taken in the Biopython sequence class is to utilize a class that holds more complex information, yet can be manipulated as if it were a simple string. This is accomplished by utilizing operator overloading to make manipulating a sequence object feel like manipulating a python string. The sequence class, referred to simply as Seq, is defined in the file <CODE>Bio/Seq.py.</CODE> Let's look at the Seq class deeper to see what it has to offer.<BR>
<BR>
A biopython Seq object has two important attributes:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><CODE>data</CODE> &ndash; as the name implies, this is the actual sequence data string of the sequence.<BR>
<BR>
<LI CLASS="li-enumerate"><CODE>alphabet</CODE> &ndash; an object describing what the individual characters making up the string &#8220;mean&#8221; and how they should be interpreted.</OL>
Clearly the alphabet object is the important thing that is making the Seq object more than just a string. The currently available alphabets for Biopython are defined in the <CODE>Bio/Alphabet</CODE> module. We'll use the IUPAC alphabets <A HREF="("><TT>(</TT></A><A HREF="http://www.chem.qmw.ac.uk/iupac/"><TT>http://www.chem.qmw.ac.uk/iupac/</TT></A>) here to deal with some of our favorite objects: DNA, RNA and Proteins. <BR>
<BR>
<CODE>Bio/Alphabet/IUPAC.py</CODE> provides basic definitions for proteins, DNA and RNA, but additionally provides the ability to extend and customize the basic definitions. For instance, for proteins, there is a basic IUPACProtein class, but there is an additional ExtendedIUPACProtein class providing for the additional elements &#8220;Asx&#8221; (asparagine or aspartic acid), &#8220;Sec&#8221; (selenocysteine), and &#8220;Glx&#8221; (glutamine or glutamic acid). For DNA you've got choices of IUPACUnambiguousDNA, which provides for just the basic letters, IUPACAmbiguousDNA (which provides for ambiguity letters for every possible situation) and ExtendedIUPACDNA, which allows letters for modified bases. Similarly, RNA can be represented by IUPACAmbigousRNA or IUPACUnambigousRNA.<BR>
<BR>
The advantages of having an alphabet class are two fold. First, this gives an idea of the type of information the <CODE>data</CODE> object contains. Secondly, this provides a means of constraining the information you have in the data object, as a means of type checking.<BR>
<BR>
Now that we know what we are dealing with, let's look at how to utilize this class to do interesting work.<BR>
<BR>
First, create a Sequence object from a string of information we've got. We'll create an unambiguous DNA object:
<PRE CLASS="verbatim">
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; my_alpha = IUPAC.unambiguous_dna
&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; my_seq = Seq('GATCGATGGGCCTATATAGGATCGAAAATCGC', my_alpha)
&gt;&gt;&gt; print my_seq
Seq('GATCGATGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
</PRE>
Even though this is a sequence object, we can deal with it in some ways as if it were a normal python string. For instance, let's get a slice of the sequence.
<PRE CLASS="verbatim">
&gt;&gt;&gt; my_seq[4:12]
Seq('GATGGGCC', IUPACUnambiguousDNA())
</PRE>
Two things are interesting to note. First, this follows the normal conventions for python sequences. So the first element of the sequence is 0 (which is normal for computer science, but not so normal for biology). When you do a slice the first item is included (i.&nbsp;e.&nbsp;4 in this case) and the last is excluded (12 in this case), which is the way things work in python, but of course not necessarily the way everyone in the world would expect. The main goal is to stay consistent with what python does. The second thing to notice is that the slice is performed on the sequence data string, but the new object produced retains the alphabet information from the original Seq object.<BR>
<BR>
You can treat the Seq object like the string in many ways:
<PRE CLASS="verbatim">
&gt;&gt;&gt; len(my_seq)
32
&gt;&gt;&gt; new_seq = my_seq[0:5]
&gt;&gt;&gt; print new_seq
Seq('GATCG', IUPACUnambiguousDNA())
&gt;&gt;&gt; my_seq + new_seq
Seq('GATCGATGGGCCTATATAGGATCGAAAATCGCGATCG', IUPACUnambiguousDNA())
&gt;&gt;&gt; my_seq[5]
'A'
&gt;&gt;&gt; my_seq == new_seq
0
</PRE>
In all of the operations, the alphabet property is maintained. This is very useful in case you accidentally end up trying to do something weird like add a protein sequence and a DNA sequence:
<PRE CLASS="verbatim">
&gt;&gt;&gt; protein_seq = Seq('EVRNAK', IUPAC.protein)
&gt;&gt;&gt; dna_seq = Seq('ACGT', IUPAC.unambiguous_dna)
&gt;&gt;&gt; protein_seq + dna_seq
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
  File "/usr/local/lib/python1.6/site-packages/Bio/Seq.py", line 42, in __add__
    raise TypeError, ("incompatable alphabets", str(self.alphabet),
TypeError: ('incompatable alphabets', 'IUPACProtein()', 'IUPACUnambiguousDNA()')
</PRE>
And if you are really just need the string to insert into something, this is very easy to extract:
<PRE CLASS="verbatim">
&gt;&gt;&gt; my_seq.tostring()
'GATCGATGGGCCTATATAGGATCGAAAATCGC'
</PRE>
The sequence object is not mutable by default, since in many biological applications you want to ensure you are not changing your data:
<PRE CLASS="verbatim">
&gt;&gt;&gt; my_seq[5] = 'G'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
AttributeError: 'Seq' instance has no attribute '__setitem__'
</PRE>
However, you can convert it into a mutable sequence and do pretty much anything you want with it:
<PRE CLASS="verbatim">
&gt;&gt;&gt; mutable_seq = my_seq.tomutable()
&gt;&gt;&gt; print mutable_seq
MutableSeq('GATCGATGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
&gt;&gt;&gt; mutable_seq[5] = 'T'
&gt;&gt;&gt; print mutable_seq
MutableSeq('GATCGTTGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
&gt;&gt;&gt; mutable_seq.remove('T')
&gt;&gt;&gt; print mutable_seq
MutableSeq('GACGTTGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
&gt;&gt;&gt; mutable_seq.reverse()
&gt;&gt;&gt; print mutable_seq
MutableSeq('CGCTAAAAGCTAGGATATATCCGGGTTGCAG', IUPACUnambiguousDNA())
</PRE>
Now that the nature of the sequence object makes some sense, the next
thing to look at is what kind of things we can do with a sequence. The
<CODE>Bio</CODE> directory contains two useful modules to transcribe and
translate a sequence object. These tools work based on the alphabet of
the sequence. For instance, let's supposed we want to transcribe our
<CODE>my_seq</CODE> object. Remember that this contains an unambiguous
alphabet, so to transcribe we would do the following:
<PRE CLASS="verbatim">
&gt;&gt;&gt; from Bio import Transcribe
&gt;&gt;&gt; transcriber = Transcribe.unambiguous_transcriber
&gt;&gt;&gt; my_rna_seq = transcriber.transcribe(my_seq)
&gt;&gt;&gt; print my_rna_seq
Seq('GAUCGAUGGGCCUAUAUAGGAUCGAAAAUCGC', IUPACUnambiguousRNA())
</PRE>
The alphabet of the new RNA Seq object is created for free, so again, dealing with a Seq object is no more difficult then dealing with a simple string.<BR>
<BR>
You can also reverse transcribe RNA sequences:
<PRE CLASS="verbatim">
&gt;&gt;&gt; transcriber.back_transcribe(my_rna_seq)
Seq('GATCGATGGGCCTATATAGGATCGAAAATCGC', IUPACUnambiguousDNA())
</PRE>
To translate our DNA object we have quite a few choices. First, we can use any number of translation tables depending on what we know about our DNA sequence. The translation tables available in biopython were taken from information at <A HREF="ftp://ftp.ncbi.nlm.nih.gov/entrez/misc/data/gc.prt"><TT>ftp://ftp.ncbi.nlm.nih.gov/entrez/misc/data/gc.prt</TT></A>. So, you have tons of choices to pick from. For this, let's just focus on two choices: the Standard translation table, and the Translation table for Vertebrate Mitochondrial DNA. These tables are labeled with id numbers 1 and 2, respectively. Now that we know what tables we are looking to get, we're all set to perform a basic translation. First, we need to get our translators that use these tables. Since we are still dealing with our unambiguous DNA object, we want to fetch translators that take this into account:
<PRE CLASS="verbatim">
&gt;&gt;&gt; from Bio import Translate
&gt;&gt;&gt; standard_translator = Translate.unambiguous_dna_by_id[1] 
&gt;&gt;&gt; mito_translator = Translate.unambiguous_dna_by_id[2]
</PRE>
Once we've got the proper translators, it's time to go ahead and translate a sequence:
<PRE CLASS="verbatim">
&gt;&gt;&gt; my_seq = Seq('GCCATTGTAATGGGCCGCTGAAAGGGTGCCCGA', IUPAC.unambiguous_dna)
&gt;&gt;&gt; standard_translator.translate(my_seq)
Seq('AIVMGR*KGAR', IUPACProtein())
&gt;&gt;&gt; mito_translator.translate(my_seq)
Seq('AIVMGRWKGAR', IUPACProtein())
</PRE>
Notice that the default translation will just go ahead and proceed blindly through a stop codon. If you are aware that you are translating some kind of open reading frame and want to just see everything up until the stop codon, this can be easily done with the <CODE>translate_to_stop</CODE> function:
<PRE CLASS="verbatim">
&gt;&gt;&gt; standard_translator.translate_to_stop(my_seq)
Seq('AIVMGR', IUPACProtein())
</PRE>
Similar to the transcriber, it is also possible to reverse translate a protein into a DNA sequence:
<PRE CLASS="verbatim">
&gt;&gt;&gt; my_protein = Seq('AVMGRWKGGRAAG', IUPAC.protein)
&gt;&gt;&gt; standard_translator.back_translate(my_protein)
Seq('GCTGTTATGGGTCGTTGGAAGGGTGGTCGTGCTGCTGGT', IUPACUnambiguousDNA())
</PRE>
This covers the basic features and uses of the Biopython sequence class. There is a more detailed description of the design ideas behind the sequence class in the Advanced section of this tutorial. This class is still under development and comments on the design and use are, of course, very welcome. Now that you've got some idea of what it is like to interact with the Biopython libraries, it's time to delve into the fun, fun world of dealing with biological file formats!<BR>
<BR>
<A NAME="toc6"></A>
<H2 CLASS="section"><A NAME="htoc9">2.3</A>&nbsp;&nbsp;A usage example</H2>
<A NAME="sec:orchids"></A>
Before we jump right into parsers and everything else to do with Biopython, let's set up an example to motivate everything we do and make life more interesting. After all, if there wasn't any biology in this tutorial, why would you want you read it?<BR>
<BR>
Since I love plants, I think we're just going to have to have a plant based example (sorry to all the fans of other organisms out there!). Having just completed a recent trip to our local greenhouse, we've suddenly developed an incredible obsession with Lady Slipper Orchids (if you wonder why take a look at <A HREF="http://www.millicentorchids.com/greenhouse/images/papesq01.jpg"><TT>http://www.millicentorchids.com/greenhouse/images/papesq01.jpg</TT></A>. If that doesn't convince you, you can look at all of the available photos at <A HREF="http://www.millicentorchids.com/greenhouse/indexphoto.htm"><TT>http://www.millicentorchids.com/greenhouse/indexphoto.htm</TT></A>). Of course, orchids are not only beautiful to look at, they are also extremely interesting for people studying evolution and systematics. So we're thinking about writing a little proposal to do a molecular study of Lady Slipper evolution and would like to see what kind of research has already been done and how we can add to that.<BR>
<BR>
After a little bit of reading up we discover that the Lady Slipper Orchids are in the Orchidaceae family and the Cypripedioideae sub-family and are made up of 5 genera: <EM>Cypripedium</EM>, <EM>Paphiopedilum</EM>, <EM>Phragmipedium</EM>, <EM>Selenipedium</EM> and <EM>Mexipedium</EM>. That gives us enough information to get started delving for more information. So, let's look at how biopython tools can help us.<BR>
<BR>
<A NAME="toc7"></A>
<H2 CLASS="section"><A NAME="htoc10">2.4</A>&nbsp;&nbsp;Parsing biological file formats</H2>
A large part of much bioinformatics work involves dealing with the many types of file formats designed to hold biological data. These files are loaded with interesting biological data, and a special challenge is parsing these files into a format so that you can manipulate them with some kind of programming language. However the task of parsing these files can be frustrated by the fact that the formats can change quite regularly, and that formats may contain small subtleties which can break even the most well designed parsers. <BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc11">2.4.1</A>&nbsp;&nbsp;General parser design</H3>
The biopython solution to these problem is to develop a structured parser framework that is applicable to all of the parsers. The advantages are two fold. First, this allows code reuse between parsers (see <CODE>Bio/ParserSupport.py</CODE>). Second, this provides a similar framework for all the parsers so that it is relatively easy to jump into the internals of a parser and figure out problems you might be having. <BR>
<BR>
All of the parsers have two components:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Scanner - The part of the parser that actually does the work or going through the file and extracting useful information. This useful information is converted into Events.<BR>
<BR>
<LI CLASS="li-enumerate">Consumer - The consumer does the job of processing the useful information and spitting it out in a format that the programmer can use. The consumer does this by receiving the events created by the scanner.</OL>
So, the parser design is event oriented. The general idea is that a scanner will go through and produce events for every item that might be of interest in a file. For instance, let's say we've got the following FASTA formatted entry (edited to fit the page):
<PRE CLASS="verbatim">
&gt;gi|6273290|gb|AF191664.1|AF191664 Opuntia clavata rpl16 gene; chloroplast gene for...
TATACATTAAAGGAGGGGGATGCGGATAAATGGAAAGGCGAAAGAAAGAAAAAAATGAA
TCTAAATGATATAGGATTCCACTATGTAAGGTCTTTGAATCATATCATAAAAGACAATGTAAT
AAA...
</PRE>
As a scanner moved through a file containing this entry, it would create the following events:
<BR>
<BR>
<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=center NOWRAP>Event Name</TD>
<TD ALIGN=center NOWRAP>Entry input</TD>
</TR>
<TR><TD BGCOLOR=black COLSPAN=2><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADDING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD ALIGN=center NOWRAP>begin_sequence</TD>
<TD ALIGN=center NOWRAP>(as soon as we notice we've got a new <CODE>&gt;</CODE>)</TD>
</TR>
<TR><TD ALIGN=center NOWRAP>title</TD>
<TD ALIGN=center NOWRAP><CODE>&gt;gi|6273290|gb|AF191664.1|AF191664 Opuntia clavata...</CODE></TD>
</TR>
<TR><TD ALIGN=center NOWRAP>sequence</TD>
<TD ALIGN=center NOWRAP><CODE>TATACATTAAAGGAGGGGGATGCGGAT...</CODE></TD>
</TR>
<TR><TD ALIGN=center NOWRAP>sequence</TD>
<TD ALIGN=center NOWRAP><CODE>TCTAAATGATATAGGATTCCACTATGTAA...</CODE></TD>
</TR>
<TR><TD ALIGN=center NOWRAP>sequence</TD>
<TD ALIGN=center NOWRAP><CODE>AAA...</CODE> (and so on &ndash; you've got the idea!)</TD>
</TR>
<TR><TD ALIGN=center NOWRAP>end_sequence</TD>
<TD ALIGN=center NOWRAP>(as soon as we reach a blank line after the sequence data)</TD>
</TR></TABLE>
<BR>
<BR>
So, events are being produced. Big deal, unless we are able to capture these events and do something interesting with them! This is where the consumer comes in. The consumer needs to do two things:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Register itself with the the scanner to let it know that it wants to receive those events that are being generated.<BR>
<BR>
<LI CLASS="li-enumerate">Do something with the events (and the information associated with them).</OL>
An example should make it more clear how this works.<BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc12">2.4.2</A>&nbsp;&nbsp;Writing your own consumer</H3>
<A NAME="sec:writing_consumer"></A>
Now it's time to understand our parser framework, and also start looking at our friends, the lady slipper orchids. To start our search, let's just take a look through the nucleotide databases at NCBI, using an Entrez search (<A HREF="lhttp://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?db=Nucleotide"><TT>lhttp://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?db=Nucleotide</TT></A>) for everything mentioning the text Cypripedioideae (this is the subfamily of lady slipper orchids). This search gives us 94 hits, which we save into a FASTA formatted text file.<BR>
<BR>
Now, let's try and use a parser to summarize the type of information we got. To take a simple example, why don't we go through and grab all of the organism names mentioned, to see how many different species of lady slipper orchids are represented in this data.<BR>
<BR>
To do this kind of useful work, we need to do get our hands dirty and write the solution to all of our problems &ndash; a consumer. This is what our consumer implementation to extract the organisms will look like:
<PRE CLASS="verbatim">
import string
from Bio.ParserSupport import AbstractConsumer

class SpeciesExtractor(AbstractConsumer):

    def __init__(self):
        self.species_list = []

    def title(self, title_info):
        title_atoms = string.split(title_info)
        new_species = title_atoms[1]

        if new_species not in self.species_list:
            self.species_list.append(new_species)
</PRE>
The first thing we do is import the base class which Consumers should derive from, <CODE>AbstractConsumer</CODE>. This base class does nice things for us like take care of all the sections we aren't interested in. Then we create our personal consumer class by deriving from this base AbstractConsumer class.<BR>
<BR>
Just like any other python class, we define a <CODE>__init__</CODE> function that will be called when a new instance of the class is created. In the initialization we set a <CODE>species_list</CODE> class attribute. This will store the species information as the file is parsed, and will allow us to extract this information later on.<BR>
<BR>
Now we come to the function that is really nifty, the <CODE>title</CODE> function. This function will be called by the Scanner every time a 'title' event is generated. So, when the Scanner comes to the first line in our example FASTA file:
<PRE CLASS="verbatim">
&gt;gi|2765658|emb|Z78533.1|CIZ78533 C.irapeanum 5.8S rRNA gene and ITS1 and ITS2 DNA
</PRE>
It will recognize this as a title, and call the <CODE>title</CODE> function with the <CODE>title_info</CODE> argument set as the value of the title.<BR>
<BR>
Now that we've captured the title, we want to extract the information from it we are interested in. Looking at the FASTA title info, we notice that the second item in the info string is the organism name. To get this out we can just use the built-in python function <CODE>string.split</CODE> to split the string at every space, creating the list <CODE>title_atoms</CODE>. Since the second element of this list is the species name, we then grab this out of the list. Then we simply check to see if the species is already in our current list of organisms, and if not, we add it.<BR>
<BR>
Okay, well that was easy enough &ndash; so now we need to call the Scanner and actual do this work. To do this, we write a little function:
<PRE CLASS="verbatim">

from Bio import Fasta

def extract_organisms(file, num_records):
    scanner = Fasta._Scanner()
    consumer = SpeciesExtractor()

    file_to_parse = open(file, 'r')

    for fasta_record in range(num_records):
        scanner.feed(file_to_parse, consumer)

    file_to_parse.close()

    return handler.species_list

</PRE>
Let's walk though the function step by step. First, we import the Fasta parser from the Biopython library, then we proceed to define our function. It takes two arguments, the FASTA formatted file to parse, and the number of records in the file. It then creates a Scanner for scanning through FASTA files, and a SpeciesExtractor consumer which will get all of the organisms, as we described above.<BR>
<BR>
We then open our file to parse and get it ready to go. All of the Biopython parsers take file handles as inputs. This means that you can pass them any kind of &#8220;file-like&#8221; object. For instance, the <CODE>url</CODE> library allows to you work with a document on a remote URL as if it was a local file, so you could use this to pass the parser a document somewhere on the net.<BR>
<BR>
Now that we've got the open file, it's time to parse it. The way the parser works is that you call <CODE>feed</CODE> for every item in the file you want to parse, passing it the file-like object to parse, and the consumer to call back to. So we loop through all records in the file, and scan them, relying on the consumer to deal with the files as appropriate. Finally, once that is all done, we get the <CODE>species_list</CODE> attribute of the consumer class, containing all of the information extracted and return that.<BR>
<BR>
Whew, with all of that work out of the way, parsing the file will be really easy:
<PRE CLASS="verbatim">
all_species = extract_organisms("ls_orchid.fasta", 94)
print "number of species:", len(all_species)
print 'species names:', all_species
</PRE>
Running this all as one big program (the program is available as <CODE>fasta_consumer.py</CODE> in the <CODE>Doc/examples</CODE> directory) give us the information we desire:
<PRE CLASS="verbatim">
[chapmanb@taxus examples]# python fasta_consumer.py
number of species: 92
species names: ['C.irapeanum', 'C.californicum', 'C.fasciculatum', 
'C.margaritaceum', 'C.lichiangense', 'C.yatabeanum', 'C.guttatum',
...
</PRE>

<H3 CLASS="subsection"><A NAME="htoc13">2.4.3</A>&nbsp;&nbsp;Making it easier</H3>
<A NAME="sec:fasta-parsing"></A>
The last section explained all of the nitty gritty of writing a specialized consumer. The flexibility of being able to write your own consumer is very nice, however for many applications it can be overkill. For a simple application, the nice Biopython folks have provided some useful classes that act more like full parsers. So, for quick and dirty applications, these are what you want to look at. <BR>
<BR>
One big problem with the parser we used above was that we were required to know the number of elements in the file. This can be pretty impractical for a lot of applications when you just want to parse through a file and look for something. To help deal with this problem, we can use the <CODE>Iterator</CODE> interface for FASTA files. This interface allows you to not worry about consumers and scanners and all of that jazz, and just march through a file one record at a time. However, doing this requires that the Iterator return some kind of object that you can manipulate to extract the info you want.<BR>
<BR>
To deal with this problem, a very useful class was written into many of the Biopython parsers &ndash; a <CODE>RecordParser</CODE>, which parses a file into a python class that represents it. For instance, for FASTA files, the Record class is just an object with <CODE>title</CODE> and <CODE>sequence</CODE> attributes. <BR>
<BR>
Let's make all of this talk more concrete by using the Iterator and Record interfaces to do what we did before &ndash; extract a unique list of all species in our FASTA file. First we need to set up our parser and iterator:
<PRE CLASS="verbatim">
&gt;&gt;&gt; from Bio import Fasta
&gt;&gt;&gt; parser = Fasta.RecordParser()
&gt;&gt;&gt; file = open("ls_orchid.fasta")
&gt;&gt;&gt; iterator = Fasta.Iterator(file, parser)
</PRE>
First we create our parser &ndash; a RecordParser that parses a FASTA entry into the Record class representing it. Then we open the file, and create an iterator, and we are ready to start parsing.<BR>
<BR>
Like most iterator interfaces, we retrieve the objects by calling <CODE>next()</CODE>. When there are no sequences left to parse, <CODE>next()</CODE> will return <CODE>None</CODE>, so we know that it is time to stop. To get our first record:
<PRE CLASS="verbatim">
&gt;&gt;&gt; cur_record = iterator.next()
</PRE>
Let's take a look at the record object. It has sequence and title attributes that we can easily get at:
<PRE CLASS="verbatim">
&gt;&gt;&gt; dir(cur_record)
['_colwidth', 'sequence', 'title']
&gt;&gt;&gt; print cur_record.title
gi|2765658|emb|Z78533.1|CIZ78533 C.irapeanum 5.8S rRNA gene and ITS1 and ITS2 DN&gt;&gt;&gt; print cur_record.sequence
CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGGAATAAACGATCGAGTGAATCCGGA
...
</PRE>
In my opinion, the coolest thing is how easy it is to get the FASTA record right back:
<PRE CLASS="verbatim">
&gt;&gt;&gt; print cur_record
&gt;gi|2765658|emb|Z78533.1|CIZ78533 C.irapeanum 5.8S rRNA gene and ITS1 and ITS2 DNA
CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGGAATAAA
CGATCGAGTGAATCCGGAGGACCGGTGTACTCAGCTCACCGGGGGCATTGCTCCCGTGGT
GACCCTGATTTGTTGTTGGGCCGCCTCGGGAGCGTCCATGGCGGGTTTGAACCTCTAGCC
CGGCGCAGTTTGGGCGCCAAGCCATATGAAAGCATCACCGGCGAATGGCATTGTCTTCCC
CAAAACCCGGAGCGGCGGCGTGCTGTCGCGTGCCCAATGAATTTTGATGACTCTCGCAAA
CGGGAATCTTGGCTCTTTGCATCGGATGGAAGGACGCAGCGAAATGCGATAAGTGGTGTG
AATTGCAAGATCCCGTGAACCATCGAGTCTTTTGAACGCAAGTTGCGCCCGAGGCCATCA
GGCTAAGGGCACGCCTGCTTGGGCGTCGCGCTTCGTCTCTCTCCTGCCAATGCTTGCCCG
GCATACAGCCAGGCCGGCGTGGTGCGGATGTGAAAGATTGGCCCCTTGTGCCTAGGTGCG
GCGGGTCCAAGAGCTGGTGTTTTGATGGCCCGGAACCCGGCAAGAGGTGGACGGATGCTG
GCAGCAGCTGCCGTGCGAATCCCCCATGTTGTCGTGCTTGTCGGACAGGCAGGAGAACCC
TTCCGAACCCCAATGGAGGGCGGTTGACCGCCATTCGGATGTGACCCCAGGTCAGGCGGG
GGCACCCGCTGAGTTTACGC
</PRE>
We can use all of this to do a rewrite of our <CODE>extract_organisms</CODE> function:
<PRE CLASS="verbatim">
def extract_organisms(file_to_parse):

    parser = Fasta.RecordParser()
    file = open(file_to_parse, 'r')
    iterator = Fasta.Iterator(file, parser)

    all_species = []

    while 1:
        cur_record = iterator.next()

        if cur_record is None:
            break

        # extract the info from the title
        title_atoms = string.split(cur_record.title)
        new_species = title_atoms[1]

        # append the new species to the list if it isn't there
        if new_species not in all_species:
            all_species.append(new_species)

    return all_species
</PRE>
Running this will give us identical results to what we saw earlier. Whether you choose to use this interface or the previous one depends on your needs and what you feel most comfortable with. Hey, Perl isn't the only place where there's more that one way to do things!<BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc14">2.4.4</A>&nbsp;&nbsp;FASTA files as Dictionaries</H3>
The final thing that we'll do with our ubiquitous orchid fasta file is to show how to index it and access it like a database. This is very useful for large files where you only need to access certain elements of the file, and makes for a nice quick 'n dirty database.<BR>
<BR>
Let's index our record via their GenBank accession number, which seems like a useful way to get track of them. To do this, we first need to write a small function which returns accession numbers from a FASTA record (this is the Record class we discussed earlier):
<PRE CLASS="verbatim">
import string

def get_accession_num(fasta_record):
    title_atoms = string.split(fasta_record.title)

    # all of the accession number information is stuck in the first element
    # and separated by '|'s
    accession_atoms = string.split(title_atoms[0], '|')
 
    # the accession number is the 4th element
    gb_name = accession_atoms[3]

    # strip the version info before returning
    return gb_name[:-2]
</PRE>
Now we need to create an index from this file, which will show us why writing this function was important. The general format for indexing a file is:
<PRE CLASS="verbatim">
index_file(file_to_index, index_file_to_create, function_to_get_index_key)
</PRE>
The tricky argument is the <CODE>function_to_get_index_key</CODE>. Basically, this is a reference to a function that can get called and return an element to use as a key. The idea here is that the <CODE>index_file</CODE> should be general purpose, and there isn't any good way for the Biopython developers to read your mind and know how you want to index your files. So now the <CODE>get_accession_num</CODE> function above makes a lot of sense!<BR>
<BR>
Using all of this, we can now create an index file and see how it works. First, let's create the index file:
<PRE CLASS="verbatim">
&gt;&gt;&gt; from Bio import Fasta 
&gt;&gt;&gt; Fasta.index_file("ls_orchid.fasta", "my_orchid_dict.idx", get_accession_num)
</PRE>
This creates an index file <CODE>my_orchid_dict.idx</CODE> based on the input from <CODE>ls_orchid.fasta</CODE> and indexed by the values returned by our <CODE>get_accession_number</CODE> function.<BR>
<BR>
Now that we've got the index, we can create an in-memory dictionary to access the file contents using the index:
<PRE CLASS="verbatim">
&gt;&gt;&gt; from Bio.Alphabet import IUPAC
&gt;&gt;&gt; dna_parser = Fasta.SequenceParser(IUPAC.ambiguous_dna)
&gt;&gt;&gt; orchid_dict = Fasta.Dictionary("my_orchid_dict.idx", dna_parser)
</PRE>
The dictionary is created from our <CODE>my_orchid_dict.idx</CODE> file, and returns Sequence objects. The type of objects returned by the index file are based on the second argument passed. This argument should be a parser that the index file will pass the information through before returning it. If no parser is passed, then the dictionary will just return the raw object (i.&nbsp;e.&nbsp;exactly as it appears in the file). <BR>
<BR>
The parser that we pass here is a <CODE>SequenceParser</CODE> which converts FASTA files into <CODE>SeqRecord</CODE> objects. The <CODE>SequenceParser</CODE> takes an argument of the alphabet we should be using for the sequences. Since the parser can't be smart enough to know exactly what it will be parsing, we need to tell it. If no alphabet is provided, then the parser will default to <CODE>Alphabet.generic_alphabet</CODE>.<BR>
<BR>
Since this is a dictionary, we can look at all of the keys we have available:
<PRE CLASS="verbatim">
&gt;&gt;&gt; print orchid_dict.keys()
['Z78475', 'Z78519', 'Z78516', 'Z78517', 'Z78514', 'Z78515', 'Z78512', 
 'Z78513', 'Z78510', 'Z78511', 'Z78457', 'Z78456', 'Z78455', 'Z78454', 
...
</PRE>
We can access a single sequence object via the keys and manipulate the object as a normal <CODE>SeqRecord</CODE> object:
<PRE CLASS="verbatim">
&gt;&gt;&gt; seq_record = orchid_dict['Z78475']
&gt;&gt;&gt; print seq_record
&lt;Bio.SeqRecord.SeqRecord instance at 0x102c1f2c&gt;
&gt;&gt;&gt; print seq_record.description
gi|2765600|emb|Z78475.1|PSZ78475 P.supardii 5.8S rRNA gene and ITS1 and ITS2 DNA
&gt;&gt;&gt; print seq_record.seq
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGTTGAGATCACATAATAAT ...', IUPACAmbiguousDNA())
</PRE>
That easily, we have created a database of our FASTA file that will spit out sequence objects. <BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc15">2.4.5</A>&nbsp;&nbsp;I love parsing &ndash; please don't stop talking about it!</H3>
Biopython has a lot of parsers, and each has its own little special niches based on the sequence format it is parsing and all of that. The best place to look for information about specific parsers and how to do cool things with them is in the Cookbook section of the Tutorial. If you don't find the information you are looking for, please consider helping out your poor overworked documentors and submitting a cookbook entry about it! (once you figure out how to do it, that is!)<BR>
<BR>
<A NAME="toc8"></A>
<H2 CLASS="section"><A NAME="htoc16">2.5</A>&nbsp;&nbsp;Connecting with biological databases</H2>
One of the very common things that you need to do in bioinformatics is extract information from biological databases. It can be quite tedious to access these databases manually, especially if you have a lot of repetitive work to do. Biopython attempts to save you time and energy by making some on-line databases available from python scripts. Currently, Biopython has code to extract information from the following databases:
<UL CLASS="itemize"><LI CLASS="li-itemize">
 ExPASy &ndash; <A HREF="http://www.expasy.org/"><TT>http://www.expasy.org/</TT></A> See section&nbsp;<A HREF="Tutorial004.html#sec:swiss_prot">3.2</A> in the Cookbook for more information.
 <LI CLASS="li-itemize">Entrez from NCBI &ndash; <A HREF="http://www.ncbi.nlm.nih.gov/Entrez/"><TT>http://www.ncbi.nlm.nih.gov/Entrez/</TT></A>
 <LI CLASS="li-itemize">PubMed from NCBI &ndash; <A HREF="http://www.ncbi.nlm.nih.gov/PubMed/"><TT>http://www.ncbi.nlm.nih.gov/PubMed/</TT></A>. See section&nbsp;<A HREF="Tutorial004.html#sec:pub_med">3.3</A> in the Cookbook for example code detailing how to use this.
 <LI CLASS="li-itemize">SCOP &ndash; <A HREF="http://scop.mrc-lmb.cam.ac.uk/scop/"><TT>http://scop.mrc-lmb.cam.ac.uk/scop/</TT></A>
</UL>
The code is these modules basically makes it easy to write python code that interact with the CGI scripts on these pages, so that you can get results in an easy to deal with format. In some cases, the results can be tightly integrated with the Biopython parsers to make it even easier to extract information.<BR>
<BR>
Here we'll show a simple example of performing a remote Entrez query. More information on the other services is available in the Cookbook, which begins on page&nbsp;<A HREF="Tutorial004.html#sec:cookbook">??</A>.<BR>
<BR>
In section&nbsp;<A HREF="#sec:writing_consumer">2.4.2</A> of the parsing examples, we talked about using Entrez to search the NCBI nucleotide databases for info on Cypripedioideae, our friends the lady slipper orchids. Now, we'll look at how to automate that process using a python script. For Entrez searching, this is more useful for displaying results then as a tool for getting sequences. The NCBI web site is mostly set up to allow remote queries so that you could write our own local CGI scripts that return information from NCBI pages. For this reason, the results are returned as HTML and it is pretty tough to get a flat file in a quick manner.<BR>
<BR>
In this example, we'll just show how to connect, get the results, and display them in a web browser. First, we'll start by defining our search and how to display the results:
<PRE CLASS="verbatim">
search_command = 'Search'
search_database = 'Nucleotide'
return_format = 'FASTA'
search_term = 'Cypripedioideae'

my_browser = 'lynx'
</PRE>
The first four terms define the search we are going to do. To use the Entrez module, you'll need to know a bit about how the remote CGI scripts at NCBI work, and you can find out more about this at <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/linking.html"><TT>http://www.ncbi.nlm.nih.gov/entrez/query/static/linking.html</TT></A>. The final term just describes the browser to display the results in.<BR>
<BR>
Now that we've got this all set up, we can query Entrez and get a handle with the results. This is done with the following code:
<PRE CLASS="verbatim">
from Bio.WWW import NCBI

result_handle = NCBI.query(search_command, search_database, term = search_term,
                           doptcmdl = return_format)
</PRE>
The query function does all of the work of preparing the CGI script command line and rounding up the HTML results.<BR>
<BR>
Now that we've got the results, we are ready to save them to a file and display them in our browser, which we can do with code like:
<PRE CLASS="verbatim">
import os

result_file_name = os.path.join(os.getcwd(), 'results.html')
result_file = open(result_file_name, 'w')
result_file.write(result_handle.read())
result_file.close()

if my_browser == 'lynx':
    os.system('lynx -force_html ' + result_file_name)
elif my_browser == 'netscape':
    os.system('netscape file:' + result_file_name)
</PRE>
Snazzy! We can fetch things and display them automatically &ndash; you could use this to quickly set up searches that you want to repeat on a daily basis and check by hand, or to set up a small CGI script to do queries and locally save the results before displaying them (as a kind of lab notebook of our search results). Hopefully whatever your task, the database connectivity code will make things lots easier for you!<BR>
<BR>
<A NAME="toc9"></A>
<H2 CLASS="section"><A NAME="htoc17">2.6</A>&nbsp;&nbsp;What to do next</H2>
Now that you've made it this far, you hopefully have a good understanding of the basics of Biopython and are ready to start using it for doing useful work. The best thing to do now is to start snooping around in the source code and looking at the automatically generated documentation. <BR>
<BR>
Once you get a picture of what you want to do, and what libraries in Biopython will do it, you should take a peak at the Cookbook, which may have example code to do something similar to what you want to do. <BR>
<BR>
If you know what you want to do, but can't figure out how to do it, please feel free to post questions to the main biopython list (biopython@biopython.org). This will not only help us answer your question, it will also allow us to improve the documentation so it can help the next person do what you want to do.<BR>
<BR>
Enjoy the code!<BR>
<BR>
<HR>
<A HREF="Tutorial002.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Tutorial004.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
