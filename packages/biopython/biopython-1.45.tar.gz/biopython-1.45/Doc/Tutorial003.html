<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.07">
<TITLE>
Quick Start -- What can you do with Biopython?
</TITLE>
</HEAD>
<BODY >
<A HREF="Tutorial002.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Tutorial004.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>

<H1><A NAME="htoc6">Chapter&nbsp;2</A>&nbsp;&nbsp;Quick Start -- What can you do with Biopython?</H1>
<A NAME="chapter:quick-start"></A>
This section is designed to get you started quickly with Biopython, and to give a general overview of what is available and how to use it. All of the examples in this section assume that you have some general working knowledge of python, and that you have successfully installed Biopython on your system. If you think you need to brush up on your python, the main python web site provides quite a bit of free documentation to get started with (<A HREF="http://www.python.org/doc/"><TT>http://www.python.org/doc/</TT></A>).<BR>
<BR>
Since much biological work on the computer involves connecting with databases on the internet, some of the examples will also require a working internet connection in order to run.<BR>
<BR>
Now that that is all out of the way, let's get into what we can do with Biopython.<BR>
<BR>
<A NAME="toc4"></A>
<H2><A NAME="htoc7">2.1</A>&nbsp;&nbsp;General overview of what Biopython provides</H2>
As mentioned in the introduction, Biopython is a set of libraries to provide the ability to deal with ''things'' of interest to biologists working on the computer. In general this means that you will need to have at least some programming experience (in python, of course!) or at least an interest in learning to program. Biopython's job is to make your job easier as a programmer by supplying reusable libraries so that you can focus on answering your specific question of interest, instead of focusing on the internals of parsing a particular file format (of course, if you want to help by writing a parser that doesn't exist and contributing it to Biopython, please go ahead!). So Biopython's job is to make you happy!<BR>
<BR>
One thing to note about Biopython is that it often provides multiple ways of ``doing the same thing.'' To me, this can be frustrating since I often way to just know the one right way to do something. However, this is also a real benefit because it gives you lots of flexibility and control over the libraries. The tutorial helps to show you the common or easy ways to do things so that you can just make things work. To learn more about the alternative possibilities, look into the Cookbook section (which tells you some cools tricks and tips) and the Advanced section (which provides you with as much detail as you'd ever want to know!).<BR>
<BR>
<A NAME="toc5"></A>
<H2><A NAME="htoc8">2.2</A>&nbsp;&nbsp;Working with sequences</H2>
<A NAME="sec:sequences"></A>
Disputedly (of course!), the central object in bioinformatics is the sequence. Thus, we'll start with a quick introduction to the Biopython mechanisms for dealing with sequences, the <CODE>Seq</CODE> object, which we'll discuss in more detail in Chapter&nbsp;<A HREF="Tutorial004.html#chapter:Bio.Seq">3</A>.<BR>
<BR>
Most of the time when we think about sequences we have in my mind a string of letters like <CODE>'AGTACACTGGT'</CODE>. You can create such <CODE>Seq</CODE> object with this sequence as follows - the ``&gt;&gt;&gt;'' represents the python prompt followed by what you would type in:
<PRE>
&gt;&gt;&gt; from Bio.Seq import Seq
&gt;&gt;&gt; my_seq = Seq("AGTACACTGGT")
&gt;&gt;&gt; my_seq.alphabet
Alphabet()
&gt;&gt;&gt; print my_seq.tostring()
AGTACACTGGT
</PRE>
What we have here is a sequence object with a <EM>generic</EM> alphabet - reflecting the fact we have <EM>not</EM> specified if this is a DNA or protein sequence (okay, a protein with a lot of Alanines, Glycines, Cysteines and Threonines!). We'll talk more about alphabets in Chapter&nbsp;<A HREF="Tutorial004.html#chapter:Bio.Seq">3</A>.<BR>
<BR>
In addition to having an alphabet, the <CODE>Seq</CODE> object differs from the python string in the methods it supports. You can't do this with a plain string:
<PRE>
&gt;&gt;&gt; my_seq
Seq('AGTACACTGGT', Alphabet())
&gt;&gt;&gt; my_seq.complement()
Seq('TCATGTGACCA', Alphabet())
&gt;&gt;&gt; my_seq.reverse_complement()
Seq('ACCAGTGTACT', Alphabet())
</PRE>
The next most important class is the <CODE>SeqRecord</CODE> or Sequence Record. This holds a sequence (as a <CODE>Seq</CODE> object) with additional annotation including an identifier, name and description. The <CODE>Bio.SeqIO</CODE> module for reading and writing sequence file formats works with <CODE>SeqRecord</CODE> objects, which will be introduced below and cover in more detail by Chapter&nbsp;<A HREF="Tutorial005.html#chapter:Bio.SeqIO">4</A>.<BR>
<BR>
This covers the basic features and uses of the Biopython sequence class.
Now that you've got some idea of what it is like to interact with the Biopython libraries, it's time to delve into the fun, fun world of dealing with biological file formats!<BR>
<BR>
<A NAME="toc6"></A>
<H2><A NAME="htoc9">2.3</A>&nbsp;&nbsp;A usage example</H2>
<A NAME="sec:orchids"></A>
Before we jump right into parsers and everything else to do with Biopython, let's set up an example to motivate everything we do and make life more interesting. After all, if there wasn't any biology in this tutorial, why would you want you read it?<BR>
<BR>
Since I love plants, I think we're just going to have to have a plant based example (sorry to all the fans of other organisms out there!). Having just completed a recent trip to our local greenhouse, we've suddenly developed an incredible obsession with Lady Slipper Orchids (if you wonder why, have a look at some <A HREF="http://www.flickr.com/search/?q=lady+slipper+orchid&s=int&z=t">Lady Slipper Orchids photos on Flickr</A>, or try a <A HREF="http://images.google.com/images?q=lady%20slipper%20orchid">Google Image Search</A>).<BR>
<BR>
Of course, orchids are not only beautiful to look at, they are also extremely interesting for people studying evolution and systematics. So let's suppose we're thinking about writing a funding proposal to do a molecular study of Lady Slipper evolution, and would like to see what kind of research has already been done and how we can add to that.<BR>
<BR>
After a little bit of reading up we discover that the Lady Slipper Orchids are in the Orchidaceae family and the Cypripedioideae sub-family and are made up of 5 genera: <EM>Cypripedium</EM>, <EM>Paphiopedilum</EM>, <EM>Phragmipedium</EM>, <EM>Selenipedium</EM> and <EM>Mexipedium</EM>.<BR>
<BR>
That gives us enough to get started delving for more information. So, let's look at how the Biopython tools can help us. We'll start with sequence parsing in Section&nbsp;<A HREF="#sec:sequence-parsing">2.4</A>, but the orchids will be back later on as well - for example we'll extra data from Swiss-Prot from certain orchid proteins in Chapter&nbsp;<A HREF="Tutorial008.html#chapter:swiss_prot">7</A>, search PubMed for papers about orchids in Section&nbsp;<A HREF="Tutorial009.html#sec:pub_med">8.1</A>, extract sequence data from GenBank in Section&nbsp;<A HREF="Tutorial009.html#genbank-retrieval">8.2.1</A>, and work with ClustalW multiple sequence alignments of orchid proteins in Section&nbsp;<A HREF="Tutorial009.html#sec:align_clustal">8.3.1</A>.<BR>
<BR>
<A NAME="toc7"></A>
<H2><A NAME="htoc10">2.4</A>&nbsp;&nbsp;Parsing sequence file formats</H2>
<A NAME="sec:sequence-parsing"></A>
A large part of much bioinformatics work involves dealing with the many types of file formats designed to hold biological data. These files are loaded with interesting biological data, and a special challenge is parsing these files into a format so that you can manipulate them with some kind of programming language. However the task of parsing these files can be frustrated by the fact that the formats can change quite regularly, and that formats may contain small subtleties which can break even the most well designed parsers.<BR>
<BR>
We are going to briefly introduce the <CODE>Bio.SeqIO</CODE> module, available in Biopython 1.43 and later. If you are using an older version of Biopython we encourage you to update (or find an old edition of this tutorial!). You can find out more in Chapter&nbsp;<A HREF="Tutorial005.html#chapter:Bio.SeqIO">4</A>.<BR>
<BR>
We'll start with an online search for our friends, the lady slipper orchids. Let's just take a look through the nucleotide databases at NCBI, using an Entrez online search (<A HREF="http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?db=Nucleotide"><TT>http://www.ncbi.nlm.nih.gov:80/entrez/query.fcgi?db=Nucleotide</TT></A>) for everything mentioning the text Cypripedioideae (this is the subfamily of lady slipper orchids). When this tutorial was originally written, this search gave us only 94 hits, which we saved as a FASTA formatted text file (<A HREF="examples/ls_orchid.fasta">ls_orchid.fasta</A>; also available online <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.fasta">here</A>) and as a GenBank formatted text file (<A HREF="examples/ls_orchid.gbk">ls_orchid.gbk</A>; also available online <A HREF="http://biopython.org/DIST/docs/tutorial/examples/ls_orchid.gbk">here</A>).<BR>
<BR>
If you run the search today, you'll get hundreds of results! When following the tutorial, if you want to see the same list of genes, just download the two files above or copy them from <CODE>docs/examples/</CODE> in the Biopython source code. In Section&nbsp;<A HREF="#sec:connecting-with-biological-databases">2.5</A> we will look at how to do a search like this from within python.<BR>
<BR>

<H3><A NAME="htoc11">2.4.1</A>&nbsp;&nbsp;Simple FASTA parsing example</H3>
<A NAME="sec:fasta-parsing"></A>
If you open the lady slipper orchids FASTA file in your favourite text editor, you'll see that the file starts like this:
<PRE>
&gt;gi|2765658|emb|Z78533.1|CIZ78533 C.irapeanum 5.8S rRNA gene and ITS1 and ITS2 DNA
CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGGAATAAACGATCGAGTG
AATCCGGAGGACCGGTGTACTCAGCTCACCGGGGGCATTGCTCCCGTGGTGACCCTGATTTGTTGTTGGG
...
</PRE>
It contains 94 records, each has a line starting with ``&gt;'' (greater-than symbol) followed by the sequence on one or more lines. Now try this in python:
<PRE>
from Bio import SeqIO
handle = open("ls_orchid.fasta")
for seq_record in SeqIO.parse(handle, "fasta") :
    print seq_record.id
    print repr(seq_record.seq)
    print len(seq_record.seq)
handle.close()
</PRE>
You should get something like this on your screen:
<PRE>
gi|2765658|emb|Z78533.1|CIZ78533
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGG...CGC', SingleLetterAlphabet())
740
...
gi|2765564|emb|Z78439.1|PBZ78439
Seq('CATTGTTGAGATCACATAATAATTGATCGAGTTAATCTGGAGGATCTGTTTACT...GCC', SingleLetterAlphabet())
592
</PRE>
Notice that the FASTA format does not specify the alphabet, so <CODE>Bio.SeqIO</CODE> has defaulted to the rather generic <CODE>SingleLetterAlphabet()</CODE> rather than something DNA specific.<BR>
<BR>

<H3><A NAME="htoc12">2.4.2</A>&nbsp;&nbsp;Simple GenBank parsing example</H3>
Now let's load the GenBank file instead - notice that the code to do this is almost identical to the snippet used above for a FASTA file - the only difference is we changed the filename and the format string:
<PRE>
from Bio import SeqIO
handle = open("ls_orchid.gbk")
for seq_record in SeqIO.parse(handle, "genbank") :
    print seq_record.id
    print repr(seq_record.seq)
    print len(seq_record.seq)
handle.close()
</PRE>
This should give:
<PRE>
Z78533.1
Seq('CGTAACAAGGTTTCCGTAGGTGAACCTGCGGAAGGATCATTGATGAGACCGTGG...CGC', IUPACAmbiguousDNA())
740
...
Z78439.1
Seq('CATTGTTGAGATCACATAATAATTGATCGAGTTAATCTGGAGGATCTGTTTACT...GCC', IUPACAmbiguousDNA())
592
</PRE>
This time <CODE>Bio.SeqIO</CODE> has been able to choose a sensible alphabet, IUPAC Ambiguous DNA. You'll also notice that a shorter string has been used as the <CODE>seq_record.id</CODE> in this case.<BR>
<BR>

<H3><A NAME="htoc13">2.4.3</A>&nbsp;&nbsp;I love parsing -- please don't stop talking about it!</H3>
Biopython has a lot of parsers, and each has its own little special niches based on the sequence format it is parsing and all of that. While the most popular file formats have parsers integrated into <CODE>Bio.SeqIO</CODE>, for some of the rarer and unloved file formats there is either no parser at all, or an old parser which has not been linked in yet.<BR>
<BR>
Chapter&nbsp;<A HREF="Tutorial005.html#chapter:Bio.SeqIO">4</A> covers <CODE>Bio.SeqIO</CODE> in more detail. Please also check the wiki page (<A HREF="http://biopython.org/wiki/SeqIO"><TT>http://biopython.org/wiki/SeqIO</TT></A>) for the latest information, or ask on the mailing list. The wiki page should includes an up to date list of supported file types, and more examples including writing sequences to a file, and converting between file formats.<BR>
<BR>
The next place to look for information about specific parsers and how to do cool things with them is in the Cookbook, Section&nbsp;<A HREF="Tutorial009.html#chapter:cookbook">8</A> of this Tutorial. If you don't find the information you are looking for, please consider helping out your poor overworked documentors and submitting a cookbook entry about it! (once you figure out how to do it, that is!)<BR>
<BR>
<A NAME="toc8"></A>
<H2><A NAME="htoc14">2.5</A>&nbsp;&nbsp;Connecting with biological databases</H2>
<A NAME="sec:connecting-with-biological-databases"></A>
One of the very common things that you need to do in bioinformatics is extract information from biological databases. It can be quite tedious to access these databases manually, especially if you have a lot of repetitive work to do. Biopython attempts to save you time and energy by making some on-line databases available from python scripts. Currently, Biopython has code to extract information from the following databases:
<UL><LI>
 <A HREF="http://www.expasy.org/">ExPASy</A> -- See Chapter&nbsp;<A HREF="Tutorial008.html#chapter:swiss_prot">7</A> in the Cookbook for more information.
 <LI><A HREF="http://www.ncbi.nlm.nih.gov/Entrez/">Entrez from NCBI</A> -- See below
 <LI><A HREF="http://www.ncbi.nlm.nih.gov/PubMed/">PubMed from NCBI</A> -- See section&nbsp;<A HREF="Tutorial009.html#sec:pub_med">8.1</A> in the Cookbook for example code detailing how to use this.
 <LI><A HREF="http://scop.mrc-lmb.cam.ac.uk/scop/">SCOP</A>
</UL>
The code is these modules basically makes it easy to write python code that interact with the CGI scripts on these pages, so that you can get results in an easy to deal with format. In some cases, the results can be tightly integrated with the Biopython parsers to make it even easier to extract information.<BR>
<BR>
Here we'll show a simple example of performing a remote Entrez query. More information on the other services is available in the Cookbook, which begins on page&nbsp;<A HREF="Tutorial009.html#chapter:cookbook">??</A>.<BR>
<BR>
In section&nbsp;<A HREF="#sec:orchids">2.3</A> of the parsing examples, we talked about using Entrez website to search the NCBI nucleotide databases for info on Cypripedioideae, our friends the lady slipper orchids. Now, we'll look at how to automate that process using a python script. For Entrez searching, this is more useful for displaying results then as a tool for getting sequences. The NCBI web site is mostly set up to allow remote queries so that you could write our own local CGI scripts that return information from NCBI pages. For this reason, the results are returned as HTML and it is pretty tough to get a flat file in a quick manner.<BR>
<BR>
In this example, we'll just show how to connect, get the results, and display them in a web browser. First, we'll start by defining our search and how to display the results:
<PRE>
search_command = 'Search'
search_database = 'Nucleotide'
return_format = 'FASTA'
search_term = 'Cypripedioideae'

my_browser = 'lynx'
</PRE>
The first four terms define the search we are going to do. To use the Entrez module, you'll need to know a bit about how the remote CGI scripts at NCBI work, and you can find out more about this at <A HREF="http://www.ncbi.nlm.nih.gov/entrez/query/static/linking.html"><TT>http://www.ncbi.nlm.nih.gov/entrez/query/static/linking.html</TT></A>. The final term just describes the browser to display the results in.<BR>
<BR>
Now that we've got this all set up, we can query Entrez and get a handle with the results. This is done with the following code:
<PRE>
from Bio import Entrez

result_handle = Entrez.query(search_command, search_database, term = search_term,
                           doptcmdl = return_format)
</PRE>
The query function does all of the work of preparing the CGI script command line and rounding up the HTML results.<BR>
<BR>
Now that we've got the results, we are ready to save them to a file and display them in our browser, which we can do with code like:
<PRE>
import os

result_file_name = os.path.join(os.getcwd(), "results.html")
result_file = open(result_file_name, "w")
result_file.write(result_handle.read())
result_file.close()

if my_browser == "lynx":
    os.system("lynx -force_html " + result_file_name)
elif my_browser == "netscape":
    os.system("netscape file:" + result_file_name)
</PRE>
Snazzy! We can fetch things and display them automatically -- you could use this to quickly set up searches that you want to repeat on a daily basis and check by hand, or to set up a small CGI script to do queries and locally save the results before displaying them (as a kind of lab notebook of our search results). Hopefully whatever your task, the database connectivity code will make things lots easier for you!<BR>
<BR>
<A NAME="toc9"></A>
<H2><A NAME="htoc15">2.6</A>&nbsp;&nbsp;What to do next</H2>
Now that you've made it this far, you hopefully have a good understanding of the basics of Biopython and are ready to start using it for doing useful work. The best thing to do now is to start snooping around in the source code and looking at the automatically generated documentation.<BR>
<BR>
Once you get a picture of what you want to do, and what libraries in Biopython will do it, you should take a peak at the Cookbook, which may have example code to do something similar to what you want to do.<BR>
<BR>
If you know what you want to do, but can't figure out how to do it, please feel free to post questions to the main biopython list (biopython@biopython.org). This will not only help us answer your question, it will also allow us to improve the documentation so it can help the next person do what you want to do.<BR>
<BR>
Enjoy the code!<BR>
<BR>
<HR>
<A HREF="Tutorial002.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="Tutorial004.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
