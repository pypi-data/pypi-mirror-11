<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Support for unittest.TestCase / Integration of fixtures</title>
    
    <link rel="stylesheet" href="_static/flasky.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.7.3.dev376+ng06b1b69.d20150827',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/pytest1favi.ico"/>
    <link rel="top" title="None" href="contents.html" />
    <link rel="up" title="pytest reference documentation" href="apiref.html" />
    <link rel="next" title="Running tests written for nose" href="nose.html" />
    <link rel="prev" title="Asserting Warnings" href="recwarn.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">
  
  

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="nose.html" title="Running tests written for nose"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="recwarn.html" title="Asserting Warnings"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="contents.html">pytest-2.7.3.dev376+ng06b1b69.d20150827</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="apiref.html" accesskey="U">pytest reference documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="support-for-unittest-testcase-integration-of-fixtures">
<span id="unittest-testcase"></span><h1>Support for unittest.TestCase / Integration of fixtures<a class="headerlink" href="#support-for-unittest-testcase-integration-of-fixtures" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal"><span class="pre">pytest</span></code> has support for running Python <a class="reference external" href="http://docs.python.org/library/unittest.html">unittest.py style</a> tests.
It&#8217;s meant for leveraging existing unittest-style projects
to use pytest features.  Concretely, pytest will automatically
collect <code class="docutils literal"><span class="pre">unittest.TestCase</span></code> subclasses and their <code class="docutils literal"><span class="pre">test</span></code> methods in
test files.  It will invoke typical setup/teardown methods and
generally try to make test suites written to run on unittest, to also
run using <code class="docutils literal"><span class="pre">pytest</span></code>.  We assume here that you are familiar with writing
<code class="docutils literal"><span class="pre">unittest.TestCase</span></code> style tests and rather focus on
integration aspects.</p>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>After <a class="reference internal" href="getting-started.html#installation"><span>Installation</span></a> type:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">py</span><span class="o">.</span><span class="n">test</span>
</pre></div>
</div>
<p>and you should be able to run your unittest-style tests if they
are contained in <code class="docutils literal"><span class="pre">test_*</span></code> modules.  If that works for you then
you can make use of most <a class="reference internal" href="index.html#features"><span>pytest features</span></a>, for example
<code class="docutils literal"><span class="pre">--pdb</span></code> debugging in failures, using <a class="reference internal" href="assert.html#assert"><span>plain assert-statements</span></a>,
<a class="reference internal" href="example/reportingdemo.html#tbreportdemo"><span>more informative tracebacks</span></a>, stdout-capturing or
distributing tests to multiple CPUs via the <code class="docutils literal"><span class="pre">-nNUM</span></code> option if you
installed the <code class="docutils literal"><span class="pre">pytest-xdist</span></code> plugin.  Please refer to
the general <code class="docutils literal"><span class="pre">pytest</span></code> documentation for many more examples.</p>
</div>
<div class="section" id="mixing-pytest-fixtures-into-unittest-testcase-style-tests">
<h2>Mixing pytest fixtures into unittest.TestCase style tests<a class="headerlink" href="#mixing-pytest-fixtures-into-unittest-testcase-style-tests" title="Permalink to this headline">¶</a></h2>
<p>Running your unittest with <code class="docutils literal"><span class="pre">pytest</span></code> allows you to use its
<a class="reference internal" href="fixture.html#fixture"><span>fixture mechanism</span></a> with <code class="docutils literal"><span class="pre">unittest.TestCase</span></code> style
tests.  Assuming you have at least skimmed the pytest fixture features,
let&#8217;s jump-start into an example that integrates a pytest <code class="docutils literal"><span class="pre">db_class</span></code>
fixture, setting up a class-cached database object, and then reference
it from a unittest-style test:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># content of conftest.py</span>

<span class="c"># we define a fixture function below and it will be &quot;used&quot; by</span>
<span class="c"># referencing its name from tests</span>

<span class="kn">import</span> <span class="nn">pytest</span>

<span class="nd">@pytest.fixture</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="s">&quot;class&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">db_class</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">DummyDB</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="c"># set a class attribute on the invoking test context</span>
    <span class="n">request</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="n">DummyDB</span><span class="p">()</span>
</pre></div>
</div>
<p>This defines a fixture function <code class="docutils literal"><span class="pre">db_class</span></code> which - if used - is
called once for each test class and which sets the class-level
<code class="docutils literal"><span class="pre">db</span></code> attribute to a <code class="docutils literal"><span class="pre">DummyDB</span></code> instance.  The fixture function
achieves this by receiving a special <code class="docutils literal"><span class="pre">request</span></code> object which gives
access to <a class="reference internal" href="fixture.html#request-context"><span>the requesting test context</span></a> such
as the <code class="docutils literal"><span class="pre">cls</span></code> attribute, denoting the class from which the fixture
is used.  This architecture de-couples fixture writing from actual test
code and allows re-use of the fixture by a minimal reference, the fixture
name.  So let&#8217;s write an actual <code class="docutils literal"><span class="pre">unittest.TestCase</span></code> class using our
fixture definition:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># content of test_unittest_db.py</span>

<span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">import</span> <span class="nn">pytest</span>

<span class="nd">@pytest.mark.usefixtures</span><span class="p">(</span><span class="s">&quot;db_class&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MyTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_method1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;db&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">db</span>   <span class="c"># fail for demo purposes</span>

    <span class="k">def</span> <span class="nf">test_method2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">db</span>   <span class="c"># fail for demo purposes</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">&#64;pytest.mark.usefixtures(&quot;db_class&quot;)</span></code> class-decorator makes sure that
the pytest fixture function <code class="docutils literal"><span class="pre">db_class</span></code> is called once per class.
Due to the deliberately failing assert statements, we can take a look at
the <code class="docutils literal"><span class="pre">self.db</span></code> values in the traceback:</p>
<div class="highlight-python"><div class="highlight"><pre>$ py.test test_unittest_db.py
======= test session starts ========
platform linux2 -- Python 2.7.9, pytest-2.8.0.dev4, py-1.4.28, pluggy-0.3.0
rootdir: $REGENDOC_TMPDIR, inifile:
collected 2 items

test_unittest_db.py FF

======= FAILURES ========
_______ MyTest.test_method1 ________

self = &lt;test_unittest_db.MyTest testMethod=test_method1&gt;

    def test_method1(self):
        assert hasattr(self, &quot;db&quot;)
&gt;       assert 0, self.db   # fail for demo purposes
E       AssertionError: &lt;conftest.DummyDB instance at 0xdeadbeef&gt;
E       assert 0

test_unittest_db.py:9: AssertionError
_______ MyTest.test_method2 ________

self = &lt;test_unittest_db.MyTest testMethod=test_method2&gt;

    def test_method2(self):
&gt;       assert 0, self.db   # fail for demo purposes
E       AssertionError: &lt;conftest.DummyDB instance at 0xdeadbeef&gt;
E       assert 0

test_unittest_db.py:12: AssertionError
======= 2 failed in 0.12 seconds ========
</pre></div>
</div>
<p>This default pytest traceback shows that the two test methods
share the same <code class="docutils literal"><span class="pre">self.db</span></code> instance which was our intention
when writing the class-scoped fixture function above.</p>
</div>
<div class="section" id="autouse-fixtures-and-accessing-other-fixtures">
<h2>autouse fixtures and accessing other fixtures<a class="headerlink" href="#autouse-fixtures-and-accessing-other-fixtures" title="Permalink to this headline">¶</a></h2>
<p>Although it&#8217;s usually better to explicitely declare use of fixtures you need
for a given test, you may sometimes want to have fixtures that are
automatically used in a given context.  After all, the traditional
style of unittest-setup mandates the use of this implicit fixture writing
and chances are, you are used to it or like it.</p>
<p>You can flag fixture functions with <code class="docutils literal"><span class="pre">&#64;pytest.fixture(autouse=True)</span></code>
and define the fixture function in the context where you want it used.
Let&#8217;s look at an <code class="docutils literal"><span class="pre">initdir</span></code> fixture which makes all test methods of a
<code class="docutils literal"><span class="pre">TestCase</span></code> class execute in a temporary directory with a
pre-initialized <code class="docutils literal"><span class="pre">samplefile.ini</span></code>.  Our <code class="docutils literal"><span class="pre">initdir</span></code> fixture itself uses
the pytest builtin <a class="reference internal" href="tmpdir.html#tmpdir"><span>tmpdir</span></a> fixture to delegate the
creation of a per-test temporary directory:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># content of test_unittest_cleandir.py</span>
<span class="kn">import</span> <span class="nn">pytest</span>
<span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">MyTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="nd">@pytest.fixture</span><span class="p">(</span><span class="n">autouse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">initdir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmpdir</span><span class="p">):</span>
        <span class="n">tmpdir</span><span class="o">.</span><span class="n">chdir</span><span class="p">()</span> <span class="c"># change to pytest-provided temporary directory</span>
        <span class="n">tmpdir</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;samplefile.ini&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;# testdata&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;samplefile.ini&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">assert</span> <span class="s">&quot;testdata&quot;</span> <span class="ow">in</span> <span class="n">s</span>
</pre></div>
</div>
<p>Due to the <code class="docutils literal"><span class="pre">autouse</span></code> flag the <code class="docutils literal"><span class="pre">initdir</span></code> fixture function will be
used for all methods of the class where it is defined.  This is a
shortcut for using a <code class="docutils literal"><span class="pre">&#64;pytest.mark.usefixtures(&quot;initdir&quot;)</span></code> marker
on the class like in the previous example.</p>
<p>Running this test module ...:</p>
<div class="highlight-python"><div class="highlight"><pre>$ py.test -q test_unittest_cleandir.py
.
1 passed in 0.12 seconds
</pre></div>
</div>
<p>... gives us one passed test because the <code class="docutils literal"><span class="pre">initdir</span></code> fixture function
was executed ahead of the <code class="docutils literal"><span class="pre">test_method</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While pytest supports receiving fixtures via <a class="reference internal" href="fixture.html#funcargs"><span>test function arguments</span></a> for non-unittest test methods, <code class="docutils literal"><span class="pre">unittest.TestCase</span></code> methods cannot directly receive fixture
function arguments as implementing that is likely to inflict
on the ability to run general unittest.TestCase test suites.
Maybe optional support would be possible, though.  If unittest finally
grows a plugin system that should help as well.  In the meanwhile, the
above <code class="docutils literal"><span class="pre">usefixtures</span></code> and <code class="docutils literal"><span class="pre">autouse</span></code> examples should help to mix in
pytest fixtures into unittest suites.  And of course you can also start
to selectively leave away the <code class="docutils literal"><span class="pre">unittest.TestCase</span></code> subclassing, use
plain asserts and get the unlimited pytest feature set.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="contents.html">
              <img class="logo" src="_static/pytest1.png" alt="Logo"/>
            </a></p><h3><a href="contents.html">Table Of Contents</a></h3>

<ul>
  <li><a href="index.html">Home</a></li>
  <li><a href="contents.html">Contents</a></li>
  <li><a href="getting-started.html">Install</a></li>
  <li><a href="example/index.html">Examples</a></li>
  <li><a href="customize.html">Customize</a></li>
  <li><a href="contact.html">Contact</a></li>
  <li><a href="talks.html">Talks/Posts</a></li>
  <li><a href="changelog.html">Changelog</a></li>
</ul>
  <hr>
  <ul>
<li><a class="reference internal" href="#">Support for unittest.TestCase / Integration of fixtures</a><ul>
<li><a class="reference internal" href="#usage">Usage</a></li>
<li><a class="reference internal" href="#mixing-pytest-fixtures-into-unittest-testcase-style-tests">Mixing pytest fixtures into unittest.TestCase style tests</a></li>
<li><a class="reference internal" href="#autouse-fixtures-and-accessing-other-fixtures">autouse fixtures and accessing other fixtures</a></li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="contents.html">Documentation overview</a><ul>
  <li><a href="apiref.html">pytest reference documentation</a><ul>
      <li>Previous: <a href="recwarn.html" title="previous chapter">Asserting Warnings</a></li>
      <li>Next: <a href="nose.html" title="next chapter">Running tests written for nose</a></li>
  </ul></li>
  </ul></li>
</ul><h3>Useful Links</h3>
<ul>
  <li><a href="index.html">The pytest Website</a></li>
  <li><a href="contributing.html">Contribution Guide</a></li>
  <li><a href="https://pypi.python.org/pypi/pytest">pytest @ PyPI</a></li>
  <li><a href="https://github.com/pytest-dev/pytest/">pytest @ GitHub</a></li>
  <li><a href="http://pytest.org/latest/plugins_index/index.html">3rd party plugins</a></li>
  <li><a href="https://github.com/pytest-dev/pytest/issues">Issue Tracker</a></li>
  <li><a href="http://pytest.org/latest/pytest.pdf">PDF Documentation</a>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

  <div class="footer">
    &copy; Copyright 2015, holger krekel and pytest-dev team.
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-7597274-13']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </body>
</html>