.. _recipes:

*******
Recipes
*******


Base Schema I
=============

A common pattern with `marshmallow` is to define a base `Schema <marshmallow.Schema>` class which has common configuration and behavior for your application's `Schemas`.

You may want to define a common session object, e.g. a `scoped_session <sqlalchemy.orm.scoping.scoped_session>` to use for all `Schemas <marshmallow.Schema>`.


.. code-block:: python

    # myproject/db.py
    import sqlalchemy as sa
    from sqlalchemy import orm

    Session = orm.scoped_session(orm.sessionmaker())
    Session.configure(bind=engine)

.. code-block:: python

    # myproject/schemas.py

    from marshmallow_sqlalchemy import ModelSchema

    from .db import Session

    class BaseSchema(ModelSchema):
        class Meta:
            sqla_session = Session


.. code-block:: python
    :emphasize-lines: 9

    # myproject/users/schemas.py

    from ..schemas import BaseSchema
    from .models import User

    class UserSchema(BaseSchema):

        # Inherit BaseSchema's options
        class Meta(BaseSchema.Meta):
            model = User

Base Schema II
==============

Here is an alternative way to define a BaseSchema class with a common ``Session`` object.

.. code-block:: python

    # myproject/schemas.py

    from marshmallow_sqlalchemy import SchemaOpts
    from .db import Session

    class BaseOpts(SchemaOpts):
        def __init__(self, meta):
            if not hasattr(meta, 'sql_session'):
                meta.sqla_session = Session
            super(BaseOpts, self).__init__(meta)

    class BaseSchema(ModelSchema):
        OPTIONS_CLASS = BaseOpts


This allows you to define class Meta options without having to subclass ``BaseSchema.Meta``.

.. code-block:: python
    :emphasize-lines: 8

    # myproject/users/schemas.py

    from ..schemas import BaseSchema
    from .models import User

    class UserSchema(BaseSchema):

        class Meta:
            model = User

Introspecting Generated Fields
==============================

It is often useful to introspect what fields are generated for a `ModelSchema <marshmallow_sqlalchemy.ModelSchema>`.

Generated fields are added to a `Schema's` ``_declared_fields`` attribute.

.. code-block:: python

    AuthorSchema._declared_fields['books']
    # <fields.QuerySelectList(default=<marshmallow.missing>, ...>


You can also use `marshmallow_sqlalchemy's` conversion functions directly.


.. code-block:: python

    from marshmallow_sqlalchemy import property2field

    id_prop = Author.__mapper__.get_property('id')

    property2field(id_prop)
    # <fields.Integer(default=<marshmallow.missing>, ...>

Overriding Generated Fields
===========================

Any field generated by a `ModelSchema <marshmallow_sqlalchemy.ModelSchema>` can be overridden.

.. code-block:: python

    from marshmallow import fields
    from marshmallow_sqlalchemy import ModelSchema

    class AuthorSchema(ModelSchema):
        # Override books field to use a nested representation rather than pks
        books = fields.Nested(BookSchema, many=True, exclude=('author', ))
        class Meta:
            model = Author
            sqla_session = Session

You can use the `field_for <marshmallow_sqlalchemy.field_for>` function to generate a marshmallow `Field <marshmallow.fields.Field>` based on single model property. This is useful for passing additional keyword arguments to the generated field.

.. code-block:: python

    from marshmallow_sqlalchemy import ModelSchema, field_for

    class AuthorSchema(ModelSchema):
        # Generate a field, passing in an additional dump_only argument
        date_created = field_for(Author, 'date_created', dump_only=True)

        class Meta:
            model = Author
            sqla_session = Session
