<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Example File System &mdash; Python-LLFUSE 0.41 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.41',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Python-LLFUSE 0.41 documentation" href="index.html" />
    <link rel="prev" title="Request Handlers" href="operations.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="operations.html" title="Request Handlers"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Python-LLFUSE 0.41 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="example-file-system">
<span id="id1"></span><h1>Example File System<a class="headerlink" href="#example-file-system" title="Permalink to this headline">Â¶</a></h1>
<p>The following is an example of a very simple in-memry file system
based on Python-LLFUSE (this example is also included in the Python-LLFUSE tarball as
<tt class="file docutils literal"><span class="pre">examples/tmpfs.py</span></tt>).</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427</pre></div></td><td class="code"><div class="highlight"><pre>the terms of the GNU LGPL.
&#39;&#39;&#39;

from __future__ import division, print_function, absolute_import

import os
import sys

# We are running from the Python-LLFUSE source directory, make sure
# that we use modules from this directory
basedir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), &#39;..&#39;))
if (os.path.exists(os.path.join(basedir, &#39;setup.py&#39;)) and
    os.path.exists(os.path.join(basedir, &#39;src&#39;, &#39;llfuse&#39;))):
    sys.path = [os.path.join(basedir, &#39;src&#39;)] + sys.path

import llfuse
import errno
import stat
from time import time
import sqlite3
import logging
from collections import defaultdict
from llfuse import FUSEError
from argparse import ArgumentParser

log = logging.getLogger()

# For Python 2 + 3 compatibility
if sys.version_info[0] == 2:
    def next(it):
        return it.next()
else:
    buffer = memoryview

class Operations(llfuse.Operations):
    &#39;&#39;&#39;An example filesystem that stores all data in memory

    This is a very simple implementation with terrible performance.
    Don&#39;t try to store significant amounts of data. Also, there are
    some other flaws that have not been fixed to keep the code easier
    to understand:

    * atime, mtime and ctime are not updated
    * generation numbers are not supported
    &#39;&#39;&#39;


    def __init__(self):
        super(Operations, self).__init__()
        self.db = sqlite3.connect(&#39;:memory:&#39;)
        self.db.text_factory = str
        self.db.row_factory = sqlite3.Row
        self.cursor = self.db.cursor()
        self.inode_open_count = defaultdict(int)
        self.init_tables()

    def init_tables(self):
        &#39;&#39;&#39;Initialize file system tables&#39;&#39;&#39;

        self.cursor.execute(&quot;&quot;&quot;
        CREATE TABLE inodes (
            id        INTEGER PRIMARY KEY,
            uid       INT NOT NULL,
            gid       INT NOT NULL,
            mode      INT NOT NULL,
            mtime_ns  INT NOT NULL,
            atime_ns  INT NOT NULL,
            ctime_ns  INT NOT NULL,
            target    BLOB(256) ,
            size      INT NOT NULL DEFAULT 0,
            rdev      INT NOT NULL DEFAULT 0,
            data      BLOB
        )
        &quot;&quot;&quot;)

        self.cursor.execute(&quot;&quot;&quot;
        CREATE TABLE contents (
            rowid     INTEGER PRIMARY KEY AUTOINCREMENT,
            name      BLOB(256) NOT NULL,
            inode     INT NOT NULL REFERENCES inodes(id),
            parent_inode INT NOT NULL REFERENCES inodes(id),

            UNIQUE (name, parent_inode)
        )&quot;&quot;&quot;)

        # Insert root directory
        now_ns = int(time() * 1e9)
        self.cursor.execute(&quot;INSERT INTO inodes (id,mode,uid,gid,mtime_ns,atime_ns,ctime_ns) &quot;
                            &quot;VALUES (?,?,?,?,?,?,?)&quot;,
                            (llfuse.ROOT_INODE, stat.S_IFDIR | stat.S_IRUSR | stat.S_IWUSR
                              | stat.S_IXUSR | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH
                              | stat.S_IXOTH, os.getuid(), os.getgid(), now_ns, now_ns, now_ns))
        self.cursor.execute(&quot;INSERT INTO contents (name, parent_inode, inode) VALUES (?,?,?)&quot;,
                            (b&#39;..&#39;, llfuse.ROOT_INODE, llfuse.ROOT_INODE))


    def get_row(self, *a, **kw):
        self.cursor.execute(*a, **kw)
        try:
            row = next(self.cursor)
        except StopIteration:
            raise NoSuchRowError()
        try:
            next(self.cursor)
        except StopIteration:
            pass
        else:
            raise NoUniqueValueError()

        return row

    def lookup(self, inode_p, name):
        if name == &#39;.&#39;:
            inode = inode_p
        elif name == &#39;..&#39;:
            inode = self.get_row(&quot;SELECT * FROM contents WHERE inode=?&quot;,
                                 (inode_p,))[&#39;parent_inode&#39;]
        else:
            try:
                inode = self.get_row(&quot;SELECT * FROM contents WHERE name=? AND parent_inode=?&quot;,
                                     (name, inode_p))[&#39;inode&#39;]
            except NoSuchRowError:
                raise(llfuse.FUSEError(errno.ENOENT))

        return self.getattr(inode)


    def getattr(self, inode):
        row = self.get_row(&#39;SELECT * FROM inodes WHERE id=?&#39;, (inode,))

        entry = llfuse.EntryAttributes()
        entry.st_ino = inode
        entry.generation = 0
        entry.entry_timeout = 300
        entry.attr_timeout = 300
        entry.st_mode = row[&#39;mode&#39;]
        entry.st_nlink = self.get_row(&quot;SELECT COUNT(inode) FROM contents WHERE inode=?&quot;,
                                     (inode,))[0]
        entry.st_uid = row[&#39;uid&#39;]
        entry.st_gid = row[&#39;gid&#39;]
        entry.st_rdev = row[&#39;rdev&#39;]
        entry.st_size = row[&#39;size&#39;]

        entry.st_blksize = 512
        entry.st_blocks = 1
        entry.st_atime_ns = row[&#39;atime_ns&#39;]
        entry.st_mtime_ns = row[&#39;mtime_ns&#39;]
        entry.st_ctime_ns = row[&#39;ctime_ns&#39;]

        return entry

    def readlink(self, inode):
        return self.get_row(&#39;SELECT * FROM inodes WHERE id=?&#39;, (inode,))[&#39;target&#39;]

    def opendir(self, inode):
        return inode

    def readdir(self, inode, off):
        if off == 0:
            off = -1

        cursor2 = self.db.cursor()
        cursor2.execute(&quot;SELECT * FROM contents WHERE parent_inode=? &quot;
                        &#39;AND rowid &gt; ? ORDER BY rowid&#39;, (inode, off))

        for row in cursor2:
            yield (row[&#39;name&#39;], self.getattr(row[&#39;inode&#39;]), row[&#39;rowid&#39;])

    def unlink(self, inode_p, name):
        entry = self.lookup(inode_p, name)

        if stat.S_ISDIR(entry.st_mode):
            raise llfuse.FUSEError(errno.EISDIR)

        self._remove(inode_p, name, entry)

    def rmdir(self, inode_p, name):
        entry = self.lookup(inode_p, name)

        if not stat.S_ISDIR(entry.st_mode):
            raise llfuse.FUSEError(errno.ENOTDIR)

        self._remove(inode_p, name, entry)

    def _remove(self, inode_p, name, entry):
        if self.get_row(&quot;SELECT COUNT(inode) FROM contents WHERE parent_inode=?&quot;,
                        (entry.st_ino,))[0] &gt; 0:
            raise llfuse.FUSEError(errno.ENOTEMPTY)

        self.cursor.execute(&quot;DELETE FROM contents WHERE name=? AND parent_inode=?&quot;,
                        (name, inode_p))

        if entry.st_nlink == 1 and entry.st_ino not in self.inode_open_count:
            self.cursor.execute(&quot;DELETE FROM inodes WHERE id=?&quot;, (entry.st_ino,))

    def symlink(self, inode_p, name, target, ctx):
        mode = (stat.S_IFLNK | stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR |
                stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP |
                stat.S_IROTH | stat.S_IWOTH | stat.S_IXOTH)
        return self._create(inode_p, name, mode, ctx, target=target)

    def rename(self, inode_p_old, name_old, inode_p_new, name_new):
        entry_old = self.lookup(inode_p_old, name_old)

        try:
            entry_new = self.lookup(inode_p_new, name_new)
        except llfuse.FUSEError as exc:
            if exc.errno != errno.ENOENT:
                raise
            target_exists = False
        else:
            target_exists = True

        if target_exists:
            self._replace(inode_p_old, name_old, inode_p_new, name_new,
                          entry_old, entry_new)
        else:
            self.cursor.execute(&quot;UPDATE contents SET name=?, parent_inode=? WHERE name=? &quot;
                                &quot;AND parent_inode=?&quot;, (name_new, inode_p_new,
                                                       name_old, inode_p_old))

    def _replace(self, inode_p_old, name_old, inode_p_new, name_new,
                 entry_old, entry_new):

        if self.get_row(&quot;SELECT COUNT(inode) FROM contents WHERE parent_inode=?&quot;,
                        (entry_new.st_ino,))[0] &gt; 0:
            raise llfuse.FUSEError(errno.ENOTEMPTY)

        self.cursor.execute(&quot;UPDATE contents SET inode=? WHERE name=? AND parent_inode=?&quot;,
                            (entry_old.st_ino, name_new, inode_p_new))
        self.db.execute(&#39;DELETE FROM contents WHERE name=? AND parent_inode=?&#39;,
                        (name_old, inode_p_old))

        if entry_new.st_nlink == 1 and entry_new.st_ino not in self.inode_open_count:
            self.cursor.execute(&quot;DELETE FROM inodes WHERE id=?&quot;, (entry_new.st_ino,))


    def link(self, inode, new_inode_p, new_name):
        entry_p = self.getattr(new_inode_p)
        if entry_p.st_nlink == 0:
            log.warn(&#39;Attempted to create entry %s with unlinked parent %d&#39;,
                     new_name, new_inode_p)
            raise FUSEError(errno.EINVAL)

        self.cursor.execute(&quot;INSERT INTO contents (name, inode, parent_inode) VALUES(?,?,?)&quot;,
                            (new_name, inode, new_inode_p))

        return self.getattr(inode)

    def setattr(self, inode, attr):

        if attr.st_size is not None:
            data = self.get_row(&#39;SELECT data FROM inodes WHERE id=?&#39;, (inode,))[0]
            if data is None:
                data = b&#39;&#39;
            if len(data) &lt; attr.st_size:
                data = data + b&#39;\0&#39; * (attr.st_size - len(data))
            else:
                data = data[:attr.st_size]
            self.cursor.execute(&#39;UPDATE inodes SET data=?, size=? WHERE id=?&#39;,
                                (buffer(data), attr.st_size, inode))
        if attr.st_mode is not None:
            self.cursor.execute(&#39;UPDATE inodes SET mode=? WHERE id=?&#39;,
                                (attr.st_mode, inode))

        if attr.st_uid is not None:
            self.cursor.execute(&#39;UPDATE inodes SET uid=? WHERE id=?&#39;,
                                (attr.st_uid, inode))

        if attr.st_gid is not None:
            self.cursor.execute(&#39;UPDATE inodes SET gid=? WHERE id=?&#39;,
                                (attr.st_gid, inode))

        if attr.st_rdev is not None:
            self.cursor.execute(&#39;UPDATE inodes SET rdev=? WHERE id=?&#39;,
                                (attr.st_rdev, inode))

        if attr.st_atime_ns is not None:
            self.cursor.execute(&#39;UPDATE inodes SET atime_ns=? WHERE id=?&#39;,
                                (attr.st_atime_ns, inode))

        if attr.st_mtime_ns is not None:
            self.cursor.execute(&#39;UPDATE inodes SET mtime_ns=? WHERE id=?&#39;,
                                (attr.st_mtime_ns, inode))

        if attr.st_ctime_ns is not None:
            self.cursor.execute(&#39;UPDATE inodes SET ctime_ns=? WHERE id=?&#39;,
                                (attr.st_ctime_ns, inode))

        return self.getattr(inode)

    def mknod(self, inode_p, name, mode, rdev, ctx):
        return self._create(inode_p, name, mode, ctx, rdev=rdev)

    def mkdir(self, inode_p, name, mode, ctx):
        return self._create(inode_p, name, mode, ctx)

    def statfs(self):
        stat_ = llfuse.StatvfsData()

        stat_.f_bsize = 512
        stat_.f_frsize = 512

        size = self.get_row(&#39;SELECT SUM(size) FROM inodes&#39;)[0]
        stat_.f_blocks = size // stat_.f_frsize
        stat_.f_bfree = max(size // stat_.f_frsize, 1024)
        stat_.f_bavail = stat_.f_bfree

        inodes = self.get_row(&#39;SELECT COUNT(id) FROM inodes&#39;)[0]
        stat_.f_files = inodes
        stat_.f_ffree = max(inodes , 100)
        stat_.f_favail = stat_.f_ffree

        return stat_

    def open(self, inode, flags):
        # Yeah, unused arguments
        #pylint: disable=W0613
        self.inode_open_count[inode] += 1

        # Use inodes as a file handles
        return inode

    def access(self, inode, mode, ctx):
        # Yeah, could be a function and has unused arguments
        #pylint: disable=R0201,W0613
        return True

    def create(self, inode_parent, name, mode, flags, ctx):
        #pylint: disable=W0612
        entry = self._create(inode_parent, name, mode, ctx)
        self.inode_open_count[entry.st_ino] += 1
        return (entry.st_ino, entry)

    def _create(self, inode_p, name, mode, ctx, rdev=0, target=None):
        if self.getattr(inode_p).st_nlink == 0:
            log.warn(&#39;Attempted to create entry %s with unlinked parent %d&#39;,
                     name, inode_p)
            raise FUSEError(errno.EINVAL)

        now_ns = int(time() * 1e9)
        self.cursor.execute(&#39;INSERT INTO inodes (uid, gid, mode, mtime_ns, atime_ns, &#39;
                            &#39;ctime_ns, target, rdev) VALUES(?, ?, ?, ?, ?, ?, ?, ?)&#39;,
                            (ctx.uid, ctx.gid, mode, now_ns, now_ns, now_ns, target, rdev))

        inode = self.cursor.lastrowid
        self.db.execute(&quot;INSERT INTO contents(name, inode, parent_inode) VALUES(?,?,?)&quot;,
                        (name, inode, inode_p))
        return self.getattr(inode)

    def read(self, fh, offset, length):
        data = self.get_row(&#39;SELECT data FROM inodes WHERE id=?&#39;, (fh,))[0]
        if data is None:
            data = b&#39;&#39;
        return data[offset:offset+length]

    def write(self, fh, offset, buf):
        data = self.get_row(&#39;SELECT data FROM inodes WHERE id=?&#39;, (fh,))[0]
        if data is None:
            data = b&#39;&#39;
        data = data[:offset] + buf + data[offset+len(buf):]

        self.cursor.execute(&#39;UPDATE inodes SET data=?, size=? WHERE id=?&#39;,
                            (buffer(data), len(data), fh))
        return len(buf)

    def release(self, fh):
        self.inode_open_count[fh] -= 1

        if self.inode_open_count[fh] == 0:
            del self.inode_open_count[fh]
            if self.getattr(fh).st_nlink == 0:
                self.cursor.execute(&quot;DELETE FROM inodes WHERE id=?&quot;, (fh,))

class NoUniqueValueError(Exception):
    def __str__(self):
        return &#39;Query generated more than 1 result row&#39;


class NoSuchRowError(Exception):
    def __str__(self):
        return &#39;Query produced 0 result rows&#39;

def init_logging(debug=False):
    formatter = logging.Formatter(&#39;%(asctime)s.%(msecs)03d %(threadName)s: &#39;
                                  &#39;[%(name)s] %(message)s&#39;, datefmt=&quot;%Y-%m-%d %H:%M:%S&quot;)
    handler = logging.StreamHandler()
    handler.setFormatter(formatter)
    root_logger = logging.getLogger()
    if debug:
        handler.setLevel(logging.DEBUG)
        root_logger.setLevel(logging.DEBUG)
    else:
        handler.setLevel(logging.INFO)
        root_logger.setLevel(logging.INFO)
    root_logger.addHandler(handler)

def parse_args():
    &#39;&#39;&#39;Parse command line&#39;&#39;&#39;

    parser = ArgumentParser()

    parser.add_argument(&#39;mountpoint&#39;, type=str,
                        help=&#39;Where to mount the file system&#39;)
    parser.add_argument(&#39;--debug&#39;, action=&#39;store_true&#39;, default=False,
                        help=&#39;Enable debugging output&#39;)

    return parser.parse_args()


if __name__ == &#39;__main__&#39;:

    options = parse_args()
    init_logging(options.debug)
    operations = Operations()

    llfuse.init(operations, options.mountpoint,
                [  &#39;fsname=tmpfs&#39;, &quot;nonempty&quot; ])

    # sqlite3 does not support multithreading
    try:
        llfuse.main(single=True)
    except:
        llfuse.close(unmount=False)
        raise

    llfuse.close()
</pre></div>
</td></tr></table></div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"><h3><a href="index.html">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installing Python-LLFUSE</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="fuse_api.html">FUSE API Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="data.html">Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="lock.html">The global lock</a></li>
<li class="toctree-l1"><a class="reference internal" href="operations.html">Request Handlers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Example File System</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="operations.html"
                        title="previous chapter">Request Handlers</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="operations.html" title="Request Handlers"
             >previous</a> |</li>
        <li><a href="index.html">Python-LLFUSE 0.41 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010-2015, Nikolaus Rath.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>