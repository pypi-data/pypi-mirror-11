# encoding: utf-8
#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import emq.common.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Permission(object):
  NONE = 0
  SEND_MESSAGE = 1
  RECEIVE_MESSAGE = 2
  SEND_RECEIVE_MESSAGE = 3
  HANDLE_MESSAGE = 4
  SEND_HANDLE_MESSAGE = 5
  GET_QUEUE_INFO = 6
  USE_QUEUE = 7
  ADMIN_QUEUE = 8
  FULL_CONTROL = 9

  _VALUES_TO_NAMES = {
    0: "NONE",
    1: "SEND_MESSAGE",
    2: "RECEIVE_MESSAGE",
    3: "SEND_RECEIVE_MESSAGE",
    4: "HANDLE_MESSAGE",
    5: "SEND_HANDLE_MESSAGE",
    6: "GET_QUEUE_INFO",
    7: "USE_QUEUE",
    8: "ADMIN_QUEUE",
    9: "FULL_CONTROL",
  }

  _NAMES_TO_VALUES = {
    "NONE": 0,
    "SEND_MESSAGE": 1,
    "RECEIVE_MESSAGE": 2,
    "SEND_RECEIVE_MESSAGE": 3,
    "HANDLE_MESSAGE": 4,
    "SEND_HANDLE_MESSAGE": 5,
    "GET_QUEUE_INFO": 6,
    "USE_QUEUE": 7,
    "ADMIN_QUEUE": 8,
    "FULL_CONTROL": 9,
  }


class QueueAttribute(object):
  """
  Copyright 2015, Xiaomi.
  All rights reserved.
  Author: shenyuannan@xiaomi.com

  Attributes:
   - delaySeconds: Queue delay seconds, message send to this queue will invisible until after
  delaySeconds, default 0s (0s ~ 15min)

   - invisibilitySeconds: Queue invisibility seconds, after message received form this queue, in
  invisibilitySeconds this will not received through receiveMessage. When
  after invisibilitySeconds if no deleteMessage called for this message, this
  message will receive again, default 30s (2s ~ 12hour)

   - receiveMessageWaitSeconds: The seconds wait when receiveMessage called, default 0s (0s ~ 20s)

   - receiveMessageMaximumNumber: Maximum receive message number in this queue, default 100(1 ~ 100)

   - messageRetentionSeconds: message retention seconds in this queue, default 4days (60s ~ 14days)

   - messageMaximumBytes: Max message size in this queue, default 256K (1K ~ 256K)

   - partitionNumber: Partition number for this queue default 4 (1 ~ 255)

   - userAttributes: User-defined attributes

  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'delaySeconds', None, None, ), # 1
    (2, TType.I32, 'invisibilitySeconds', None, None, ), # 2
    (3, TType.I32, 'receiveMessageWaitSeconds', None, None, ), # 3
    (4, TType.I32, 'receiveMessageMaximumNumber', None, None, ), # 4
    (5, TType.I32, 'messageRetentionSeconds', None, None, ), # 5
    (6, TType.I32, 'messageMaximumBytes', None, None, ), # 6
    (7, TType.I32, 'partitionNumber', None, None, ), # 7
    (8, TType.MAP, 'userAttributes', (TType.STRING,None,TType.STRING,None), None, ), # 8
  )

  def __init__(self, delaySeconds=None, invisibilitySeconds=None, receiveMessageWaitSeconds=None, receiveMessageMaximumNumber=None, messageRetentionSeconds=None, messageMaximumBytes=None, partitionNumber=None, userAttributes=None,):
    self.delaySeconds = delaySeconds
    self.invisibilitySeconds = invisibilitySeconds
    self.receiveMessageWaitSeconds = receiveMessageWaitSeconds
    self.receiveMessageMaximumNumber = receiveMessageMaximumNumber
    self.messageRetentionSeconds = messageRetentionSeconds
    self.messageMaximumBytes = messageMaximumBytes
    self.partitionNumber = partitionNumber
    self.userAttributes = userAttributes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.delaySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.invisibilitySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.receiveMessageWaitSeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.receiveMessageMaximumNumber = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.messageRetentionSeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.messageMaximumBytes = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.partitionNumber = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.MAP:
          self.userAttributes = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in xrange(_size0):
            _key5 = iprot.readString();
            _val6 = iprot.readString();
            self.userAttributes[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueueAttribute')
    if self.delaySeconds is not None:
      oprot.writeFieldBegin('delaySeconds', TType.I32, 1)
      oprot.writeI32(self.delaySeconds)
      oprot.writeFieldEnd()
    if self.invisibilitySeconds is not None:
      oprot.writeFieldBegin('invisibilitySeconds', TType.I32, 2)
      oprot.writeI32(self.invisibilitySeconds)
      oprot.writeFieldEnd()
    if self.receiveMessageWaitSeconds is not None:
      oprot.writeFieldBegin('receiveMessageWaitSeconds', TType.I32, 3)
      oprot.writeI32(self.receiveMessageWaitSeconds)
      oprot.writeFieldEnd()
    if self.receiveMessageMaximumNumber is not None:
      oprot.writeFieldBegin('receiveMessageMaximumNumber', TType.I32, 4)
      oprot.writeI32(self.receiveMessageMaximumNumber)
      oprot.writeFieldEnd()
    if self.messageRetentionSeconds is not None:
      oprot.writeFieldBegin('messageRetentionSeconds', TType.I32, 5)
      oprot.writeI32(self.messageRetentionSeconds)
      oprot.writeFieldEnd()
    if self.messageMaximumBytes is not None:
      oprot.writeFieldBegin('messageMaximumBytes', TType.I32, 6)
      oprot.writeI32(self.messageMaximumBytes)
      oprot.writeFieldEnd()
    if self.partitionNumber is not None:
      oprot.writeFieldBegin('partitionNumber', TType.I32, 7)
      oprot.writeI32(self.partitionNumber)
      oprot.writeFieldEnd()
    if self.userAttributes is not None:
      oprot.writeFieldBegin('userAttributes', TType.MAP, 8)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.userAttributes))
      for kiter7,viter8 in self.userAttributes.items():
        oprot.writeString(kiter7)
        oprot.writeString(viter8)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.delaySeconds)
    value = (value * 31) ^ hash(self.invisibilitySeconds)
    value = (value * 31) ^ hash(self.receiveMessageWaitSeconds)
    value = (value * 31) ^ hash(self.receiveMessageMaximumNumber)
    value = (value * 31) ^ hash(self.messageRetentionSeconds)
    value = (value * 31) ^ hash(self.messageMaximumBytes)
    value = (value * 31) ^ hash(self.partitionNumber)
    value = (value * 31) ^ hash(self.userAttributes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueueState(object):
  """
  Attributes:
   - createTimestamp: Queue create timestamp;

   - lastModifiedTimestamp: Queue last modified timestamp;

   - approximateMessageNumber: The approximate message number in this queue;

   - approximateAvailableMessageNumber: The available message number in this queue, this is for message that could
  be get using receivedMesasge

   - approximateInvisibilityMessageNumber: The invisibility message number in this queue, this is for received message
  that in invisibilitySeconds and not deleted;

  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'createTimestamp', None, None, ), # 1
    (2, TType.I64, 'lastModifiedTimestamp', None, None, ), # 2
    (3, TType.I64, 'approximateMessageNumber', None, None, ), # 3
    (4, TType.I64, 'approximateAvailableMessageNumber', None, None, ), # 4
    (5, TType.I64, 'approximateInvisibilityMessageNumber', None, None, ), # 5
  )

  def __init__(self, createTimestamp=None, lastModifiedTimestamp=None, approximateMessageNumber=None, approximateAvailableMessageNumber=None, approximateInvisibilityMessageNumber=None,):
    self.createTimestamp = createTimestamp
    self.lastModifiedTimestamp = lastModifiedTimestamp
    self.approximateMessageNumber = approximateMessageNumber
    self.approximateAvailableMessageNumber = approximateAvailableMessageNumber
    self.approximateInvisibilityMessageNumber = approximateInvisibilityMessageNumber

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.createTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.lastModifiedTimestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.approximateMessageNumber = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.approximateAvailableMessageNumber = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.approximateInvisibilityMessageNumber = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueueState')
    if self.createTimestamp is not None:
      oprot.writeFieldBegin('createTimestamp', TType.I64, 1)
      oprot.writeI64(self.createTimestamp)
      oprot.writeFieldEnd()
    if self.lastModifiedTimestamp is not None:
      oprot.writeFieldBegin('lastModifiedTimestamp', TType.I64, 2)
      oprot.writeI64(self.lastModifiedTimestamp)
      oprot.writeFieldEnd()
    if self.approximateMessageNumber is not None:
      oprot.writeFieldBegin('approximateMessageNumber', TType.I64, 3)
      oprot.writeI64(self.approximateMessageNumber)
      oprot.writeFieldEnd()
    if self.approximateAvailableMessageNumber is not None:
      oprot.writeFieldBegin('approximateAvailableMessageNumber', TType.I64, 4)
      oprot.writeI64(self.approximateAvailableMessageNumber)
      oprot.writeFieldEnd()
    if self.approximateInvisibilityMessageNumber is not None:
      oprot.writeFieldBegin('approximateInvisibilityMessageNumber', TType.I64, 5)
      oprot.writeI64(self.approximateInvisibilityMessageNumber)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.createTimestamp is None:
      raise TProtocol.TProtocolException(message='Required field createTimestamp is unset!')
    if self.lastModifiedTimestamp is None:
      raise TProtocol.TProtocolException(message='Required field lastModifiedTimestamp is unset!')
    if self.approximateMessageNumber is None:
      raise TProtocol.TProtocolException(message='Required field approximateMessageNumber is unset!')
    if self.approximateAvailableMessageNumber is None:
      raise TProtocol.TProtocolException(message='Required field approximateAvailableMessageNumber is unset!')
    if self.approximateInvisibilityMessageNumber is None:
      raise TProtocol.TProtocolException(message='Required field approximateInvisibilityMessageNumber is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.createTimestamp)
    value = (value * 31) ^ hash(self.lastModifiedTimestamp)
    value = (value * 31) ^ hash(self.approximateMessageNumber)
    value = (value * 31) ^ hash(self.approximateAvailableMessageNumber)
    value = (value * 31) ^ hash(self.approximateInvisibilityMessageNumber)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateQueueRequest(object):
  """
  Attributes:
   - queueName: The queue name

   - queueAttribute: The queue attribute

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRUCT, 'queueAttribute', (QueueAttribute, QueueAttribute.thrift_spec), None, ), # 2
  )

  def __init__(self, queueName=None, queueAttribute=None,):
    self.queueName = queueName
    self.queueAttribute = queueAttribute

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.queueAttribute = QueueAttribute()
          self.queueAttribute.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateQueueRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.queueAttribute is not None:
      oprot.writeFieldBegin('queueAttribute', TType.STRUCT, 2)
      self.queueAttribute.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.queueAttribute)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CreateQueueResponse(object):
  """
  Attributes:
   - queueName: The queue name
  The name returned here may be a little different from user set in request (with developerId as prefix).
  So the user should use the name returned by this response for those following operations

   - queueAttribute: The queue attribute;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRUCT, 'queueAttribute', (QueueAttribute, QueueAttribute.thrift_spec), None, ), # 2
  )

  def __init__(self, queueName=None, queueAttribute=None,):
    self.queueName = queueName
    self.queueAttribute = queueAttribute

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.queueAttribute = QueueAttribute()
          self.queueAttribute.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CreateQueueResponse')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.queueAttribute is not None:
      oprot.writeFieldBegin('queueAttribute', TType.STRUCT, 2)
      self.queueAttribute.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.queueAttribute is None:
      raise TProtocol.TProtocolException(message='Required field queueAttribute is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.queueAttribute)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteQueueRequest(object):
  """
  Attributes:
   - queueName: The queue name;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
  )

  def __init__(self, queueName=None,):
    self.queueName = queueName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteQueueRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PurgeQueueRequest(object):
  """
  Attributes:
   - queueName: The queue name;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
  )

  def __init__(self, queueName=None,):
    self.queueName = queueName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PurgeQueueRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetQueueAttributesRequest(object):
  """
  Attributes:
   - queueName: The queue name

   - queueAttribute: The queue attribute

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRUCT, 'queueAttribute', (QueueAttribute, QueueAttribute.thrift_spec), None, ), # 2
  )

  def __init__(self, queueName=None, queueAttribute=None,):
    self.queueName = queueName
    self.queueAttribute = queueAttribute

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.queueAttribute = QueueAttribute()
          self.queueAttribute.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetQueueAttributesRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.queueAttribute is not None:
      oprot.writeFieldBegin('queueAttribute', TType.STRUCT, 2)
      self.queueAttribute.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.queueAttribute)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetQueueAttributesResponse(object):
  """
  Attributes:
   - queueName: The queue name

   - queueAttribute: The queue attribute;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRUCT, 'queueAttribute', (QueueAttribute, QueueAttribute.thrift_spec), None, ), # 2
  )

  def __init__(self, queueName=None, queueAttribute=None,):
    self.queueName = queueName
    self.queueAttribute = queueAttribute

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.queueAttribute = QueueAttribute()
          self.queueAttribute.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetQueueAttributesResponse')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.queueAttribute is not None:
      oprot.writeFieldBegin('queueAttribute', TType.STRUCT, 2)
      self.queueAttribute.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.queueAttribute is None:
      raise TProtocol.TProtocolException(message='Required field queueAttribute is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.queueAttribute)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetQueueInfoRequest(object):
  """
  Attributes:
   - queueName: The queue name;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
  )

  def __init__(self, queueName=None,):
    self.queueName = queueName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetQueueInfoRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetQueueInfoResponse(object):
  """
  Attributes:
   - queueName: The queue name

   - queueAttribute: The queue attribute;

   - queueState: The queue state;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRUCT, 'queueAttribute', (QueueAttribute, QueueAttribute.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'queueState', (QueueState, QueueState.thrift_spec), None, ), # 3
  )

  def __init__(self, queueName=None, queueAttribute=None, queueState=None,):
    self.queueName = queueName
    self.queueAttribute = queueAttribute
    self.queueState = queueState

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.queueAttribute = QueueAttribute()
          self.queueAttribute.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.queueState = QueueState()
          self.queueState.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetQueueInfoResponse')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.queueAttribute is not None:
      oprot.writeFieldBegin('queueAttribute', TType.STRUCT, 2)
      self.queueAttribute.write(oprot)
      oprot.writeFieldEnd()
    if self.queueState is not None:
      oprot.writeFieldBegin('queueState', TType.STRUCT, 3)
      self.queueState.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.queueAttribute is None:
      raise TProtocol.TProtocolException(message='Required field queueAttribute is unset!')
    if self.queueState is None:
      raise TProtocol.TProtocolException(message='Required field queueState is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.queueAttribute)
    value = (value * 31) ^ hash(self.queueState)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListQueueRequest(object):
  """
  Attributes:
   - queueNamePrefix: The queue name prefix;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueNamePrefix', None, "", ), # 1
  )

  def __init__(self, queueNamePrefix=thrift_spec[1][4],):
    self.queueNamePrefix = queueNamePrefix

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueNamePrefix = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListQueueRequest')
    if self.queueNamePrefix is not None:
      oprot.writeFieldBegin('queueNamePrefix', TType.STRING, 1)
      oprot.writeString(self.queueNamePrefix)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueNamePrefix)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListQueueResponse(object):
  """
  Attributes:
   - queueName: The queueName list with queueNamePrefix;

  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'queueName', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, queueName=None,):
    self.queueName = queueName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.queueName = []
          (_etype12, _size9) = iprot.readListBegin()
          for _i13 in xrange(_size9):
            _elem14 = iprot.readString();
            self.queueName.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListQueueResponse')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.queueName))
      for iter15 in self.queueName:
        oprot.writeString(iter15)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetPermissionRequest(object):
  """
  Attributes:
   - queueName
   - developerId
   - permission
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'developerId', None, None, ), # 2
    (3, TType.I32, 'permission', None, None, ), # 3
  )

  def __init__(self, queueName=None, developerId=None, permission=None,):
    self.queueName = queueName
    self.developerId = developerId
    self.permission = permission

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.developerId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.permission = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetPermissionRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.developerId is not None:
      oprot.writeFieldBegin('developerId', TType.STRING, 2)
      oprot.writeString(self.developerId)
      oprot.writeFieldEnd()
    if self.permission is not None:
      oprot.writeFieldBegin('permission', TType.I32, 3)
      oprot.writeI32(self.permission)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.developerId is None:
      raise TProtocol.TProtocolException(message='Required field developerId is unset!')
    if self.permission is None:
      raise TProtocol.TProtocolException(message='Required field permission is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.developerId)
    value = (value * 31) ^ hash(self.permission)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RevokePermissionRequest(object):
  """
  Attributes:
   - queueName
   - developerId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'developerId', None, None, ), # 2
  )

  def __init__(self, queueName=None, developerId=None,):
    self.queueName = queueName
    self.developerId = developerId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.developerId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RevokePermissionRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.developerId is not None:
      oprot.writeFieldBegin('developerId', TType.STRING, 2)
      oprot.writeString(self.developerId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.developerId is None:
      raise TProtocol.TProtocolException(message='Required field developerId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.developerId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryPermissionRequest(object):
  """
  Attributes:
   - queueName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
  )

  def __init__(self, queueName=None,):
    self.queueName = queueName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryPermissionRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryPermissionResponse(object):
  """
  Attributes:
   - permission
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'permission', None, None, ), # 1
  )

  def __init__(self, permission=None,):
    self.permission = permission

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.permission = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryPermissionResponse')
    if self.permission is not None:
      oprot.writeFieldBegin('permission', TType.I32, 1)
      oprot.writeI32(self.permission)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.permission is None:
      raise TProtocol.TProtocolException(message='Required field permission is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.permission)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryPermissionForIdRequest(object):
  """
  Attributes:
   - queueName
   - developerId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'developerId', None, None, ), # 2
  )

  def __init__(self, queueName=None, developerId=None,):
    self.queueName = queueName
    self.developerId = developerId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.developerId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryPermissionForIdRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.developerId is not None:
      oprot.writeFieldBegin('developerId', TType.STRING, 2)
      oprot.writeString(self.developerId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.developerId is None:
      raise TProtocol.TProtocolException(message='Required field developerId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.developerId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueryPermissionForIdResponse(object):
  """
  Attributes:
   - permission
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'permission', None, None, ), # 1
  )

  def __init__(self, permission=None,):
    self.permission = permission

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.permission = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueryPermissionForIdResponse')
    if self.permission is not None:
      oprot.writeFieldBegin('permission', TType.I32, 1)
      oprot.writeI32(self.permission)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.permission is None:
      raise TProtocol.TProtocolException(message='Required field permission is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.permission)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListPermissionsRequest(object):
  """
  Attributes:
   - queueName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
  )

  def __init__(self, queueName=None,):
    self.queueName = queueName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListPermissionsRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ListPermissionsResponse(object):
  """
  Attributes:
   - permissionList
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'permissionList', (TType.STRING,None,TType.I32,None), None, ), # 1
  )

  def __init__(self, permissionList=None,):
    self.permissionList = permissionList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.permissionList = {}
          (_ktype17, _vtype18, _size16 ) = iprot.readMapBegin()
          for _i20 in xrange(_size16):
            _key21 = iprot.readString();
            _val22 = iprot.readI32();
            self.permissionList[_key21] = _val22
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ListPermissionsResponse')
    if self.permissionList is not None:
      oprot.writeFieldBegin('permissionList', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.permissionList))
      for kiter23,viter24 in self.permissionList.items():
        oprot.writeString(kiter23)
        oprot.writeI32(viter24)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.permissionList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
