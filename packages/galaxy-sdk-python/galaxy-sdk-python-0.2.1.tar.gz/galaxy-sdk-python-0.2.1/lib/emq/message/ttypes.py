# encoding: utf-8
#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import emq.common.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class MessageAttribute(object):
  """
  Copyright 2015, Xiaomi.
  All rights reserved.
  Author: shenyuannan@xiaomi.com

  Attributes:
   - name: name of the attribute
  must be unique in one message
   - type: must start with "STRING" or "BINARY", with an optional "." and a user-defined sub-type
  like "STRING.INTEGER" or "BINARY.JPEG"
  do not contain characters excepts alphabets, digits or "."

   - stringValue: must be set if type is "STRING"

   - binaryValue: must be set if type is "BINARY"

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRING, 'type', None, None, ), # 2
    (3, TType.STRING, 'stringValue', None, None, ), # 3
    (4, TType.STRING, 'binaryValue', None, None, ), # 4
  )

  def __init__(self, name=None, type=None, stringValue=None, binaryValue=None,):
    self.name = name
    self.type = type
    self.stringValue = stringValue
    self.binaryValue = binaryValue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.stringValue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.binaryValue = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MessageAttribute')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 2)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.stringValue is not None:
      oprot.writeFieldBegin('stringValue', TType.STRING, 3)
      oprot.writeString(self.stringValue)
      oprot.writeFieldEnd()
    if self.binaryValue is not None:
      oprot.writeFieldBegin('binaryValue', TType.STRING, 4)
      oprot.writeString(self.binaryValue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.stringValue)
    value = (value * 31) ^ hash(self.binaryValue)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendMessageRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - messageBody: Message body;

   - delaySeconds: Delay seconds for this message, this will overwrite delaySecond of this
  queue, default 0s (0s ~ 15min);

   - invisibilitySeconds: Invisibility seconds for this message, this will overwrite
  invisibilitySeconds of this queue, default 30s (0s ~ 12hour);

   - messageAttributes: User-defined attributes attached to message

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'messageBody', None, None, ), # 2
    (3, TType.I32, 'delaySeconds', None, None, ), # 3
    (4, TType.I32, 'invisibilitySeconds', None, None, ), # 4
    (5, TType.LIST, 'messageAttributes', (TType.STRUCT,(MessageAttribute, MessageAttribute.thrift_spec)), None, ), # 5
  )

  def __init__(self, queueName=None, messageBody=None, delaySeconds=None, invisibilitySeconds=None, messageAttributes=None,):
    self.queueName = queueName
    self.messageBody = messageBody
    self.delaySeconds = delaySeconds
    self.invisibilitySeconds = invisibilitySeconds
    self.messageAttributes = messageAttributes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.messageBody = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.delaySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.invisibilitySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.messageAttributes = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = MessageAttribute()
            _elem5.read(iprot)
            self.messageAttributes.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendMessageRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.messageBody is not None:
      oprot.writeFieldBegin('messageBody', TType.STRING, 2)
      oprot.writeString(self.messageBody)
      oprot.writeFieldEnd()
    if self.delaySeconds is not None:
      oprot.writeFieldBegin('delaySeconds', TType.I32, 3)
      oprot.writeI32(self.delaySeconds)
      oprot.writeFieldEnd()
    if self.invisibilitySeconds is not None:
      oprot.writeFieldBegin('invisibilitySeconds', TType.I32, 4)
      oprot.writeI32(self.invisibilitySeconds)
      oprot.writeFieldEnd()
    if self.messageAttributes is not None:
      oprot.writeFieldBegin('messageAttributes', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.messageAttributes))
      for iter6 in self.messageAttributes:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.messageBody is None:
      raise TProtocol.TProtocolException(message='Required field messageBody is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.messageBody)
    value = (value * 31) ^ hash(self.delaySeconds)
    value = (value * 31) ^ hash(self.invisibilitySeconds)
    value = (value * 31) ^ hash(self.messageAttributes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendMessageResponse(object):
  """
  Attributes:
   - messageID: MessageID for the send message, it should in format
  "partititonID:createTimestamp:sequenceID";

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'messageID', None, None, ), # 1
  )

  def __init__(self, messageID=None,):
    self.messageID = messageID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.messageID = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendMessageResponse')
    if self.messageID is not None:
      oprot.writeFieldBegin('messageID', TType.STRING, 1)
      oprot.writeString(self.messageID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.messageID is None:
      raise TProtocol.TProtocolException(message='Required field messageID is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.messageID)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendMessageBatchRequestEntry(object):
  """
  Attributes:
   - entryId: The identifier for this partitcular receipt handle;
  Using to identify the result in response;
  Need to be unique within one batch

   - messageBody: Message body;

   - delaySeconds: Delay seconds for this message, this will overwrite delaySecond of this
  queue, default 0s (0s ~ 15min);

   - invisibilitySeconds: Invisibility seconds for this message, this will overwrite
  invisibilitySeconds of this queue, default 30s (0s ~ 12hour);

   - messageAttributes: User-defined attributes attached to message

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'entryId', None, None, ), # 1
    (2, TType.STRING, 'messageBody', None, None, ), # 2
    (3, TType.I32, 'delaySeconds', None, None, ), # 3
    (4, TType.I32, 'invisibilitySeconds', None, None, ), # 4
    (5, TType.LIST, 'messageAttributes', (TType.STRUCT,(MessageAttribute, MessageAttribute.thrift_spec)), None, ), # 5
  )

  def __init__(self, entryId=None, messageBody=None, delaySeconds=None, invisibilitySeconds=None, messageAttributes=None,):
    self.entryId = entryId
    self.messageBody = messageBody
    self.delaySeconds = delaySeconds
    self.invisibilitySeconds = invisibilitySeconds
    self.messageAttributes = messageAttributes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.entryId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.messageBody = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.delaySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.invisibilitySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.messageAttributes = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = MessageAttribute()
            _elem12.read(iprot)
            self.messageAttributes.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendMessageBatchRequestEntry')
    if self.entryId is not None:
      oprot.writeFieldBegin('entryId', TType.STRING, 1)
      oprot.writeString(self.entryId)
      oprot.writeFieldEnd()
    if self.messageBody is not None:
      oprot.writeFieldBegin('messageBody', TType.STRING, 2)
      oprot.writeString(self.messageBody)
      oprot.writeFieldEnd()
    if self.delaySeconds is not None:
      oprot.writeFieldBegin('delaySeconds', TType.I32, 3)
      oprot.writeI32(self.delaySeconds)
      oprot.writeFieldEnd()
    if self.invisibilitySeconds is not None:
      oprot.writeFieldBegin('invisibilitySeconds', TType.I32, 4)
      oprot.writeI32(self.invisibilitySeconds)
      oprot.writeFieldEnd()
    if self.messageAttributes is not None:
      oprot.writeFieldBegin('messageAttributes', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.messageAttributes))
      for iter13 in self.messageAttributes:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.entryId is None:
      raise TProtocol.TProtocolException(message='Required field entryId is unset!')
    if self.messageBody is None:
      raise TProtocol.TProtocolException(message='Required field messageBody is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.entryId)
    value = (value * 31) ^ hash(self.messageBody)
    value = (value * 31) ^ hash(self.delaySeconds)
    value = (value * 31) ^ hash(self.invisibilitySeconds)
    value = (value * 31) ^ hash(self.messageAttributes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendMessageBatchRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - sendMessageBatchRequestEntryList: List of SendMessageBatchRequestEntry;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.LIST, 'sendMessageBatchRequestEntryList', (TType.STRUCT,(SendMessageBatchRequestEntry, SendMessageBatchRequestEntry.thrift_spec)), None, ), # 2
  )

  def __init__(self, queueName=None, sendMessageBatchRequestEntryList=None,):
    self.queueName = queueName
    self.sendMessageBatchRequestEntryList = sendMessageBatchRequestEntryList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.sendMessageBatchRequestEntryList = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = SendMessageBatchRequestEntry()
            _elem19.read(iprot)
            self.sendMessageBatchRequestEntryList.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendMessageBatchRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.sendMessageBatchRequestEntryList is not None:
      oprot.writeFieldBegin('sendMessageBatchRequestEntryList', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.sendMessageBatchRequestEntryList))
      for iter20 in self.sendMessageBatchRequestEntryList:
        iter20.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.sendMessageBatchRequestEntryList is None:
      raise TProtocol.TProtocolException(message='Required field sendMessageBatchRequestEntryList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.sendMessageBatchRequestEntryList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendMessageBatchResponseEntry(object):
  """
  Attributes:
   - entryId: corresponding to the entryId in request

   - messageID: MessageID for the send message, it should in format
  "partititonID:createTimestamp:sequenceID";

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'entryId', None, None, ), # 1
    (2, TType.STRING, 'messageID', None, None, ), # 2
  )

  def __init__(self, entryId=None, messageID=None,):
    self.entryId = entryId
    self.messageID = messageID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.entryId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.messageID = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendMessageBatchResponseEntry')
    if self.entryId is not None:
      oprot.writeFieldBegin('entryId', TType.STRING, 1)
      oprot.writeString(self.entryId)
      oprot.writeFieldEnd()
    if self.messageID is not None:
      oprot.writeFieldBegin('messageID', TType.STRING, 2)
      oprot.writeString(self.messageID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.entryId is None:
      raise TProtocol.TProtocolException(message='Required field entryId is unset!')
    if self.messageID is None:
      raise TProtocol.TProtocolException(message='Required field messageID is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.entryId)
    value = (value * 31) ^ hash(self.messageID)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MessageBatchErrorEntry(object):
  """
  Attributes:
   - id: corresponding to the entryId/receiptHandle in request

   - reason: The exception indicate why the request entry failed

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'id', None, None, ), # 1
    (2, TType.STRUCT, 'reason', (emq.common.ttypes.GalaxyEmqServiceException, emq.common.ttypes.GalaxyEmqServiceException.thrift_spec), None, ), # 2
  )

  def __init__(self, id=None, reason=None,):
    self.id = id
    self.reason = reason

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.reason = emq.common.ttypes.GalaxyEmqServiceException()
          self.reason.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MessageBatchErrorEntry')
    if self.id is not None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.reason is not None:
      oprot.writeFieldBegin('reason', TType.STRUCT, 2)
      self.reason.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.id is None:
      raise TProtocol.TProtocolException(message='Required field id is unset!')
    if self.reason is None:
      raise TProtocol.TProtocolException(message='Required field reason is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.id)
    value = (value * 31) ^ hash(self.reason)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SendMessageBatchResponse(object):
  """
  Attributes:
   - successful: The sucessful results list;

   - failed: Failed results list;

  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'successful', (TType.STRUCT,(SendMessageBatchResponseEntry, SendMessageBatchResponseEntry.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'failed', (TType.STRUCT,(MessageBatchErrorEntry, MessageBatchErrorEntry.thrift_spec)), None, ), # 2
  )

  def __init__(self, successful=None, failed=None,):
    self.successful = successful
    self.failed = failed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.successful = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = SendMessageBatchResponseEntry()
            _elem26.read(iprot)
            self.successful.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.failed = []
          (_etype30, _size27) = iprot.readListBegin()
          for _i31 in xrange(_size27):
            _elem32 = MessageBatchErrorEntry()
            _elem32.read(iprot)
            self.failed.append(_elem32)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SendMessageBatchResponse')
    if self.successful is not None:
      oprot.writeFieldBegin('successful', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.successful))
      for iter33 in self.successful:
        iter33.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.failed is not None:
      oprot.writeFieldBegin('failed', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.failed))
      for iter34 in self.failed:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.successful)
    value = (value * 31) ^ hash(self.failed)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ReceiveMessageRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - maxReceiveMessageNumber: Max receive message number, default 100 (1 ~ 100);

   - maxReceiveMessageWaitSeconds: Max receive message wait seconds, default 20s (0 ~ 20), 0s means no wait;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.I32, 'maxReceiveMessageNumber', None, 100, ), # 2
    (3, TType.I32, 'maxReceiveMessageWaitSeconds', None, 0, ), # 3
  )

  def __init__(self, queueName=None, maxReceiveMessageNumber=thrift_spec[2][4], maxReceiveMessageWaitSeconds=thrift_spec[3][4],):
    self.queueName = queueName
    self.maxReceiveMessageNumber = maxReceiveMessageNumber
    self.maxReceiveMessageWaitSeconds = maxReceiveMessageWaitSeconds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.maxReceiveMessageNumber = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.maxReceiveMessageWaitSeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ReceiveMessageRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.maxReceiveMessageNumber is not None:
      oprot.writeFieldBegin('maxReceiveMessageNumber', TType.I32, 2)
      oprot.writeI32(self.maxReceiveMessageNumber)
      oprot.writeFieldEnd()
    if self.maxReceiveMessageWaitSeconds is not None:
      oprot.writeFieldBegin('maxReceiveMessageWaitSeconds', TType.I32, 3)
      oprot.writeI32(self.maxReceiveMessageWaitSeconds)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.maxReceiveMessageNumber)
    value = (value * 31) ^ hash(self.maxReceiveMessageWaitSeconds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ReceiveMessageResponse(object):
  """
  Attributes:
   - messageID: MessageID for the received message;

   - receiptHandle: Receipt Handle for the received message
  Using when change visibility time/delete message

   - messageBody: Message body for the received message;

   - messageAttributes: User-defined attributes attached to message

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'messageID', None, None, ), # 1
    (2, TType.STRING, 'receiptHandle', None, None, ), # 2
    (3, TType.STRING, 'messageBody', None, None, ), # 3
    (4, TType.LIST, 'messageAttributes', (TType.STRUCT,(MessageAttribute, MessageAttribute.thrift_spec)), None, ), # 4
  )

  def __init__(self, messageID=None, receiptHandle=None, messageBody=None, messageAttributes=None,):
    self.messageID = messageID
    self.receiptHandle = receiptHandle
    self.messageBody = messageBody
    self.messageAttributes = messageAttributes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.messageID = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.receiptHandle = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.messageBody = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.messageAttributes = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = MessageAttribute()
            _elem40.read(iprot)
            self.messageAttributes.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ReceiveMessageResponse')
    if self.messageID is not None:
      oprot.writeFieldBegin('messageID', TType.STRING, 1)
      oprot.writeString(self.messageID)
      oprot.writeFieldEnd()
    if self.receiptHandle is not None:
      oprot.writeFieldBegin('receiptHandle', TType.STRING, 2)
      oprot.writeString(self.receiptHandle)
      oprot.writeFieldEnd()
    if self.messageBody is not None:
      oprot.writeFieldBegin('messageBody', TType.STRING, 3)
      oprot.writeString(self.messageBody)
      oprot.writeFieldEnd()
    if self.messageAttributes is not None:
      oprot.writeFieldBegin('messageAttributes', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.messageAttributes))
      for iter41 in self.messageAttributes:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.messageID is None:
      raise TProtocol.TProtocolException(message='Required field messageID is unset!')
    if self.receiptHandle is None:
      raise TProtocol.TProtocolException(message='Required field receiptHandle is unset!')
    if self.messageBody is None:
      raise TProtocol.TProtocolException(message='Required field messageBody is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.messageID)
    value = (value * 31) ^ hash(self.receiptHandle)
    value = (value * 31) ^ hash(self.messageBody)
    value = (value * 31) ^ hash(self.messageAttributes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ChangeMessageVisibilityRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - receiptHandle: receiptHandle for change visibility;

   - invisibilitySeconds: The extra invisibilitySeconds for this message, the invisibility seconds
  will be (oldIvisibulitySeconds + newInvisibilitySeconds), and can only
  affect on the newly received message and ont exceed old invisibilitySeconds;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'receiptHandle', None, None, ), # 2
    (3, TType.I32, 'invisibilitySeconds', None, None, ), # 3
  )

  def __init__(self, queueName=None, receiptHandle=None, invisibilitySeconds=None,):
    self.queueName = queueName
    self.receiptHandle = receiptHandle
    self.invisibilitySeconds = invisibilitySeconds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.receiptHandle = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.invisibilitySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ChangeMessageVisibilityRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.receiptHandle is not None:
      oprot.writeFieldBegin('receiptHandle', TType.STRING, 2)
      oprot.writeString(self.receiptHandle)
      oprot.writeFieldEnd()
    if self.invisibilitySeconds is not None:
      oprot.writeFieldBegin('invisibilitySeconds', TType.I32, 3)
      oprot.writeI32(self.invisibilitySeconds)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.receiptHandle is None:
      raise TProtocol.TProtocolException(message='Required field receiptHandle is unset!')
    if self.invisibilitySeconds is None:
      raise TProtocol.TProtocolException(message='Required field invisibilitySeconds is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.receiptHandle)
    value = (value * 31) ^ hash(self.invisibilitySeconds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ChangeMessageVisibilityBatchRequestEntry(object):
  """
  Attributes:
   - receiptHandle: receiptHandle for change visibility;

   - invisibilitySeconds: The extra invisibilitySeconds for this message, the invisibility seconds
  will be (oldIvisibulitySeconds + newInvisibilitySeconds), and can only
  affect on the newly received message and ont exceed old invisibilitySeconds;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'receiptHandle', None, None, ), # 1
    (2, TType.I32, 'invisibilitySeconds', None, None, ), # 2
  )

  def __init__(self, receiptHandle=None, invisibilitySeconds=None,):
    self.receiptHandle = receiptHandle
    self.invisibilitySeconds = invisibilitySeconds

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.receiptHandle = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.invisibilitySeconds = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ChangeMessageVisibilityBatchRequestEntry')
    if self.receiptHandle is not None:
      oprot.writeFieldBegin('receiptHandle', TType.STRING, 1)
      oprot.writeString(self.receiptHandle)
      oprot.writeFieldEnd()
    if self.invisibilitySeconds is not None:
      oprot.writeFieldBegin('invisibilitySeconds', TType.I32, 2)
      oprot.writeI32(self.invisibilitySeconds)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.receiptHandle is None:
      raise TProtocol.TProtocolException(message='Required field receiptHandle is unset!')
    if self.invisibilitySeconds is None:
      raise TProtocol.TProtocolException(message='Required field invisibilitySeconds is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.receiptHandle)
    value = (value * 31) ^ hash(self.invisibilitySeconds)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ChangeMessageVisibilityBatchRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - changeMessageVisibilityRequestEntryList: List of ChangeMessageVisibilityRequest;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.LIST, 'changeMessageVisibilityRequestEntryList', (TType.STRUCT,(ChangeMessageVisibilityBatchRequestEntry, ChangeMessageVisibilityBatchRequestEntry.thrift_spec)), None, ), # 2
  )

  def __init__(self, queueName=None, changeMessageVisibilityRequestEntryList=None,):
    self.queueName = queueName
    self.changeMessageVisibilityRequestEntryList = changeMessageVisibilityRequestEntryList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.changeMessageVisibilityRequestEntryList = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = ChangeMessageVisibilityBatchRequestEntry()
            _elem47.read(iprot)
            self.changeMessageVisibilityRequestEntryList.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ChangeMessageVisibilityBatchRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.changeMessageVisibilityRequestEntryList is not None:
      oprot.writeFieldBegin('changeMessageVisibilityRequestEntryList', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.changeMessageVisibilityRequestEntryList))
      for iter48 in self.changeMessageVisibilityRequestEntryList:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.changeMessageVisibilityRequestEntryList is None:
      raise TProtocol.TProtocolException(message='Required field changeMessageVisibilityRequestEntryList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.changeMessageVisibilityRequestEntryList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ChangeMessageVisibilityBatchResponse(object):
  """
  Attributes:
   - successful: The sucessful receipt handle;

   - failed: Failed results list;
  Using receipt handle to index

  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'successful', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'failed', (TType.STRUCT,(MessageBatchErrorEntry, MessageBatchErrorEntry.thrift_spec)), None, ), # 2
  )

  def __init__(self, successful=None, failed=None,):
    self.successful = successful
    self.failed = failed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.successful = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = iprot.readString();
            self.successful.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.failed = []
          (_etype58, _size55) = iprot.readListBegin()
          for _i59 in xrange(_size55):
            _elem60 = MessageBatchErrorEntry()
            _elem60.read(iprot)
            self.failed.append(_elem60)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ChangeMessageVisibilityBatchResponse')
    if self.successful is not None:
      oprot.writeFieldBegin('successful', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.successful))
      for iter61 in self.successful:
        oprot.writeString(iter61)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.failed is not None:
      oprot.writeFieldBegin('failed', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.failed))
      for iter62 in self.failed:
        iter62.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.successful)
    value = (value * 31) ^ hash(self.failed)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteMessageRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - receiptHandle: receipt handle of message to delete;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.STRING, 'receiptHandle', None, None, ), # 2
  )

  def __init__(self, queueName=None, receiptHandle=None,):
    self.queueName = queueName
    self.receiptHandle = receiptHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.receiptHandle = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteMessageRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.receiptHandle is not None:
      oprot.writeFieldBegin('receiptHandle', TType.STRING, 2)
      oprot.writeString(self.receiptHandle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.receiptHandle is None:
      raise TProtocol.TProtocolException(message='Required field receiptHandle is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.receiptHandle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteMessageBatchRequestEntry(object):
  """
  Attributes:
   - receiptHandle: receipt handle of message to delete;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'receiptHandle', None, None, ), # 1
  )

  def __init__(self, receiptHandle=None,):
    self.receiptHandle = receiptHandle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.receiptHandle = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteMessageBatchRequestEntry')
    if self.receiptHandle is not None:
      oprot.writeFieldBegin('receiptHandle', TType.STRING, 1)
      oprot.writeString(self.receiptHandle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.receiptHandle is None:
      raise TProtocol.TProtocolException(message='Required field receiptHandle is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.receiptHandle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteMessageBatchRequest(object):
  """
  Attributes:
   - queueName: Queue name;

   - deleteMessageBatchRequestEntryList: List of DeleteMessageRequest;

  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'queueName', None, None, ), # 1
    (2, TType.LIST, 'deleteMessageBatchRequestEntryList', (TType.STRUCT,(DeleteMessageBatchRequestEntry, DeleteMessageBatchRequestEntry.thrift_spec)), None, ), # 2
  )

  def __init__(self, queueName=None, deleteMessageBatchRequestEntryList=None,):
    self.queueName = queueName
    self.deleteMessageBatchRequestEntryList = deleteMessageBatchRequestEntryList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.queueName = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.deleteMessageBatchRequestEntryList = []
          (_etype66, _size63) = iprot.readListBegin()
          for _i67 in xrange(_size63):
            _elem68 = DeleteMessageBatchRequestEntry()
            _elem68.read(iprot)
            self.deleteMessageBatchRequestEntryList.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteMessageBatchRequest')
    if self.queueName is not None:
      oprot.writeFieldBegin('queueName', TType.STRING, 1)
      oprot.writeString(self.queueName)
      oprot.writeFieldEnd()
    if self.deleteMessageBatchRequestEntryList is not None:
      oprot.writeFieldBegin('deleteMessageBatchRequestEntryList', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.deleteMessageBatchRequestEntryList))
      for iter69 in self.deleteMessageBatchRequestEntryList:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.queueName is None:
      raise TProtocol.TProtocolException(message='Required field queueName is unset!')
    if self.deleteMessageBatchRequestEntryList is None:
      raise TProtocol.TProtocolException(message='Required field deleteMessageBatchRequestEntryList is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.queueName)
    value = (value * 31) ^ hash(self.deleteMessageBatchRequestEntryList)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class DeleteMessageBatchResponse(object):
  """
  Attributes:
   - successful: The sucessful receipt handle;

   - failed: Failed results list;
  Using receipt handle to index

  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'successful', (TType.STRING,None), None, ), # 1
    (2, TType.LIST, 'failed', (TType.STRUCT,(MessageBatchErrorEntry, MessageBatchErrorEntry.thrift_spec)), None, ), # 2
  )

  def __init__(self, successful=None, failed=None,):
    self.successful = successful
    self.failed = failed

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.successful = []
          (_etype73, _size70) = iprot.readListBegin()
          for _i74 in xrange(_size70):
            _elem75 = iprot.readString();
            self.successful.append(_elem75)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.failed = []
          (_etype79, _size76) = iprot.readListBegin()
          for _i80 in xrange(_size76):
            _elem81 = MessageBatchErrorEntry()
            _elem81.read(iprot)
            self.failed.append(_elem81)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('DeleteMessageBatchResponse')
    if self.successful is not None:
      oprot.writeFieldBegin('successful', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.successful))
      for iter82 in self.successful:
        oprot.writeString(iter82)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.failed is not None:
      oprot.writeFieldBegin('failed', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.failed))
      for iter83 in self.failed:
        iter83.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.successful)
    value = (value * 31) ^ hash(self.failed)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
